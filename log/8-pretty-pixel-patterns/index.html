<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content=ekunazanu name=author><meta content="Playing around with pixels." name=description><meta content="Pretty Pixel Patterns" property=og:title><meta content=article property=og:type><meta content="Playing around with pixels." property=og:description><meta content=https://ekunazanu.foo/log/8-pretty-pixel-patterns/ property=og:url><meta content=https://ekunazanu.foo/thumbnails/log.8.pixels.avif.png property=og:image><meta content="Doodle of pixels and functions." property=og:image:alt><meta content=image/png property=og:image:type><meta content=1200 property=og:image:width><meta content=900 property=og:image:height><meta content=en_US property=og:locale><meta content=ekunazanu.foo property=og:site_name><title>Pretty Pixel Patterns ~ ekunazanu.foo</title><link href=https://ekunazanu.foo/log/8-pretty-pixel-patterns/ rel=cannonical><link href=https://ekunazanu.foo/atom.xml rel=alternate type=application/atom+xml><link href=https://ekunazanu.foo/misc/main.css rel=stylesheet><link href=https://ekunazanu.foo/misc/favicon.png rel=icon><meta content=Zola name=generator><body><nav><ul><li><h2><a href=https://ekunazanu.foo>ekunazanu.foo</a></h2><li><a href=https://ekunazanu.foo/log>Log</a> ⟶<li><a href=https://ekunazanu.foo/lab>Lab</a></ul></nav><div class=print>https://ekunazanu.foo</div><main><article><h1>Pretty Pixel Patterns</h1><p>Week went by quick. Had quizzes, cleaned some of my digital library but I still have to organize all my accounts and data. But I should be done with most of the things I <em>need</em> to get done by next week. After that, I can go back to The Plan™. If you still remember that.<p>In other news, I tried to generate <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Perlin_noise#Algorithm_detail target=_blank>Perlin noise</a>, and that led to me experimenting with pixel coloring. Surprisingly good looking patterns can arise from very simple bitwise and arithmetic operations. I colored the pixels based on their position — the intensity for each channel for a pixel is a function of its spatial coordinates — and that was enough for generating some very interesting images. I want to show a few nice ones:<details><summary>Enable JavaScript</summary> <p>If the images are not visible, JavaScript is probably disabled; you will need to enable JavaScript to render the patterns. The images are rendered on the browser because compression algorithms distort the patterns and lossless formats take up too much space — and I really don’t want to pollute my Git history with big binary files, even with LFS enabled.</p> <p>On a side note, I don’t like how JavaScript has no native support for 8-bit unsigned integers. I initially wrote this in Go, and it felt ugly adding extra logic in JavaScript just to recreate 8-bit overflows and underflows.</p></details><ol><li>Gradients — (x, y, !x). The pixels become redder towards the right, greener towards the bottom, and bluer towards the left. It is an 8-bit image so the pattern repeats after every 256 pixels.</ol><p><canvas id=canvas0></canvas><ol start=2><li>Shadows — (x+y, x+y, x+y). The pixel value is a simple linear x+y, so diagonal pixels have the same intensity values. The image is grayscale since all the channels have the same value for a given pixel.</ol><p><canvas id=canvas1></canvas><ol start=3><li>Candy — (x+y, x+y+85, x+y+171). It similar to the above pattern, but the added offsets ‘separate’ each channel and create distinct bands.</ol><p><canvas id=canvas2></canvas><ol start=4><li>Waves — (0, (x%y)/2, x%y). The intensity of the blue (and green) channel increases as x increases, until the diagonal x=y — where it resets as the remainder becomes zero. It happens again at diagonals x=2y, x=3y, x=4y, etc.</ol><p><canvas id=canvas3></canvas><ol start=5><li>Boxer — (x, x^y, x+y). The diagonal gradient is because of the red and blue channels. The alternating squares is due to the green channel’s x^y. I feel the XOR is a great way to represent the frequency of bit flips at different indices — each square boundary represents a bit flip at some index. Higher the contrast, higher the index of the bit flip.</ol><p><canvas id=canvas4></canvas><ol start=6><li>Ripples — (63, x*x+y*y, 175). The pixels having same intensity k for x*x+y*y=k follow the equation for a circle — and hence the pattern. The narrowing concentric circles also reveal the exponential nature of the function and the modular nature of unsigned integers. There are some nice interference patterns going as well.</ol><p><canvas id=canvas5></canvas><ol start=7><li>Hyperbolic — (x*x-y*y, x*x-y*y, x*x-y*y). Just as x*x+y*y is the equation for a circle, x*x-y*y is the equation for a hyperbola. So instead of narrowing concentric circles, the pattern now consists of narrowing concentric hyperbolas.</ol><p><canvas id=canvas6></canvas><ol start=8><li>Chip — (255, (x&y)*y, x). The x&y has a look similar to the XOR pattern, and multiplying it with y gives it with a high-frequency, grain-y look. Additionally, the red and blue channels are defined to give it a silicon-wafer-reflection-esque look.</ol><p><canvas id=canvas7></canvas><ol start=9><li>Matrix — (0, (x^y)*(x^y), 0). From this point on, why the patterns emerge the way it does is beyond me. If you know, please share; I would love to know it too. Functions from here on are mostly a result of me trying to make the patterns look pretty.</ol><p><canvas id=canvas8></canvas><ol start=10><li>Temple — (((x*x)&y)*y, ((x*x)&y)*y, 32). Looks like pillars, as well as patterns etched on the walls of old temples.</ol><p><canvas id=canvas9></canvas><ol start=11><li>Peacock — (0, x*x*y*y, x*x*x*y*y*y). I think this is one of the prettiest patterns. The colors remind me of the feathers of a peacock.</ol><p><canvas id=canvas10></canvas><ol start=12><li>Crimson — ((x^(x*x*y*y))&y, 0, 0). Uses the same x*x*y*y function but masked with an XOR with x and an AND with y. I feel like this can be the loading screen of a bloody horror-thriller game.</ol><p><canvas id=canvas11></canvas><ol start=13><li>Phases — (x^(x*x*y*y)/2, (x*x*y*y)^y, (x*x*y*y)^x^y). Pretty much the same pattern as before, but the green and blue channels have slightly altered versions of the same function resulting in different colors. Makes it look light like night and morning.</ol><p><canvas id=canvas12></canvas><p>There are more functions but I found these the most pretty.<h2 id=Melting_Metal_and_Mental_States>Melting Metal and Mental States</h2><p>I also experimented with hardware a bit. I bought a small TFT display but it did not come with pins attached. I had a few pins laying around so I decided to solder it, but ended up causing chaos: I inhaled the lead-tin fumes, my friend ingested it. I burnt my fingers, and as a reflex threw the solder on my friend — he dodged it, but burnt his fingers later anyway. I was holding the solder <del>near</del> on top of some cup noodles and managed to get its plastic melted and stuck on the gun. Tried to sand it off with paper and the paper burnt. Also right as I threw the solder gun, it melted the solder wire itself exposing the copper inside. Another guy came to help us and got a mild shock from it. It was chaotic but also quite comical to say the least.<p><img alt="doodle of a person soldering and lighting things on fire and another person with a burnt finger looking and another person in the background horrified" decoding=async loading=lazy src=/media/log/solder-chaos.avif><p>Watching a tutorial on how to use a solder properly seems like the saner (and obvious) approach in retrospect.<p>Anyway that is all for this week. Cya next week.</p><script>var canvasList = []
const scale = 2;
for (let i = 0; i < 13; i++) {
    canvasList[i] = document.getElementById(`canvas${i}`).getContext("2d");
    canvasList[i].canvas.width = 512 * scale;
    canvasList[i].canvas.height = 256 * scale;
}

async function generatePattern(canvasCurr, rFunc, gFunc, bFunc) {
    const width = canvasCurr.canvas.width;
    const height = canvasCurr.canvas.height;
    const imageData = canvasCurr.createImageData(width, height);
    const data = imageData.data;
    for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
            const index = (y * width + x) * 4;
            data[index]     = (rFunc(x/scale, y/scale)) % 0x100;
            data[index + 1] = (gFunc(x/scale, y/scale)) % 0x100;
            data[index + 2] = (bFunc(x/scale, y/scale)) % 0x100;
            data[index + 3] = 0xFF;
        }
    }
    canvasCurr.putImageData(imageData, 0, 0);
}

generatePattern(canvasList[0], (x,y)=> x, (x,y)=> y, (x,y)=> x^0xFF);
generatePattern(canvasList[1], (x,y)=> x+y, (x,y)=> x+y, (x,y)=> x+y);
generatePattern(canvasList[2], (x,y)=> x+y, (x,y)=> x+y+85, (x,y)=> x+y+171);
generatePattern(canvasList[3], (x,y)=> 0, (x,y)=> (x % 0x100) % (y % 0x100)/2, (x,y)=> (x % 0x100) % (y % 0x100));
generatePattern(canvasList[4], (x,y)=> x, (x,y)=> x^y, (x,y)=> x+y);
generatePattern(canvasList[5], (x,y)=> 0x3F, (x,y)=> scale*x*x+scale*y*y, (x,y)=> 0xAF);
generatePattern(canvasList[6], (x,y)=> ((scale*x*x-scale*y*y) % 0x100) + 0x100, (x,y)=> ((scale*x*x-scale*y*y) % 0x100) + 0x100, (x,y)=> ((scale*x*x-scale*y*y) % 0x100) + 0x100);
generatePattern(canvasList[7], (x,y)=> 0xFF, (x,y)=> ((x&y) % 0x100) * y, (x,y)=> x);
generatePattern(canvasList[8], (x,y)=> 0, (x,y)=> (x^y)*(x^y), (x,y)=> 0);
generatePattern(canvasList[9], (x,y)=> (((x*x*scale*scale)&y)*y), (x,y)=> (((x*x*scale*scale)&y)*y), (x,y)=> 0x20); // the correct scaling not multiply twice, but it looks bad
generatePattern(canvasList[10], (x,y)=> 0, (x,y)=> ((x*y) % 0x100)*((x*y) % 0x100) * scale*scale*scale, (x,y)=> ((x*y) % 0x100)*((x*y) % 0x100)*((x*y) % 0x100) * scale*scale*scale*scale*scale);
generatePattern(canvasList[11], (x,y)=> (x^((((x*x*y*y)%0x100)*scale*scale*scale) % 0x100))&y, (x,y)=> 0, (x,y)=> 0);
generatePattern(canvasList[12], (x,y)=> ((x*scale)^((((x*x*y*y)%0x100)*scale*scale*scale) % 0x100))/2, (x,y)=> (y^((((x*x*y*y)%0x100)*scale*scale*scale) % 0x100)), (x,y)=> (x^y^((((x*x*y*y)%0x100)*scale*scale*scale) % 0x100)));</script><style>canvas{image-rendering:pixelated}</style></article></main><footer><a href=https://ekunazanu.foo/more#Terms_of_Use>© 2025</a> <a href=https://ekunazanu.foo/about>ekunazanu</a> · <a rel="noopener nofollow noreferrer" href=https://creativecommons.org/licenses/by/4.0/ target=_blank>CC BY 4.0</a> · <a rel="noopener nofollow noreferrer" href=https://github.com/ekunazanu/ekunazanu.foo target=_blank>Source</a></footer>