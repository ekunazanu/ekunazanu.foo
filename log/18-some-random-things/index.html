<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content=ekunazanu name=author><meta content="Posting on a random Thursday?" name=description><meta content="Some Random Things" property=og:title><meta content=article property=og:type><meta content="Posting on a random Thursday?" property=og:description><meta content=https://ekunazanu.foo/log/18-some-random-things/ property=og:url><meta content=https://ekunazanu.foo/thumbnails/log.18.dice.avif.png property=og:image><meta content="Doodle of two dice being rolled." property=og:image:alt><meta content=image/png property=og:image:type><meta content=1200 property=og:image:width><meta content=900 property=og:image:height><meta content=en_US property=og:locale><meta content=ekunazanu.foo property=og:site_name><title>Some Random Things ~ ekunazanu.foo</title><link href=https://ekunazanu.foo/log/18-some-random-things/ rel=cannonical><link href=https://ekunazanu.foo/atom.xml rel=alternate type=application/atom+xml><link href=https://ekunazanu.foo/misc/main.css rel=stylesheet><link href=https://ekunazanu.foo/misc/favicon.png rel=icon><meta content=Zola name=generator><body><nav><ul><li><h2><a href=https://ekunazanu.foo>ekunazanu.foo</a></h2><li><a href=https://ekunazanu.foo/log>Log</a> ⟶<li><a href=https://ekunazanu.foo/lab>Lab</a></ul></nav><div class=print>https://ekunazanu.foo</div><main><article><h1>Some Random Things</h1><p>Yes, updates are slowing shifting towards the end of the month, but I think it makes more sense this way. The posts can then (for me) act as a reflection of what I’ve done for the month. Or that is what I would have said if the posts actually were logs of what I got done for the month. Lately I have been wanting to post about things I find midly interesting, instead of mundane things-that-I-got-done. Things that are too short and simple for <a href=/lab>Lab</a>, but interesting enough that I want to write about it.<p>One of those things is how a random uniform distribution changes when transformed by different operators. I made some simple visualizations to get a feel of how they transform the uniform distribution to something less uniform:<p><canvas id=canvasDistributions></canvas><p>The random numbers are sampled from a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Continuous_uniform_distribution target=_blank>uniform distribution</a>. They are equally likely to get small numbers, big numbers, and everything in between. The first square shows cells with just the random numbers — the uniform distribution. Adding random numbers to random numbers changes the uniform distribution to a one that approaches a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Normal_distribution target=_blank>Gaussian distribution</a>, because of <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Central_limit_theorem target=_blank>CLT</a> since the random numbers are <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables target=_blank>IID</a>. For division, small denominators distort the distribution because probability for denominator P(X &lt; x) scales linearly but quotients scales hyperbolically — so bigger numbers are disproportionately more unlikely. In multiplication too, the probability of the factors scale linearly, but products scale superlinearly, so the probability of products scales sublinearly. That is, bigger numbers are, again, disproportionately less likely.<p>The unary operators are simpler to understand: The square root scales bigger numbers slower than smaller numbers — smaller numbers ‘grow more’ after the transformation, so small numbers are increasinsly less probable. The logarithm is similar, but it grows even slower, so the effect is even more pronounced. The maximum of two random numbers similarly skews values towards larger numbers — the probability linearly increases as the size of numbers increase.<p>For the comparator, the distribution is a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Bernoulli_distribution target=_blank>bernoulli distribution</a> with P(X = True | Y = y) = y. But 𝔼[Y] = 0.5, so P(X = True) = 0.5. That is, the uniform distribution collapses to 1 (True) or 0 (False) in a 50-50 split. The modulo is also simple: The probability a number is big P(X > x) scales linearly, but since the result is reduced by the modulus, the result is only big (P(Y > y)) if the modulus is also big. So similar to multiplicaiton, the distribution skews towards smaller values.<p>Anyhow, pretty interesting stuff. I explored <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Littlewood_polynomial target=_blank>littlewood polynomials</a> a bit as well. Dragon curves showing up in the fractal pattern was interesting, and the reason they do is pretty neat. Also read about <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Helicopter_money target=_blank>helicopter money</a>. Not as neat, but equally as interesting.<p><img alt="brief description of helipcopter money explained using a doodles - a cartoonish central bank giving away free money" decoding=async loading=lazy src=/media/log/free-money.avif><p>I am thinking about writing less about journal-y posts in Log, and write about more about short, random, interesting topics. Maybe future Log posts will reflect this. Maybe this is the general direction Log is heading towards. I don’t know; I might start doing more stuff and start writing about them more frequently once I’m done with college in a few weeks. Or maybe I will get even lesser time once I start working. We’ll see.<p>Speaking of work, I got a job offer that I <strong>have</strong> to accept — not because of a weak market for new grads (it is pretty bad out there though), but because of how the system works in my college. TLDR: Companies visit and offer jobs, and you have to accept the first offer that you receive. It is basically solving the assignment problem using FCFS. Not the most optimal, but it is what it is. Anyhow I got lucky, and got a job I’m satisfied with.<p><img alt="doodle of a person offering a job after a horrible interview answer" decoding=async loading=lazy src=/media/log/hired.avif><p>Been a slow month otherwise. Cya next month.</p><script>const WIDTH = 1280
const COLORS = getColorPalette(0.7, -0.6, 0.7, 0.9, 0.05, 0.95);
// const COLORS = getColorPalette(2.6, 0.4, 0.7, 0.9, 0.05, 0.95);

const altRandomFunctions = {
    "Random": () => Math.random(),
    "Random + Random + ...": () => Math.random() + Math.random() + Math.random() + Math.random() + Math.random(),
    "Random / Random": () => Math.random() / Math.random(),
    "Random * Random": () => Math.random() * Math.random(),
    "sqrt(Random)": () => Math.sqrt(Math.random()),
    "log2(Random)": () => Math.log2(Math.random()),
    "max(Random, Random)": () => Math.max(Math.random(), Math.random()),
    "Random <= Random": () => Number(Math.random() <= Math.random()),
    "Random % Random": () => Math.random() % Math.random(),
};

const canvasDistributions = initializeCanvas("canvasDistributions", 1530);
initializeCanvasText(canvasDistributions, "#000", "left");
canvasDistributions.fillText("Normalized Values", 785, 25);
drawColorBar(canvasDistributions);
drawFunctionDistributions(canvasDistributions, altRandomFunctions);


// functions

function drawFunctionDistributions(canvas, functions, x = 40, y = 40, size = 10, columns = 3) {
    let gap = Math.round((WIDTH - (size * x * (columns))) / (columns - 1));
    let yOffset = 20 - y * size;
    let xOffset = 0;
    let randomVals = [];
    let normalizedVals = [];
    Object.entries(functions).forEach(([funcName, funcFunction], i) => {
        if (i % columns == 0) {
            xOffset = 0;
            yOffset += y * size + 80;
        }
        else xOffset += x * size + gap;
        randomVals = Array.from({ length: y }, () => Array.from({ length: x }, funcFunction));
        normalizedVals = normalizeValues(randomVals);
        drawHeatmap(canvas, normalizedVals, x * size, y * size, xOffset, yOffset);
        canvas.fillStyle = "#000";
        canvas.fillText(funcName, xOffset, yOffset + y * size + 27);
    });
}

function normalizeValues(values, newMin = 0, newMax = 127) {
    let maxVal = Math.max(...values.flat());
    let minVal = Math.min(...values.flat());
    if (maxVal === minVal) {
        return values.map(row => 
            row.map((value) => value));
    }
    return values.map(row => 
        row.map(value => {
            return Math.floor(((value - minVal) / (maxVal - minVal)) * (newMax - newMin) + newMin);
        })
    );
}

function drawHeatmap(canvas, values, width, height, xOffset = 0, yOffset = 0, colors = COLORS) {
    let cellWidth = width / values[0].length;
    let cellHeight = height / values.length;
    for (let y = 0; y < values.length; y++) {
        for (let x = 0; x < values[y].length; x++) {
            canvas.fillStyle = getColor(colors[values[y][x]]);
            canvas.fillRect(x * cellWidth + xOffset, y * cellHeight + yOffset, cellWidth, cellHeight);
        }
    }
}

function drawColorBar(canvas, y = 0, x = 0, colors = COLORS, stops = 128, height = 50, width = 768) {
    let lineWidth = width / stops;
    canvas.lineWidth = lineWidth;
    for (let i = 0; i < stops; i++) {
        canvas.strokeStyle = getColor(colors[i]);
        canvas.beginPath();
        canvas.moveTo(i * lineWidth + x, y);
        canvas.lineTo(i * lineWidth + x, y + height);
        canvas.stroke();
    }
}

function getColor(rgbArray) {
    let r = Math.floor(Math.max(0, Math.min(rgbArray[0], 1)) * 255);
    let g = Math.floor(Math.max(0, Math.min(rgbArray[1], 1)) * 255);
    let b = Math.floor(Math.max(0, Math.min(rgbArray[2], 1)) * 255);
    return `rgb(${r}, ${g}, ${b})`;
}

function getColorPalette(start, rotation, hue = 1, gamma = 1, dark = 0, light = 1, stops = 128) {
    const colors = [];
    let phi = 0;
    let stop = 0;
    for (let i = dark; i < light; i += (light - dark) / stops) {
        phi = 2 * Math.PI * (start / 3 + rotation * stop);
        stop = Math.pow(i, gamma);
        amplitude = hue * stop * (1 - stop) / 2;
        colors.push([
            stop + amplitude * (-0.14861 * Math.cos(phi) + 1.78277 * Math.sin(phi)),
            stop + amplitude * (-0.29227 * Math.cos(phi) - 0.90649 * Math.sin(phi)),
            stop + amplitude * (+1.97294 * Math.cos(phi))
        ]);
    }
    return colors;
}


function initializeCanvas(canvasID, height, width = WIDTH) {
    const canvas = document.getElementById(canvasID).getContext("2d");
    canvas.canvas.width = width;
    canvas.canvas.height = height;
    return canvas;
}

function initializeCanvasText(canvas, color = "#000", horizontal = "center", vertical = "middle", font = "25px JetBrains Mono") {
    canvas.font = font;
    canvas.textBaseline = vertical;
    canvas.textAlign = horizontal;
    canvas.fillStyle = color;
}</script></article></main><footer><a href=https://ekunazanu.foo/more#Terms_of_Use>© 2025</a> <a href=https://ekunazanu.foo/about>ekunazanu</a> · <a rel="noopener nofollow noreferrer" href=https://creativecommons.org/licenses/by/4.0/ target=_blank>CC BY 4.0</a> · <a rel="noopener nofollow noreferrer" href=https://github.com/ekunazanu/ekunazanu.foo target=_blank>Source</a></footer>