<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content=ekunazanu name=author><meta content="Turns out (sometimes), the DVD square will never reach the corner." name=description><meta content="Calculating Collisions" property=og:title><meta content=article property=og:type><meta content="Turns out (sometimes), the DVD square will never reach the corner." property=og:description><meta content=https://ekunazanu.foo/log/10-calculating-collisions/ property=og:url><meta content=https://ekunazanu.foo/thumbnails/log.10.dvd.avif.png property=og:image><meta content="Doodle of the DVD square and its trajectory." property=og:image:alt><meta content=image/png property=og:image:type><meta content=1200 property=og:image:width><meta content=900 property=og:image:height><meta content=en_US property=og:locale><meta content=ekunazanu.foo property=og:site_name><title>Calculating Collisions ~ ekunazanu.foo</title><link href=https://ekunazanu.foo/log/10-calculating-collisions/ rel=cannonical><link href=https://ekunazanu.foo/atom.xml rel=alternate type=application/atom+xml><link href=https://ekunazanu.foo/misc/main.css rel=stylesheet><link href=https://ekunazanu.foo/misc/favicon.png rel=icon><meta content=Zola name=generator><body><nav><ul><li><h2><a href=https://ekunazanu.foo>ekunazanu.foo</a></h2><li><a href=https://ekunazanu.foo/log>Log</a> ⟶<li><a href=https://ekunazanu.foo/lab>Lab</a></ul></nav><div class=print>https://ekunazanu.foo</div><main><article><h1>Calculating Collisions</h1><p>I had my midterm exams this entire week, so naturally I ended up wasting a lot of time on YouTube. Something interesting happens during exams — I procrastinate more and do everything except study, even productive things. Human psychology I guess. And I know I am not the only one; I know full well that all of my friends share the exact same laissez faire attitude during exam season. Or maybe it’s true that birds of a feather flock together.<p><img alt="doodle of friends agreeing to play cricket before exams" decoding=async loading=lazy src=/media/log/exam-cricket.avif><p>I was binge-watching clips of The Office, and came across the scene where <a href="https://www.youtube.com/watch?v=QOtuX0jL85Y" rel="noopener nofollow noreferrer" target=_blank>everyone is eagerly waiting for a DVD logo to hit a corner</a>. And that made me curious — how many collisions does it actually take? So I quickly wrote a basic function to count the number of collisions for some initial coordinates and some given aspect ratio for the bounding box. I added two more lines of code to visualize the collisions as well. And got this:<p><canvas id=canvasCollisions></canvas> <input id=sliderYCoord style=margin-left:0 type=range>Initial Y: <span id=textYCoord>0.0000</span><br> <input id=sliderRatio style=margin-left:0 type=range>Aspect ratio: <span id=textRatio>3.0000</span><br> Collisions: <span id=textCollisions>5</span><p>You also can try specific aspect ratios: Most screens will usually have an aspect ratio of either <a id=switchRatio43 style=cursor:pointer>4:3</a> or <a id=switchRatio169 style=cursor:pointer>16:9</a>. Anyway, I think there are some interesting insights. The collisions will either be infinite or finite depending on the initial conditions. It is finite whenever the ‘criss-crosses overlap’ — for lack of a proper definition/description. Note that it may not seem that way because the canvas has a finite precision, so if the Y position is off by even half a pixel, it will not register as hitting the corner.<p>Designing the function for collisions made it obvious why it has to be that way: Collisions are symmetric and the bounding box is a rectangle. So if the rhombic tiles are coming close to each other, it means the ray elsewhere is experiencing two close collisions — somewhere near a corner. As the tiling patterns overlap, that collision difference reaches zero which means the ray has to hit a corner. It also means that other initial conditions result in an infinite loop. That DVD square will never reach a corner. Sad.<p>As for other things, The Plan™ got derailed. Of course, it did. But to be fair, I did have my midterms all week. And while I did procrastinate a lot, I did learn other things — mostly about rotary positional embeddings. This <a rel="noopener nofollow noreferrer" href=https://blog.eleuther.ai/rotary-embeddings/ target=_blank>post here</a> explains it pretty well. Anyhow, I’ll try to start The Plan™ this week. For real. <small>(If the lab exams don’t ruin my schedule.)</small><p><img alt="doodle of a person asking others to trust them" decoding=async loading=lazy src=/media/log/trust-me-bro.avif><p>Cya next week.</p><script>// quick ugly script
// decetly performat, but code is ugly

const maxIters = 100;
const canvasCollisions = document.getElementById("canvasCollisions").getContext("2d");
const textYCoord = document.getElementById("textYCoord");
const textRatio = document.getElementById("textRatio");
const textCollisions = document.getElementById("textCollisions");
const sliderYCoord = document.getElementById("sliderYCoord");
const sliderRatio = document.getElementById("sliderRatio");
const switchRatio43 = document.getElementById("switchRatio43");
const switchRatio169 = document.getElementById("switchRatio169");
var collisions = 0;

canvasCollisions.canvas.width = 1296;
canvasCollisions.canvas.height = 432;
canvasCollisions.canvas.style.border = "0.0625rem solid #000"
sliderYCoord.min = 0;
sliderYCoord.max = canvasCollisions.canvas.height;
sliderYCoord.step = 1;
sliderYCoord.value = 0;
sliderRatio.min = 432;
sliderRatio.max = 1296;
sliderRatio.step = 2;
sliderRatio.value = 1296;

drawReflections(canvasCollisions, 0, 0, canvasCollisions.canvas.width, canvasCollisions.canvas.height, maxIters);
drawCircle(canvasCollisions, 0);

sliderYCoord.addEventListener("input", function() {
    updateCanvasWrapper();
});

sliderRatio.addEventListener("input", function() {
    canvasCollisions.canvas.width = sliderRatio.value;
    updateCanvasWrapper();
});

switchRatio43.addEventListener("click", function() {
    canvasCollisions.canvas.width = 576;
    sliderRatio.value = 576;
    updateCanvasWrapper();
});

switchRatio169.addEventListener("click", function() {
    canvasCollisions.canvas.width = 768;
    sliderRatio.value = 768;
    updateCanvasWrapper();
});

function updateCanvasWrapper() {
    canvasCollisions.clearRect(0, 0, canvasCollisions.canvas.width, canvasCollisions.canvas.height);
    collisions = drawReflections(canvasCollisions, 0, sliderYCoord.value, canvasCollisions.canvas.width, canvasCollisions.canvas.height, maxIters);
    drawCircle(canvasCollisions, sliderYCoord.value);
    textYCoord.innerHTML = (sliderYCoord.value / sliderYCoord.max).toFixed(4);
    textRatio.innerHTML = (sliderRatio.value / 432).toFixed(4);
    if (collisions == 100) textCollisions.innerHTML = "≥ 100";
    else textCollisions.innerHTML = collisions;
}

function drawCircle(canvas, y, x = 0, radius = 15, color = "#aaa") {
    canvas.fillStyle = color;
    canvas.beginPath();
    canvas.arc(x, y, radius, 0, Math.PI * 2);
    canvas.closePath();
    canvas.fill();
    canvas.stroke();
}

function drawReflections(canvas, initialX, initialY, boundX, boundY, maxIter = 5, color = "#000", strokewidth = 2) {
    let iter = 0;
    let x = initialX;
    let y = initialY;
    let right = true;
    let down = true;
    let diffX, diffY;
    canvas.strokeStyle = color;
    canvas.lineWidth = strokewidth;
    canvas.beginPath();
    while (iter < maxIter) {
        canvas.moveTo(x, y);
        if (right) {diffX = boundX - x} else {diffX = x}
        if (down) {diffY = boundY - y} else {diffY = y}
        if (diffX < diffY) {
            if (right) {x = boundX; right = false} else {x = 0; right = true;}
            if (down) {y += diffX} else {y -= diffX}
        }
        else if (diffY < diffX) {
            if (down) {y = boundY; down = false} else {y = 0; down = true;}
            if (right) {x += diffY} else {x -= diffY}
        }
        else if (diffX == diffY) {
            if (down) {y = boundY} else {y = 0}
            if (right) {x = boundX} else {x = 0}
            canvas.lineTo(x, y);
            canvas.closePath();
            canvas.stroke();
            drawCircle(canvas, y, x);
            break;
        }
        canvas.lineTo(x, y);
        iter++;
    }
    canvas.closePath();
    canvas.stroke();
    return iter
}</script></article></main><footer><a href=https://ekunazanu.foo/more#Terms_of_Use>© 2025</a> <a href=https://ekunazanu.foo/about>ekunazanu</a> · <a rel="noopener nofollow noreferrer" href=https://creativecommons.org/licenses/by/4.0/ target=_blank>CC BY 4.0</a> · <a rel="noopener nofollow noreferrer" href=https://github.com/ekunazanu/ekunazanu.foo target=_blank>Source</a></footer>