<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content=ekunazanu name=author><meta content="A visual description of the CIE 1931 colour spaces." name=description><meta content="Quantifying Colour" property=og:title><meta content=article property=og:type><meta content="A visual description of the CIE 1931 colour spaces." property=og:description><meta content=https://ekunazanu.foo/lab/quantifying-colour/ property=og:url><meta content=https://ekunazanu.foo/thumbnails/lab.colours.svg.png property=og:image><meta content="Red, green, and blue lines representing pixels of an RGB display." property=og:image:alt><meta content=image/png property=og:image:type><meta content=1200 property=og:image:width><meta content=900 property=og:image:height><meta content=en_US property=og:locale><meta content=ekunazanu.foo property=og:site_name><title>Quantifying Colour ~ ekunazanu.foo</title><link href=https://ekunazanu.foo/lab/quantifying-colour/ rel=cannonical><link href=https://ekunazanu.foo/atom.xml rel=alternate type=application/atom+xml><link href=https://ekunazanu.foo/misc/main.css rel=stylesheet><link href=https://ekunazanu.foo/misc/favicon.png rel=icon><meta content=Zola name=generator><body><nav><ul><li><h2><a href=https://ekunazanu.foo>ekunazanu.foo</a></h2><li><a href=https://ekunazanu.foo/log>Log</a><li><a href=https://ekunazanu.foo/lab>Lab</a> ⟶</ul></nav><div class=print>https://ekunazanu.foo</div><main><article><h1>Quantifying Colour</h1><p>There are <a rel="noopener nofollow noreferrer" href=https://www.statista.com/statistics/245501/multiple-mobile-device-ownership-worldwide/ target=_blank>billions of monitors</a> worldwide that can reproduce the exact same colour when instructed to. This in itself is an engineering marvel, but it glosses over the fact that this is only possible if there is a standard definition for colours in the first place. Earlier, colours were loosely defined using a limited set of words — most languages have at most <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_term#Color-term_hierarchy target=_blank>twelve words</a> to describe colours. These loose definitions are fine in most cases, but it is not precise enough for describing the tiny differences between similar looking colours that is required for accurate colour reproduction.<p><img alt="a image of green leaves with boxes below showing some of the shades of green present in the image" decoding=async loading=lazy src=/media/lab/quantifying-colour/leaves.avif><details open><summary>Same name, different colours</summary> <p>The above coloured rectangles shows some of the colours present in the above image. Despite being different, all the shades can be described by the same label — green. One could argue, they can be labelled as lime-green, olive-green, light-green, dark-green, etc to create some distinction. But this naming system is still clunky and highly inefficient. To display the above image accurately, there needs to be a way to describe the all the different shades of green uniquely without needing to resort to an ever-growing list of labels.</p> <p>Image sourced from <a rel="noopener nofollow noreferrer" href=https://pixabay.com/photos/boundary-dark-green-wallpaper-1867353/ target=_blank>Pixabay</a>, under <a rel="noopener nofollow noreferrer" href=https://creativecommons.org/public-domain/cc0/ target=_blank>CC0</a>.</p></details><p>Instead of mapping colours to possibly millions of labels, it would be much simpler to use numbered units — the desired precision can then be achieved by simply using more or fewer digits. The idea of mapping colours to numbers might look odd, but it is not too far fetched. Most measurable physical phenomena have already been quantified (for eg. distances, temperature, etc). So if colours can be physically measured it should be easy to map them to numbers, in theory.<p>Defining colours using numbers also opens up interesting questions: What does addition or multiplication of colours look like? The process of quantifying colours will also reveal why <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Web_colors target=_blank>colour hexcodes</a> cannot show enough colours even with 16,777,216 values, and how a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/The_dress target=_blank>dress became a debate</a> on the internet, and why colour blindness exists.<h2>Spectral Power Distribution</h2><p>The goal is to then measure colours as some physical entity. Unfortunately, colours are a subjective phenomenon. However the fact that <em>most</em> people can agree on the colour of something suggests that there must be at least something objective and physical about it. And there is. Colours are only visible in the presence of light, and that provides a huge clue as to what colours are.<p>Light is complicated, but it can be thought of as a bunch of wave-like particles, called <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Photon target=_blank>photons</a> — each carrying some specific amount of energy. The energy of these particles is determined by their <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Photon_energy#Physics target=_blank>wavelength or frequency</a>.<p><canvas id=canvasPhoton></canvas> <input id=sliderPhotonWavelength type=range>Wavelength<details open><summary>Photon representation</summary> <p>The above is an interpretation of a photon, and is not necessarily accurate. The exact shape of photons is difficult to describe since photons exhibit <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Wave%E2%80%93particle_duality#Wave-particle_duality_of_light target=_blank>both particle and wave-like behaviour</a>. Trying to visualize photons as both a particle and a wave can get very tricky very quickly.</p></details><p><canvas id=canvasPhotonSpectrum></canvas><details open><summary>Electromagnetic spectrum</summary> <p>There are photons with different energies (or wavelengths). The different wavelengths of photons together form the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Electromagnetic_spectrum target=_blank>electromagnetic spectrum</a>. It is simply the full range photons energies, ordered by wavelength or frequency. The above wavelengths are not to scale.</p></details><p>The energy carried by photons can be physically measured, making it trivial to quantify light. To simplify comparisons between different types of light however, the energy measurements are normalized per unit time as <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Power_(physics) target=_blank>power</a>, and then normalized per unit area as <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Intensity_(physics) target=_blank>intensity</a> — where the area is the total area of the body radiating the photons/light.<p>So, light sources can be quantified using a singular intensity value. However, for reasons that will become more obvious later, light is actually represented using multiple intensity values — by measuring the intensity separately for photons at different wavelengths. The intensity-per-wavelength distribution is called the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Spectral_power_distribution target=_blank>spectral power distribution</a>.<p><canvas id=canvasPhotonPower></canvas> <canvas id=canvasPhotonPowerSPD></canvas> <input id=sliderPhotonPowerWavelength0 type=range>450nm Photons<br> <input id=sliderPhotonPowerWavelength1 type=range>500nm Photons<br> <input id=sliderPhotonPowerWavelength2 type=range>550nm Photons<br> <input id=sliderPhotonPowerWavelength3 type=range>600nm Photons<br> <input id=sliderPhotonPowerWavelength4 type=range>650nm Photons<br><details open><summary>Spectral power distribution</summary> <p>The above is an example of a spectral power distribution. The intensity at each wavelength depends on the number of photons at that wavelength and the energy of photons at that wavelength. The <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Photon_energy target=_blank>energy of a photon</a> is inversely proportional to its wavelength, so the shorter wavelength photons shown above have a higher intensity for the same number of photons.</p></details><p>The spectral power distribution provides a way to quantify light. But this is all irrelevant until there is a quantitative way to define a relationship between colours and the spectral power distribution (light) as well.<h2 id=-1>Photoreceptor Cells</h2><p>The biggest clue to finding that relationship is rather obvious — colour perception is not possible without light, but it is also not possible without eyes. Eyes are sensitive to light, but more importantly they react differently to different wavelengths of light.<p>To understand how eyes can distinguish between different wavelengths of light, it helps to know a little bit about human physiology. Eyes have different types of <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Photoreceptor_cell target=_blank>photoreceptor cells</a> that have evolved to respond to photons with specific wavelengths. Unsurprisingly, these wavelengths are very similar to those emitted by the sun (380nm–750nm):<p><canvas id=canvasSPDSun></canvas><details open><summary>Spectral power distribution of the sun</summary> <p>The above is an approximation of the spectral power distribution of the sun. Human eyes have evolved to become sensitive to these wavelengths to be able to perceive environments lit up by the sun.</p></details><p>Photons, depending on their energy (their wavelength), can ‘excite’ certain photoreceptor cells to produce a specific response. The human eye has two kinds of photoreceptor cells — <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Rod_cell target=_blank>rod cells</a> and three types of <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Cone_cell target=_blank>cone cells</a>. The different types of photoreceptor cells are sensitive to different wavelengths of light by differing amounts — some cone cells will not produce a significant response to lights with longer wavelengths but other cones may. The <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Spectral_sensitivity target=_blank>sensitivity</a> curves of the different photoreceptor cells are shown below:<p><canvas id=canvasSensitivityCurves></canvas><details open><summary>Normalized approximations</summary> <p>The sensitivity curves shown here are normalized approximations (for simpler visualizations and calculations), and are not accurate. In reality, the sensitivity curves are less smooth, and different types of cones have differing levels of sensitivity. For example, the sensitivity of S-cones is significantly lower compared to the other cones. Similarly, rods are more sensitive to light than any of the cones.</p></details><p>Because of the varying sensitivity curves, the cones can distinguish between different wavelengths of light. Consider a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Monochromatic_radiation target=_blank>monochromatic light source</a> (a light source with a near singular wavelength). The cones will produce a response to the light, depending on the wavelength of the light and how sensitive the cones are to that wavelength. However, since each type of cone has a different sensitivity, their response will be different for the same light.<p><canvas id=canvasSimpleSPD></canvas> <canvas id=canvasSimpleSSC></canvas> <canvas id=canvasSimpleRSP></canvas> <input id=sliderSimpleWavelength type=range>Wavelength<br><details open><summary>Photoreceptor cell responses</summary> <p>The first graph is the spectral power distribution of the light source. Since it is monochromatic, the intensity narrowly peaks at some wavelength. The graph below shows the sensitivity curves of the cones. The diagram on the bottom represents the responses of the cones to the monochromatic light. The different cones produce different responses to the same monochromatic light source — because of their differing sensitivity.</p></details><p>This is in itself is not enough to help differentiate different wavelengths, but the way the sensitivity curves are (or have evolved to be) distributed makes it such that all different wavelengths will always correspond to a unique set of responses in the cones — making it possible to distinguish different wavelengths. The brain has evolved to interpret these unique responses as perceiving unique colours.<p><canvas id=canvasSimpleColorSPD></canvas> <canvas id=canvasSimpleColorSSC></canvas> <canvas id=canvasSimpleColorRSP></canvas><div class=cBox id=divSimpleColor></div><input id=sliderSimpleColorWavelength type=range>Wavelength<br><details open><summary>Colour perception</summary> <p>Notice how different wavelengths always result in a unique set of values. Wavelengths that are close to each other may produce similar cone responses and thus the brain interprets them as similar colours. But in general, wavelengths that are distinct will produce distinctly different responses and the brain will interpret them as different colours.</p> <p>The colour in the above box is how the brain interprets the cone responses as a colour. The colours in the above box (and all subsequent boxes) is however just for illustration — it is an approximation and is not accurate. Also, the name in the above colour box is an example of a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Spectral_color#Spectral_color_terms target=_blank>word-based definition</a>. Notice here how imprecise they are — the same name correspond to lots of different shades of colours.</p></details><p>Rods are not shown in the above examples because they do not affect colour perception. In <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Photopic_vision target=_blank>well-lit conditions</a>, cones might produce different responses based on the wavelength of light. But in such conditions, the rod cells produce a saturated response since rods are more sensitive to light than cones. Since the response of rods in bright environments is indifferent to wavelengths, it cannot differentiate between distinct wavelengths, and thus does not have a major impact on colour perception — in bright conditions.<p><canvas id=canvasRodsLightSPD></canvas> <canvas id=canvasRodsLightSSC></canvas> <canvas id=canvasRodsLightRSP></canvas><div class=cBox id=divRodsLight></div><input id=sliderRodsLightWavelength type=range>Wavelength<br><details open><summary>Saturated response</summary> <p>The sensitivity of the rods is represented here with respect to the sensitivity of the cones (but it is not-to-scale, and is still an approximation). Because of their high sensitivity, the response of rods remain saturated, and no meaningful information about the wavelength is obtained from the response. The set of cones responses however, remains varied for different wavelengths, and the distinct cone responses can be interpreted by the brain as distinct wavelengths.</p></details><p>In <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Scotopic_vision target=_blank>dark environments</a>, rods produce a response when cones do not. But unlike cones, there is only one type of rod cell; there is no other type of rod cell with a slightly different sensitivity curve to help differentiate wavelengths. So, two light sources with different wavelengths can produce the same response in rods, and there is no way to differentiate the wavelengths from the singular response of the rods. The brain evolved to interpret the response of the rods as a singular luminance (brightness) value.<p><canvas id=canvasRodsDarkSPD></canvas> <canvas id=canvasRodsDarkSSC></canvas> <canvas id=canvasRodsDarkBAR></canvas> <canvas id=canvasRodsDarkRSP></canvas><div class=cBox id=divRodsDarkBox></div><input id=sliderRodsDarkWavelength type=range>Wavelength<br><details open><summary>Wavelength ambiguity</summary> <p>Different wavelengths can produce similar responses in the rods, and are thus perceived as similar by the brain. For example, a low intensity light of <a class=linkSwitch id=linkRodsDarkWavelengthA>492nm</a> and <a class=linkSwitch id=linkRodsDarkWavelengthB>536nm</a> can produce similar sets of responses in the rods (and cones), and so cyan and yellow-ish green may appear similar in the dark.</p></details><p>So rods cannot distinguish light of differing wavelengths regardless of whether it is dark or bright, and hence do not play a big role in colour perception.<h3 id=-2>Colour Blindness</h3><p>Sometimes cone cells too may not be able to differentiate between different wavelengths of light. This can happen due to missing cones, or cones with overlapping sensitivity curves. Without the third cone, light with different wavelengths can produce a similar set of cone responses — differentiating between the wavelengths is again not possible. This results in <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_blindness target=_blank>colour blindness</a>.<p><canvas id=canvasBlindSPD></canvas> <canvas id=canvasBlindSSC></canvas> <canvas id=canvasBlindBAR></canvas> <canvas id=canvasBlindRSP></canvas><div class=cBox id=divBlindBox></div><input id=sliderBlindWavelength type=range>Wavelength<br><input id=sliderBlindSensitivityOverlap type=range>M-cone Overlap<br><details open><summary>Wavelength ambiguity</summary> <p>If the sensitivity curves of the M-cones overlap the sensitivity curves of the L-cones, then different wavelengths of light (for eg. <a class=linkSwitch id=linkBlindWavelengthA>554nm</a> and <a class=linkSwitch id=linkBlindWavelengthB>604nm</a>) can produce similar sets of responses in the cones — causing them to appear similar. This is not the case if the sensitivity of the M-cones and L-cones <a class=linkSwitch id=linkBlindOverlap>do not have significant overlap</a>.</p></details><p>The type of cone anomaly determines the type of colour blindness. The sensitivity curve of the L-cones may shift towards shorter wavelengths (protanomaly), or the sensitivity of the M-cones can skew towards longer wavelengths (deuteranomaly). Some people might also lack functional L-cones (protanopia) or M-cones (deuteranopia) entirely. The result is similar in all the cases — reds and greens look similar. In very rare cases, people can have anomalous S-cones, resulting in tritanomaly and tritanopia.<p><canvas id=canvasBlindBARNR></canvas> <canvas id=canvasBlindBARPP></canvas> <canvas id=canvasBlindBARDP></canvas> <canvas id=canvasBlindBARTP></canvas><details open><summary>Colour blindness types</summary> <p>The bars represent how colours of different wavelengths for people with normal colour vision might appear to people with colour blindness. The first bar shows unaltered colours. The second bar shows colours for people with protanopia, and the third depicts colours for people with deuteranopia. The fourth bar represents how colours appear to people with tritanopia.</p></details><p>In extremely rare cases, people might have only S-cones or no cone cells at all. Both will result in <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Monochromacy#Humans target=_blank>total colour blindness</a> since there is no mechanism for differentiating light with different wavelengths.<p>Colour blindness also provides clues for why colour perception is subjective — not all people have three perfectly functioning cones, that have the exact same sensitivity curves as everyone else. Also, how exactly the brain interprets the responses as colours is still a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_vision#Theories target=_blank>debate</a>. So even with identical sensitivity curves and cone responses, brains may interpret signals differently for some people, which can again lead to inconsistent colour perception among people.<p>Nonetheless, the same wavelengths of light are generally perceived consistently by most of the population. So, for the purpose of colour quantification, <em>how</em> the brain interprets the cone responses can be ignored, and standard cone sensitivity curves can be defined using the sensitivity curves of the majority of people with normal colour vision.<p><canvas id=canvasAggregateSSC></canvas><details open><summary>Standardizing sensitivity curves</summary> <p>A standard set of sensitivity curves can be defined using the aggregate of the sensitivity curves of people with normal colour vision.</p></details><p>This results in a set of standardized sensitivity curves, which can be used for quantifying colours. However, before doing that, another type of colour needs to be addressed.<h3 id=-3>Non-Spectral Colours</h3><p>Until now, only <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Spectral_color target=_blank>spectral colours</a> (colours corresponding to monochromatic light) have been discussed. But most of the light around is not monochromatic; it is a combination of multiple wavelengths of light. This will slightly complicate the measurement of the cone responses. Earlier, for monochromatic light, the responses were simply the sensitivity values of the cones at the given wavelength. This does not work for non-monochromatic light since there is no singular, specific wavelength.<p><canvas id=canvasMonochromaticSPD></canvas> <canvas id=canvasNonMonochromaticSPD></canvas><details open><summary>Monochromatic and non-monochromatic light</summary> <p>The first spectral power distribution shows a monochromatic light source. The second spectral power distribution shows a light source that is non-monochromatic, since it emits light over a much wider range of wavelengths. Notice how non-monochromatic light does not necessarily emit the same intensity of light at all wavelengths.</p></details><p>Instead, the responses for non-monochromatic light sources is calculated by finding the weighted average of all the responses — by computing the normalized area under the response curve. The response curve is simply the product of the cone sensitivity curves and spectral power distribution: The spectral power distribution describes the intensity of light for some given wavelengths. Meanwhile, the sensitivity curves describes the sensitivity of the cones at some given wavelengths. So, their product together describes the cone response at that wavelength. Measuring this product over all wavelengths (equivalent to calculating the area) gives the total response, which may be normalized if required (eg. responses are normalized for monochromatic light).<p>For example, this is what the cone responses for light corresponding to <a class=linkSwitch id=linkNonSpectralSPDGrey>grey</a>, <a class=linkSwitch id=linkNonSpectralSPDPink>pink</a>, <a class=linkSwitch id=linkNonSpectralSPDWhite>white</a>, <a class=linkSwitch id=linkNonSpectralSPDPurple>purple</a>, and <a class=linkSwitch id=linkNonSpectralSPDOlive>olive green</a> look like:<p><canvas id=canvasNonSpectralSPD></canvas> <canvas id=canvasNonSpectralSSC></canvas> <canvas id=canvasNonSpectralRSP></canvas><div class=cBox id=divNonSpectral></div><details open><summary>Interactive spectral power distribution</summary> <p>The spectral power distribution can also be modified by drawing on it.</p></details><details open><summary>Cone responses</summary> <p>The response of the cones is the the total area under the curve that is obtained after multiplying the spectral power distribution and the cone sensitivity curves. The response may be normalized for light sources that have a very narrow wavelength range (eg. monochromatic light).</p></details><p>The colour of non-monochromatic light can look different from spectral colours because the set of cone responses produced for these types of lights may be different from the set of responses produced for spectral colours. The brain interprets these unique cone responses as a colour distinct from spectral colours. These colours are aptly referred to as non-spectral colours.<details open><summary>Metamerism</summary> <p>There are times when non-monochromatic light produces cone responses that are similar to the responses produced by spectral colours — making them appear similar to spectral colours. This phenomenon will be discussed later.</p></details><h2 id=-4>Colour Space</h2><p>Since colours perception is ultimately dependent on the set of cone responses, it should be theoretically possible to represent colours using only the responses of the cones. And these responses should theoretically be enough to describe every perceivable colour. So, if the set of cone responses can be quantified, it should be possible for all colours to be quantified just as easily.<p>As mentioned earlier, the spectral power distribution of any light is both quantifiable and <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Spectroradiometer target=_blank>measurable</a>. Similarly, while the cone sensitivity curves are subjective, for the purpose of colour quantification, an aggregate of the majority can be standardized and used. Since the response of the cones is dependent on these two factors — both of which can be quantified — the response, too, should be quantifiable. But only if there is a well-defined relationship between the two as well.<p>Again, as discussed in the non-spectral colours subsection, the biology virtuosos have already found a way to define that relationship — it is the normalized area under the response curve (the response curve itself is the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Pointwise#Examples target=_blank>point-wise product</a> of the spectral power distribution and the photoreceptor sensitivity curves).<p><canvas id=canvasPointWiseSPD></canvas> <canvas id=canvasPointWiseSSC></canvas> <canvas id=canvasPointWiseRSP></canvas><details open><summary>Cone response revisited</summary> <p>The response of the cones is the the normalized area under the curve of the response curve. The response curve is the point-wise product of the spectral power distribution and the cone sensitivity curves.</p></details><p>This relationship can be more formally described as:<p><code>L = ∫ J(λ)·l(λ)·dλ</code><br> <code>M = ∫ J(λ)·m(λ)·dλ</code><br> <code>S = ∫ J(λ)·s(λ)·dλ</code><p>Where <code>J(λ)</code> describes the spectral power distribution of the light, while <code>l(λ)</code>, <code>m(λ)</code>, and <code>s(λ)</code> are the sensitivity curves of the L-cones, M-cones, and S-cones. The responses are also normalized such that their maxima is equal to unity. This relationship quantifies cone responses to a spectral power distribution.<p>So the colour of any light or any object reflecting light can be precisely described by its (L,M,S) values — which can be derived by from its spectral power distribution. The set of all possible (L,M,S) values describes every perceivable colour, and all these possible values together form a three dimensional space, aptly called a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_space target=_blank>colour space</a>. More specifically, this is the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/LMS_color_space target=_blank>LMS colour space</a>, where colours are defined as a set of (L,M,S) values. The LMS colour space here is visualized below, where each of the responses of the cones is represented using a spatial dimension.<p><canvas id=canvasColorSpaceLMS></canvas><div class=cBox id=divColorSpaceLMS></div><input id=sliderColorSpaceLMSL type=range>L<br><input id=sliderColorSpaceLMSM type=range>M<br><input id=sliderColorSpaceLMSS type=range>S<br><details open><summary>The LMS colour space</summary> <p>While all colours can be represented using LMS values — and hence will always be in the LMS color space, the reverse is not always true. Not all LMS values correspond to perceivable colours. Since the sensitivity curves of the M-cones overlaps the sensitivity curves of L-cones and S-cones, any type of light that excites the M-cones, must also excite the L-cones, or S-cones, or both. So ‘colours’ having LMS values such as <a class=linkSwitch id=linkColorSpaceLMSImp>(0,0.7,0)</a> are <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Impossible_color#Imaginary_colors target=_blank>imaginary</a>. The imaginary values are represented as black in the above LMS colour space, but their actual colour is hard to approximate since these ‘colours’ do not appear naturally, and have only been replicated recently by <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Olo_(color) target=_blank>shooting lasers directly to the retina</a>.</p></details><p>So we achieved our goal — a way to quantify colours precisely, using numbers. Except this is not at all the standard used when describing colours. The LMS colour space is <em>one</em> way to describe colours, but is not the <em>standard</em> way to describe them.<p>As mentioned, defining the LMS values for a colour requires defining some relationship between the spectral power distribution and response of the cones. However, this is only possible if there is a set of standardized sensitivity curves. Without them, the responses cannot be measured or defined.<p><canvas id=canvasSensitivityUndefinedSPD></canvas> <canvas id=canvasSensitivityUndefinedSSC></canvas> <canvas id=canvasSensitivityUndefinedRSP></canvas><details open><summary>Undefined cone sensitivity</summary> <p>The cones responses cannot be calculated from the spectral power distribution if there is nothing relating them both.</p></details><p>Interestingly, colours were quantified and standardized even before the sensitivity of the cones were measurable with a decent level of precision. So there was already an existing definition/model for colours, making the LMS colour space redundant.<p>And perhaps, you might have never even heard of colours being represented as a set of LMS values. Instead you might have seen colours represented as a set of RGB values. What is up with that? How is it different from LMS values? And if you have ever searched for numerical values for colour, you might have come across some random XYZ values and a coloured horseshoe diagram that looks like this:<p><canvas id=canvasXYChromaticityDiagram></canvas><p>What is up with THAT? To understand this weird diagram, and how RGB values work, we need to forget about cone fundamentals and start using the standard that was used for quantifying colours earlier.<p>This older model of colours did not use the cone responses as its basis. Instead, it used colour matching functions — mapping colours to the intensity of certain lights required to produce that colour. This is the same as quantifying colours using numbers (measurable intensity values), but the difference is that it relies on a different phenomenon to map colours to numbers.<h2 id=-5>Metamerism</h2><p>As mentioned earlier briefly, sometimes lights with different spectral power distributions can produce similar responses in the cones as spectral colours. They can also produce similar cone responses as non-spectral colours as well. More broadly, the same cone responses can be produced by light having different spectral power distributions — so different types of lights can appear to have the same colour even if their spectral power distributions vary. This is called <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Metamerism_(colour) target=_blank>metamerism</a>.<p><canvas id=canvasMetamerSPD></canvas> <canvas id=canvasMetamerSSC></canvas> <canvas id=canvasMetamerRSP></canvas><div class=cBox id=divMetamer></div><details open><summary>Metamer examples</summary> <p>Here, <a class=linkSwitch id=linkMetamerDistributionA>multiple</a> <a class=linkSwitch id=linkMetamerDistributionB>distributions</a> can produce similar <a class=linkSwitch id=linkMetamerDistributionX>maroons</a>.</p></details><p>This phenomenon was explored further in colour matching experiments by <a rel="noopener nofollow noreferrer" href=https://doi.org/10.1088/1475-4878/30/4/301 target=_blank>William David Wright</a> and <a rel="noopener nofollow noreferrer" href=https://doi.org/10.1098/rsta.1932.0005 target=_blank>John Guild</a>. A light source with three wavelengths (435nm, 546nm, 700nm), each with different intensities, were mapped to spectral colours by varying the intensities of its constituent monochromatic lights — such that the resultant light was perceived to be the same as a spectral colour. The findings were then aggregated and summarized as (the now standardized) colour-matching functions.<p>The colour matching curves define the intensity of each of the three <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Primary_color#Real_primaries target=_blank>primaries</a> required to replicate a spectral colour. Primaries are colours that can be used for recreating other colours. Here, the primaries are the 435nm, 546nm, 700nm monochromatic lights.<p><canvas id=canvasColorMatchingCMF></canvas> <canvas id=canvasColorMatchingSPD></canvas> <canvas id=canvasColorMatchingSSC></canvas> <canvas id=canvasColorMatchingRSP></canvas><div class=cBox id=divColorMatching></div><input id=sliderColorMatchingWavelength type=range>Wavelength<br><details open><summary>Inaccurate cyans</summary> <p>The first graph shows the intensity of the primaries — they are colour matching functions. The rest of the graphs have the same meaning as the previous figures. Notice the negative intensity values, and notice how the colours formed by the primaries around <a class=linkSwitch id=linkColorMatchingWavelengthA>500nm</a> cyan looks very different from the real cyan at 500nm.</p></details><p>While the three primaries can produce similar responses to certain spectral colours in the cones — making them appear similar — it is not always the case. There are spectral colours which can never be replicated using only the three monochromatic primaries. For example, the three wavelengths above cannot produce a colour that looks similar to spectral cyans (light having wavelengths around 500nm).<p>However, the cyans can still be mapped to the primaries. The spectral cyans look similar to the colours formed by the primaries if some intensity of the 700nm primary is added to the cyan itself. This results in measurable intensity values of the 700nm primary — which can be used to map and quantify the spectral cyans. However, since light is added to the spectral colour instead of the primaries, it needs to be represented differently. In the colour matching curves, this is represented using negative values.<p><canvas id=canvasColorMatchCircle></canvas> <input id=sliderColorMatchCircleIntensity type=range>700nm Intensity (Normalized): <span id=spanColorMatchingCircleR></span><br><details open><summary>Negative intensity</summary> <p>The 435nm, 546nm, and 700nm primaries cannot produce colours that exactly matches the spectral cyans. The only way to match the primaries to spectral colours is by adding <a class=linkSwitch id=linkColorMatchCircle>some amount</a> of the 700nm primary to the spectral colour itself. The addition of 700nm light to the spectral colours is represented as negative intensity in the colour matching functions.</p> <p>Physically, it is impossible to create light with negative intensity, so it is impossible to reproduce certain colours using only three wavelengths of light. However, colours can still be <strong>represented theoretically</strong> using negative values in these colour matching functions, for the purpose of quantifying colours.</p></details><p>These colour matching functions form the basis for the present standards that are used for describing and defining colours.<h2 id=-6>CIE Colour Spaces</h2><p>The Wright-Guild colour matching functions makes spectral colours quantifiable as a set of measurable intensity values of three monochromatic lights. But non-spectral colours too can be mapped to intensity values using this technique.<p>Instead of constraining the intensity values of the primaries to follow the colour matching functions, they can also be set to any arbitrary intensity value. This results in other perceivable colours, which are not necessarily spectral — ie. non-spectral colours. They are still colours nonetheless, and more importantly, all these colours can be mapped to a set of (intensity) values. So, a set of intensity values (of the 435nm, 546m, and 700nm primaries) define a colour. Since these values define colours, they can together create a colour space. This colour space is called the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_RGB_color_space target=_blank>CIE RGB colour space</a>.<p><canvas id=canvasColorSpaceRGB></canvas><div class=cBox id=divColorSpaceRGB></div><input id=sliderColorSpaceRGBR type=range>R (700nm)<br><input id=sliderColorSpaceRGBG type=range>G (546nm)<br><input id=sliderColorSpaceRGBB type=range>B (435nm)<br><details open><summary>The CIE RGB colour space</summary> <p>The CIE RGB colour space uses the normalized intensity of 700nm, 546nm, and 435nm lights as its bases. The LMS colour space, in contrast, used the response of the cones (L,M,S) as its bases.</p></details><p>These intensity values are again measurable and quantifiable, and forms another way to quantify colours. However, there are some minor inconveniences with this colours space. Not all colours are present in this colours space. Or more accurately, not all perceivable colours lie in the positive quadrant of this colour space.<p>Consider the spectral colours. Mapping spectral colours in the this colour space results in the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Spectral_color#In_color_spaces target=_blank>spectral locus</a>. Some part of this spectral locus outside the positive quadrant of this space — for example, the spectral cyans. Similarly, certain non-spectral colours lie outside the positive bounds of this space as well.<p><canvas id=canvasColorSpaceRGBLocusCMF></canvas> <canvas id=canvasColorSpaceRGBLocus></canvas> <input id=sliderColorSpaceRGBLocusWavelength type=range>Wavelength<br><details open><summary>Cyans outside the positive quadrant</summary> <p>Unlike the LMS colour space, which describes all perceivable colours using non-negative values (all colours have values within zero and one), the CIE RGB colour space requires negative values to define certain colours. For example, spectral cyans are represented using negative intensity of the R primary, and thus lie in the negative R half of the CIE RGB space.</p></details><p>It was decided that a colour space that could map all colours to non-negative values would have been preferable. But instead of conducting more experiments to construct a new colour space, the existing CIE RGB colour space could also be transformed using simple linear transformations. The transformation of the three dimensional colour space can be defined using a simple 3x3 matrix.<p><canvas id=canvasColorSpaceTransformCMF></canvas> <canvas id=canvasColorSpaceTransform></canvas> <input id=sliderColorSpaceTransform0 type=range><input id=sliderColorSpaceTransform1 type=range><input id=sliderColorSpaceTransform2 type=range><br> <input id=sliderColorSpaceTransform3 type=range><input id=sliderColorSpaceTransform4 type=range><input id=sliderColorSpaceTransform5 type=range><br> <input id=sliderColorSpaceTransform6 type=range><input id=sliderColorSpaceTransform7 type=range><input id=sliderColorSpaceTransform8 type=range><br><details open><summary>Linear transformations</summary> <p>The matrix defines how the space gets transformed. To get a more intuitive feel of the transformations, try fiddling around with the matrix value sliders. To understand how linear transformations and matrices work in more detail, you can refer to <a rel="noopener nofollow noreferrer" href=https://www.3blue1brown.com/lessons/linear-transformations target=_blank>this great resource</a>.</p></details><p><a class=linkSwitch id=linkColorSpaceTransformMatRandom>Transforming</a> the space means the new space is now defined by different new bases or new primaries. Earlier, some spectral colours had to be defined by negative values of a primary, but now the same colour is defined by positive values. It suggests that the coordinate system (the primaries) itself has to contain some sort of a negative intensity. But it is impossible for light to have negative intensity, implying that the primaries for the new colour cannot physically exist, and themselves are imaginary.<p>Since the primaries of the new colour space are imaginary, it is reasonable to define the new primaries to represent more abstract concepts instead of physical quantities. Again, it was decided that <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Luminous_efficiency_function target=_blank>one of the primaries</a> would define the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Luminance target=_blank>luminance</a> of the colour. The other two can be used to derive its <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Chromaticity target=_blank>chromaticity</a>. One of the two primaries is also roughly equal to the response of the S-cones. A specific transformation was defined to map the colours to the non-negative quadrant and incorporate the above ideas.<p><canvas id=canvasColorSpaceTransformSpecificCMF></canvas> <canvas id=canvasColorSpaceTransformSpecific></canvas> <input id=sliderColorSpaceTransformSpecific0 type=range><input id=sliderColorSpaceTransformSpecific1 type=range><input id=sliderColorSpaceTransformSpecific2 type=range><br> <input id=sliderColorSpaceTransformSpecific3 type=range><input id=sliderColorSpaceTransformSpecific4 type=range><input id=sliderColorSpaceTransformSpecific5 type=range><br> <input id=sliderColorSpaceTransformSpecific6 type=range><input id=sliderColorSpaceTransformSpecific7 type=range><input id=sliderColorSpaceTransformSpecific8 type=range><br><details open><summary>Specific transformation</summary> <p>A <a class=linkSwitch id=linkColorSpaceTransformSpecificMat>specfic matrix</a> was defined to transforms the colour matching functions to have all positive values, and to fulfill other certain criteria — one of them being separating luminance and chromaticity.</p></details><details open><summary>Luminance and chromaticity</summary> <p>Luminance refers to the perceived brightness of a colour, while chromaticity is analogous to hues. According to the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Opponent_process target=_blank>opponent process</a> theory, colours are perceived as pairs of opposing colours — red vs green, blue vs yellow (chromaticity), and black vs white (luminance). Hence, it is possible to describe a colour by how red it is compared to how green it is, how blue it is compared to how yellow it is, and how bright the overall colour is — ie. defining colours based on luminance and chromaticity values.</p></details><p>The primaries of this new colour space are named X, Y, and Z — and the resulting colour space is called the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/CIE_1931_color_space#Meaning_of_X,_Y_and_Z target=_blank>CIE XYZ colour space</a>. All spectral colours lie in the positive quadrant of this colour space.<p><canvas id=canvasColorSpaceXYZLocusCMF></canvas> <canvas id=canvasColorSpaceXYZLocus></canvas> <input id=sliderColorSpaceXYZLocusWavelength type=range>Wavelength<br><details open><summary>Imaginary primaries</summary> <p>Notice how transforming the CIE RGB space results in a new space, defined by new bases (primaries). The new XYZ primaries are no longer grounded in physical reality, and instead are more abstract and imaginary.</p></details><p>The other colours in the CIE RGB space can similarly be mapped in the XYZ colour space by applying the same matrix transformation. However, not all perceivable colours can be mapped to the XYZ space using this transformation since the CIE RGB space itself does not define all perceivable colours in its space — colours that require ‘negative’ intensities have not been defined, <strong>apart from the spectral colours</strong>. Unlike the RGB colour space, where the primaries are physical monochromatic lights and thus have a corresponding colour, the CIE XYZ space has imaginary primaries and so it is not obvious which colour a certain combination of (X,Y,Z) values refer to — or if it even maps to a valid colour.<p><canvas id=canvasColorSpaceXYZ></canvas> <input id=sliderColorSpaceXYZX type=range>X<br> <input id=sliderColorSpaceXYZY type=range>Y<br> <input id=sliderColorSpaceXYZZ type=range>Z<br><details open><summary>The CIE XYZ colour space</summary> <p>The colours in the CIE RGB space after the transformation — resulting in the XYZ space — is shown above. While some of the values in the new XYZ space are valid colours (eg. the CIE RGB colours), it is not clear what the values outside the CIE RGB bounds represent. Real and perceivable colours like the <a class=linkSwitch id=linkColorSpaceXYZCyan>spectral cyans</a> lie outside the positive bounds of CIE RGB space, but still lie inside the positive bounds of the CIE XYZ space. There must similarly be other (X,Y,Z) values that are outside the RGB bounds but inside the XYZ bounds, that are valid colours — for example, the colours lying between the spectral cyans the the CIE RGB colours. However, mapping these colours can be very difficult, since the primaries of the CIE XYZ space are imaginary and don’t necessarily correspond to an observable colour, unlike the physical CIE RGB primaries.</p></details><p>To find which colours the undefined values correspond to, it is helpful to first discuss yet another popular way to represent colours — using chromaticity spaces.<h2 id=-7>Chromaticity Space</h2><p>As mentioned before, colours can be alternatively classified based on more abstract properties like their luminance and chromaticity. This can be a more convenient way for defining colours since it matches with how the brain is <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Opponent_process target=_blank>believed to classify colours</a> — as dark vs bright (luminance), and as red vs green and blue vs yellow (chromaticity).<p>Consider the CIE RGB colour space. A simple way to obtain a crude approximation of the luminance from the primaries’ values is by taking the their sum (R+G+B). Likewise, the chromaticity values can be approximated by taking the ratios between the intensities of the RGB primaries.<details><summary>Luminance-chromaticity estimates</summary> <p>While the luminance and chromaticity are approximations, it does not mean that there is loss of information. The exact RGB values can be recreated using the luminance and chromaticity estimates. The approximation simply refers to the imperfect separation of luminance and chromaticity.</p></details><p>So, the luminance of a colour with values (R,G,B) will be L=R+G+B, and its chromaticity values would be their relative intensities — which can be computed by normalizing them. That is, the chromaticity ratios r, g, b would be equal to R/L, G/L, and B/L respectively. Consider a simple example where the luminance is fixed to one. In the CIE RGB space, all the colours with a luminance value of one will lie on the R+G+B=1 plane. The (R,G,B) values of a colour on this plane represents the ratios of its primaries, and so represents its chromaticity values.<p><canvas id=canvasColorSpaceRGBChroma></canvas><div class=cBox id=divColorSpaceRGBChroma></div><input id=sliderColorSpaceRGBChroma0 type=range>R<progress id=progressColorSpaceRGBChroma0></progress>r<br><input id=sliderColorSpaceRGBChroma1 type=range>G<progress id=progressColorSpaceRGBChroma1></progress>g<br><input id=sliderColorSpaceRGBChroma2 type=range>B<progress id=progressColorSpaceRGBChroma2></progress>b<br><details open><summary>Chromaticity plane</summary> <p>The above slice of the CIE RGB space represents a chromaticity plane. When the luminance is fixed, changing any of the (R,G,B) values changes the relative intensity of the primaries without changing their total intensity (luminance). So colours on these type of planes represent colours with a fixed luminance, but different chromaticities.</p> <p>Here, since the luminance is fixed to one, the chromaticity ratios (r,g,b) of the colours are simply the (R,G,B) values.</p></details><p>A colour with some other luminance k will lie on the plane R+G+B=k. Meanwhile the chromaticity ratios will be the normalized intensities of the primaries, so the (r,g,b) ratios are the projection of the (R,G,B) values on the R+G+B=1 plane.<p><canvas id=canvasColorSpaceRGBChromaProject></canvas><div class=cBox id=divColorSpaceRGBChromaProject></div><input id=sliderColorSpaceRGBChromaProject0 type=range>R<progress id=progressColorSpaceRGBChromaProject0></progress>r<br><input id=sliderColorSpaceRGBChromaProject1 type=range>G<progress id=progressColorSpaceRGBChromaProject1></progress>g<br><input id=sliderColorSpaceRGBChromaProject2 type=range>B<progress id=progressColorSpaceRGBChromaProject2></progress>b<br><input id=sliderColorSpaceRGBChromaProjectPan type=range>Pan <details open><summary>Dimensionality reduction</summary> <p>The coloured dots represent colours with the same luminance — colours that lie on the R+G+B=k plane (outlined using the gray triangle). The chromaticity of a colour is the ratio of the intensities, or put simply, their normalized intensities. Geometrically, the chromaticity (the point in black) is the projection of the (R,G,B) point (coloured gray) on the R+G+B=1 plane. Try <a class=linkSwitch id=linkColorSpaceRGBChromaProjectPan>panning</a> to get a feel of this space.</p> <p>From the diagram it can be seen that colours with the same chromaticity but different luminance lie on the same lines radiating from the origin. These can be thought of as lines of chromaticity. Points on these lines represent colours with the same chromaticity but different luminance values. Colours with the same chromaticity values appear ‘similar’ but can look lighter or darker, depending on their luminance. For example, <a class=linkSwitch id=linkColorSpaceRGBChromaProjectGreen1>greens</a> lying on the same chromaticity-line look similar but appear <a class=linkSwitch id=linkColorSpaceRGBChromaProjectGreen2>lighter</a> or <a class=linkSwitch id=linkColorSpaceRGBChromaProjectGreen0>darker</a> based on their luminance.</p> <p>Since colours with the same chromaticity but different luminance values get projected to the same point, it leads to a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Dimensionality_reduction target=_blank>loss of information</a>. The chromaticity plane contains information about chromaticity, and generally does not contain any information about luminance. So unless luminance is explicitly specified, it is impossible to recreate the corresponding RGB values using just the (r,g,b) values.</p></details><p>For some specific luminance, the chromaticity space is just a two dimensional plane in a three dimensional space. Instead of representing the chromaticity space as a plane embedded in a three dimensional space, it is simply represented as a two dimensional space by projecting the chromaticity plane to one of the colour space planes. In the case of the CIE RGB space, the R+G+B=1 chromaticity plane is projected to the RG plane.<p><canvas id=canvasChromaSpaceRG></canvas> <input id=sliderChromaSpaceRGPan type=range>Pan<details open><summary>The CIE rg chromaticity space</summary> <p>Projecting the R+G+B=1 plane of the CIE RGB space to the <a class=linkSwitch id=linkChromaSpaceRGPan>RG plane</a> results in the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Rg_chromaticity target=_blank>rg chromaticity space</a>. This plane is specifically called rg plane, and not the RG plane, because RG and rg represent different quantities. The values (r,g) represent the chromaticity of a colour — it represents the relative ratios of the R and G primaries. Meanwhile the (R,G) values simply represent the absolute intensity of R and G primaries.</p></details><p>The chromaticity values for the spectral colours, too, can be calculated by applying the same transformations on the spectral locus — normalizing the intensity of the primaries to get its projection on the R+G+B=1 plane, and then selecting the (r,g) values to get its <a class=linkSwitch id=linkChromaRGBLocusPan>projection on the rg plane</a>.<p><canvas id=canvasChromaRGBLocus></canvas> <input id=sliderChromaRGBLocusWavelength type=range>Wavelength<br> <input id=sliderChromaRGBLocusPan type=range>Pan<br> <input checked id=switchChromaRGBLocusSlice type=checkbox><label for=switchChromaRGBLocusSlice>Show colours</label><details open><summary>The CIE rg chromaticity diagram</summary> <p>Applying the same operations for the spectral colours instead of the CIE RGB colours — applying the transformations on the spectral locus — results in the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Rg_chromaticity#rg_chromaticity_diagram target=_blank>rg chromaticity diagram</a>. The spectral locus is represented in gray, while its projection on the R+G+B=1 plane is coloured in black. Notice that again, a part of the locus lies on the negative half in the rg chromaticity space.</p></details><p>While the colours, and therefore the chromaticity of the colours in the positive quadrant in the rg chromaticity space are defined, the chromaticity for colours outside the small subset of the positive quadrant is again not defined. Apart from the spectral colours, of course.<p><canvas id=canvasChromaRGUndefined></canvas><details open><summary>Undefined chromaticity</summary> <p>The CIE rg chromaticity space is derived from the CIE RGB colour space, so colours and values that are undefined in the RGB colour space are also undefined in the rg chromaticity space. The only colours that have defined values are the colours created using the CIE RGB primaries, and the spectral colours. These have definite values in the RGB space and thus also have values defined in the rg chromaticity space.</p></details><p>The rg chromaticity diagram above might look a little weird with chromaticities defined in some of the negative half of this space (the spectral cyans), and other chromaticities defined in some of the positive half (the colours replicable using the CIE RGB primaries), but with no chromaticities defined for values in between that space. It is not because there are no such colours — colours that are a combination of spectral cyans and the CIE RGB primaries exist, and intuition would suggest that they will have (r,g) values in between those of the cyans and CIE RGB colours in the chromaticity space. The problem is finding a way to map these colours (chromaticities) in the chromaticity space.<p><canvas id=canvasChromaRGDefined></canvas><details open><summary>In-between chromaticities</summary> <p>Intuition suggests that the chromaticity of colours which consist of some combination of spectral cyans and CIE RGB primaries would lie in the space between the spectral locus (the part corresponding to cyans) and the CIE RGB colours. This space is highlighted in light blue above.</p></details><p>Defining the chromaticity for this undefined, in-between space requires another insight from other experiments — namely that <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Grassmann%27s_laws_(color_science) target=_blank>addition of colours can be approximated as a linear operation</a>. What it means is that colours defined in the CIE spaces can be used to define other colours that are a linear combination of the already-defined colours.<p>Consider two colours the lie on the spectral locus, eg. two spectral cyans. The colours that can be formed using a linear combination of these cyans can then be represented as a linear combination of the chromaticity values of the CIE RGB primaries — ie. they can be represented using (r,g) values.<p><canvas id=canvasChromaRGLinear></canvas><div class=cBox id=divChromaRGLinear></div><input id=sliderChromaRGLinearWavelength0 type=range><input id=sliderChromaRGLinearIntensity0 type=range><br><input id=sliderChromaRGLinearWavelength1 type=range><input id=sliderChromaRGLinearIntensity1 type=range><br> Intensity of <span id=spanChromaRGLinearWavelength0></span>nm light (r: <span id=spanChromaRGLinearWavelength0R></span>, g: <span id=spanChromaRGLinearWavelength0G></span>): <span id=spanChromaRGLinearIntensity0></span><br> Intensity of <span id=spanChromaRGLinearWavelength1></span>nm light (r: <span id=spanChromaRGLinearWavelength1R></span>, g: <span id=spanChromaRGLinearWavelength1G></span>): <span id=spanChromaRGLinearIntensity1></span><br> The rg-chromaticity of resultant colour:<br><span id=spanChromaRGLinearChromaValues></span><br> = <span id=spanChromaRGLinearChromaResult></span><details open><summary>Defining chromaticity using already defined chromaticities</summary> <p>Combining spectral colours of varying intensities results in real, observable colours. These perceivable colours can be defined as a linear combination of the spectral colours. Since addition of colours is linear, and the spectral colours have values defined in the CIE colour and chromaticity spaces, these new colours can themselves be defined as the linear combination of CIE colour/chromaticity space using the already-defined values of the spectral colours.</p> <p>The entire space ‘inside’ the spectral locus will have a defined chromaticity, and it should be obvious why — any colour that can be created as some combination of spectral colours will always lie inside this space. In fact, this space contains the chromaticity of all perceivable colours. Since a colour is ultimately determined by the intensity of lights at different wavelengths (the spectral power distribution), a linear combination of their intensities can be mapped in this space — and since these intensities will always be non-negative, their chromaticity values will always lie inside the area spanned by the spectral locus.</p></details><p>This property of linearity of colour addition can similarly be expanded from the two dimensional chromaticity spaces to the three dimensional colour spaces. A colour can be first quantified as the intensity of two monochromatic lights, which can then be rewritten as the linear combination of the CIE primaries using the CIE colour values of the two monochromatic lights.<p>While the chromaticity space was introduced to show the linearity of addition of colours in a simpler reduced dimensional space, it has other uses too. Chromaticity is another way to quantify colours. It is not perfect, since there is a reduction of information — the luminance component of a colour is sacrificed in order to be able to represent colours using two dimensions. But this is a convenient tradeoff since most visual communication media are two dimensional, so chromaticity spaces allow easy representation of colours on such media, without losing much information — making them pretty popular.<h3 id=-8>The xy Chromaticity Space</h3><p>While chromaticity spaces are a popular way of representing colours (again, to be more accurate, chromaticities) the CIE rg-chromaticity space is not very common because it requires negative values to describe certain chromaticities. Instead, the xy chromaticity space is more commonly used.<p>Similar to how the CIE RGB colour space was transformed to get the rg chromaticity space and rg chromaticity diagram, the same transformations can be applied for the CIE XYZ colour space to get the xy chromaticity space and the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/CIE_1931_color_space#/media/File:CIE1931xy_blank.svg target=_blank>xy chromaticity diagram</a>.<p><canvas id=canvasChromaXYZLocus></canvas> <input id=sliderChromaXYZLocusWavelength type=range>Wavelength<br> <input id=sliderChromaXYZLocusPan type=range>Pan<details open><summary>Meaning of xy</summary> <p>The nomenclature used in the CIE XYZ colour space is analogous to the naming convention used in the CIE RGB colour space. So x = X/(X+Y+Z) and y = Y/(X+Y+Z). The chromaticity value is obtained by projecting colours on the X+Y+Z=1 plane, and then z values are discarded to get the (x,y) values — analogous to projecting the the X+Y+Z=1 chromaticity plane to the XY plane.</p> <p>Here, the chromaticity of the spectral colours (the spectral locus) is shown above.</p></details><p>Since the XYZ colour space is specifically defined to map spectral colours to positive values, the chromaticity values (which are just normalized values of the primaries) of the spectral colours are all positive as well. Because all perceivable colours are some combination of the spectral colours, the chromaticity values of all observable colours will lie inside the spectral locus area, and thus will also have positive values.<p><canvas id=canvasLocusRatio></canvas><div class=cBox id=divLocusRatio></div><input id=sliderLocusRatioWavelength0 type=range><input id=sliderLocusRatioIntensity0 type=range><br><input id=sliderLocusRatioWavelength1 type=range><input id=sliderLocusRatioIntensity1 type=range><br><span id=spanLocusRatiox></span>, <span id=spanLocusRatioy></span><br><details open><summary>The CIE xy chromaticity diagram</summary> <p>Unlike the rg chromaticity space, all the perceivable colours have their chromaticity defined using non-negative values in the xy chromaticity space. The (x,y) chromaticity values for all the colours can be derived the same way it was done in the rg-chromaticity space — using a linear combination of two spectral colours, and then using their xy chromaticity values to calculate the xy chromaticity values of the colours formed using the two spectral colours.</p></details><p>Quantifying colours using chromaticity values is not perfect because of the elimination of the luminance information, but chromaticity diagrams like the xy chromaticity diagram can be still be useful for certain applications — eg. to visualize the limitations of gamuts.<h2 id=-9>Gamut</h2><p>Again, consider two monochromatic light sources. These lights will produce colours with a chromaticity that is a linear combination of the chromaticity values of their constituent monochromatic lights — the chromaticity of the resultant colours will lie on the line that joins the spectral colours in the CIE xy chromaticity plane. No combination of intensities can produce a colour with a chromaticity outside this line.<p>For example, lights having greenish and bluish chromaticities can never produce a colour with reddish chromaticities.<p><canvas id=canvasLocusGamutTwo></canvas><div class=cBox id=divLocusGamutTwo></div><input id=sliderLocusGamutTwoIntensity0 type=range>546nm<br><input id=sliderLocusGamutTwoIntensity1 type=range>435nm<br><details open><summary>Chromaticity of two lights</summary> <p>Colours created by combining two (monochromatic) lights will have a chromaticity that lies on the line connecting the chromaticity points of the two lights in the chromaticity diagram. In this case, the 546nm and 435nm lights can never create colours with chromaticities lying outside this line.</p></details><p>Until now, all the visualizations used the ratios of two monochromatic lights to calculate the chromaticity of colours. However, the chromaticity can be calculated using three monochromatic lights as well. The chromaticity will then be a linear combination of three chromaticity values.<p>Consider three monochromatic lights — the CIE RGB primaries, for example. The chromaticity of the colour created using the primaries would be a linear combination of the three chromaticities.<p><canvas id=canvasLocusGamutCIE></canvas><div class=cBox id=divLocusGamutCIE></div><input id=sliderLocusGamutCIEIntensity0 type=range>700nm (0.733, 0.267)<br><input id=sliderLocusGamutCIEIntensity1 type=range>546nm (0.266, 0.724)<br><input id=sliderLocusGamutCIEIntensity2 type=range>435nm (0.166, 0.008)<br> +<span id=spanLocusGamutCIEIntensity0></span> × (0.733r + 0.267g)<br> +<span id=spanLocusGamutCIEIntensity1></span> × (0.266r + 0.724g)<br> +<span id=spanLocusGamutCIEIntensity2></span> × (0.166r + 0.008g)<br> = <span id=spanLocusGamutCIEChromaticity></span><details open><summary>Chromaticity of three primaries</summary> <p>The chromaticity of colours produced using the CIE RGB primaries will always lie inside the triangle formed by the three primaries — since it uses a linear combination of non-negative scalars coefficients (intensity values).</p></details><p>The chromaticity of the colours which can be physically created using the RGB primaries will lie inside the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Convex_polygon target=_blank>convex polygon</a> formed by the primaries. This range of colours (or chromaticities) that the primaries can produce is called its <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Gamut target=_blank>gamut</a>. Points lying outside the polygon cannot be physically created (at least with the same three primaries), since it would require a linear combination with negative coefficients — creating colours with chromaticities that lie outside this polygon would require some negative intensities of the primaries, which is physically not possible.<p>Using more primaries would result in a convex polygon with more vertices (corners) and would cover a larger area, and hence more chromaticities, but having three primaries is usually enough for most applications. It is also economically more efficient to use primaries which are not purely monochromatic. So most displays use just three primaries which aren’t monochromatic — some of these primaries have been standardized, and are even used to construct colour spaces. For example, the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/SRGB target=_blank>sRGB</a> and <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Adobe_RGB_color_space target=_blank>Adobe RGB</a> colour spaces use standardized primaries which are non-monochromatic.<p><canvas id=canvasLocusGamutMultiple></canvas><div class=cBox id=divLocusGamutMultiple></div><input id=sliderLocusGamutMultipleIntensity0 type=range>Primary A<br><input id=sliderLocusGamutMultipleIntensity1 type=range>Primary B<br><input id=sliderLocusGamutMultipleIntensity2 type=range>Primary C<br><p><select id=selectLocusGamutMultipleSpace></select><details open><summary>Gamut & Colour space</summary> <p>Gamut refers to the set of colours that can be physically recreated by an output device, while a colour space is simply a mathematical model used to describe colours. Colour spaces like <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/SRGB target=_blank>sRGB</a> and <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/DCI-P3 target=_blank>DCI-P3</a> may arbitrarily restrict itself to certain values to more accurately represent physical and economic constraints. Others like the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/ProPhoto_RGB_color_space target=_blank>Pro Photo</a> use imaginary primaries (like the CIE XYZ colour space) to be able to represent a broader set of perceivable colours.</p></details><p>The sRGB colour space underpins another popular way of quantifying colours — <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Web_colors#Hex_triplet target=_blank>colour hexcodes</a>. These hex codes represent the intensity of the sRGB primaries. Usually, the first two hex numbers (same as one byte, or eight bits) correspond to the intensity of the reddish primary. The next two hex values represent the intensity of the greenish primary and the next two hex numbers describe the intensity of the bluish primary.<p><canvas id=canvasHexDeconstruction></canvas><details open><summary>Colour depth</summary> <p>In hex notation, a colour is usually represented using 24 bits. The number of bits assigned for representing a colour is called the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_depth target=_blank>bit depth or colour depth</a>. These 24-bit colours are sometimes also called true colours, and can represent a total of 2^24 values or 16,777,216 colours. Similarly, there are also 8-bit colours and 30-bit colours, which can represent fewer and more shades of colours respectively. There are also other colour depths like 3-bit colours, etc.</p> <p>The colour depth in a way represents the ‘precision’ of colours that can be produced, but does not represent the ‘range’ of colours. The colours are still constrained by their primaries — colours outside the gamut of the primaries can never be recreated even if more bits are assigned to control their intensity more precisely.</p></details><p>So far multiple ways of quantifying colours have been discussed. It might feel like that these are more than enough for most applications, but there is one more important thing to consider when quantifying and reproducing colours.<h2 id=-10>White Point</h2><p>Back to some physical science — all bodies radiate photons, due to <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Black-body_radiation target=_blank>blackbody radiation</a>. The spectral power distribution of the radiation is a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Planck%27s_law#The_law target=_blank>function of temperature</a>. The spectral power distribution of the radiation will have a colour associated with it.<p><canvas id=canvasBlackbodyColorSPD></canvas> <canvas id=canvasBlackbodyColorSSC></canvas> <canvas id=canvasBlackbodyColorRSP></canvas><div class=cBox id=divBlackbodyColor></div><input id=sliderBlackbodyColorTemperature type=range>Temperature<br><details open><summary>Blackbody</summary> <p>A blackbody is an idealized body that emits only blackbody radiation (radiation is only a function of temperature). Most bodies in the universe are not perfect blackbodies, but approximating it as such can still be useful. The sun is an example of a blackbody — its surface is around 5500K, and emits the highest intensity radiation around the visible wavelengths (visible light).</p></details><p>The colours above have a corresponding chromaticity — and when mapped on the CIE xy chromaticity diagram, together form the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Planckian_locus target=_blank>Planckian locus</a>.<p><canvas id=canvasLocusPlanckian></canvas><details open><summary>Planckian locus</summary> <p>The chromaticity of the colours of blackbodies at different temperatures when mapped on a chromaticity diagram forms the Planckian locus. Try changing the previous temperature slider to see how temperature affects the spectral power distribution of a blackbody, and how that in turn affects its chromaticity.</p></details><p>The <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_temperature target=_blank>colour temperature</a> is another way to quantify certain colours and chromaticities — mostly different types of white. It is a common way to do it, as most physical sources of illumination have a chromaticity close to these values. Daylight, for example, has a chromaticity similar to a blackbody at temperatures ranging from 5000K to 6500K, and incandescent bulbs emit light having a colour temperature close to 2700K.<details><summary>Daylight colour temperature</summary> <p>Incandescent bulbs have filaments heated to about 2000K to 2700K and thus have colour temperature close to that temperature. But the same is not true for sunlight as its colour temperature depends on the time of day. Due to <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Rayleigh_scattering target=_blank>Rayleigh scattering</a>, shorter wavelengths of sunlight get scattered making it appear redder, while making skies and overcast light appear bluer. During mornings and evenings when the sun is lower in the sky, more light gets scattered causing sunlight to appear even redder (have a lower colour temperature). Daylight is the combination of all direct and indirect sunlight, and thus also depends on the time of day.</p></details><p>Most illuminants have chromaticity values that lie close to the Planckian locus, but do not lie exactly on it — as most bodies are not perfect blackbodies. Other light sources like <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Fluorescent_lamp#Color_temperature target=_blank>fluorescent lights</a> and <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Light-emitting_diode#White_LEDs target=_blank>LEDs</a>, do not even use blackbody radiation to emit light, and thus also do not necessarily lie on the Planckian locus.<p><canvas id=canvasLocusPlanckianLED></canvas><details open><summary>White illuminants</summary> <p>Daylight and other light sources usually appear white, and may have chromaticities that lie near the Planckian locus, but need not lie exactly on it.</p></details><p>While the chromaticity values of these illuminants do not lie on the Planckian locus, they are still close enough to be perceptually similar to a blackbody, to be meaningfully attributed to a colour temperature. These colours can be assigned a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Correlated_color_temperature target=_blank>correlated colour temperature</a> depending on the colour temperature it most closely resembles.<p><canvas id=canvasLocusPlanckianCCT></canvas><details open><summary>Correlated colour temperature lines</summary> <p>The lines intersecting the Planckian locus represent correlated colour temperatures. Two points on a correlated colour temperature line have the same correlated correlated colour temperature.</p></details><p>Correlated colour temperature can describe non-ideal blackbodies and other sources of white light. But since a single correlated colour temperature can correspond to multiple chromaticity values, it is not a very precise way to describe white light.<p>Instead, to represent different types of white light in an unambiguous and precise manner, certain <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Standard_illuminant target=_blank>standard illuminants</a> have been defined. These are theoretical sources of light with a precisely defined spectral power distribution, and therefore with an exact chromaticity value as well.<p><canvas id=canvasLocusIlluminants></canvas><div class=cBox id=divLocusIlluminants></div><select id=selectLocusIlluminants></select><details open><summary>Standard illuminants</summary> <p>Some of <a class=linkSwitch id=linkLocusIlluminants>these illuminants</a> have defined to represent common sources of illumination (light). For example, the D65 illuminant represents daylight with a colour temperature of around 6500K, while Illuminant A represents an incandescent light with a specific spectral power distribution.</p></details><p>All this effort just to define certain chromaticities of white light might seem excessive, but its importance is more apparent when you consider that most colours are visible not because they emit their own light, but because they reflect the light of an illuminant. That illuminant is usually daylight (white), or some other illuminant trying to replicate daylight.<p>Since a non-emissive body does not emit its own light, its spectral power distribution is mostly dependent on what it reflects, and the spectral power distribution of the light source illuminating it. More accurately, it is the point-wise product of the body’s <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Reflectance target=_blank>spectral reflectance curve</a> and the spectral power distribution of the illuminant. For example, a body might appear bluish under daylight but the same body may appear more yellowish under an incandescent light.<p><canvas id=canvasReflectanceReflectance></canvas> <canvas id=canvasReflectanceIlluminant></canvas> <canvas id=canvasReflectanceProduct></canvas> <canvas id=canvasReflectanceRSP></canvas><div class=cBox id=divReflectance></div><select id=selectReflectanceIlluminants></select><details open><summary>Spectral reflectance</summary> <p>The spectral reflectance describes how much light is reflected based on its wavelength. More precisely, it defines the fraction of light that gets reflected, as a function of wavelength.</p> <p>The first graph shows the spectral reflectance of an object, the second graph shows the spectral power distribution of the illuminant, and the third shows the resultant spectral power distribution of this reflected radiation (the product of the above two curves).</p> <p>As can be seen, the colour of a non-emissive body is dependent on its ‘own colour’ as well as the light illuminating it. For example, here, changing the above illuminant to <a class=linkSwitch id=linkReflectanceIlluminantA>Illuminant A</a> or <a class=linkSwitch id=linkReflectanceD65>D65</a> makes the resultant colours appear warmer or colder, even if the ‘inherent colours’ — <a class=linkSwitch id=linkReflectanceSPDGrey>greys</a>, <a class=linkSwitch id=linkReflectanceSPDWhite>whites</a>, <a class=linkSwitch id=linkReflectanceSPDPink>pinks</a>, <a class=linkSwitch id=linkReflectanceSPDPurple>purples</a>, <a class=linkSwitch id=linkReflectanceSPDOlive>greens</a>, etc — do not change at all.</p></details><p>The colour distortions due to differences in illumination can be seen more clearly in this example — the same objects here are lit up by different types of illuminants.<p><canvas id=canvasWhitePointsCompare></canvas><div class=cBox id=divWhitePointsCompareA></div><div class=cBox id=divWhitePointsCompareB></div><details open><summary>Colour picker</summary> <p>Hover over the pictures to compare the ‘same colour’ under different illumination.</p></details><details open><summary>Colour distortion</summary> <p>The left colour box shows colours under warm lighting, while the right colour box shows how it would appear under cool lighting. Here, the ‘same colours’ get distorted because of inconsistent illumination.</p> <p>Image sourced from <a rel="noopener nofollow noreferrer" href=https://www.goodfreephotos.com/other-photos/rooms/classroom-and-blackboard.jpg.php target=_blank>Good Free Photos</a>, under <a rel="noopener nofollow noreferrer" href=https://creativecommons.org/public-domain/cc0/ target=_blank>CC0</a>.</p></details><p>The change in colour because of differences in illumination also affects its chromaticity. Consider a ‘white’ object (reflects all wavelengths of light equally) under an equal energy illuminant (emits equal energy of radiation/light for all wavelengths). The resultant spectral power distribution of this body will be a straight line — ie. equal energy across all wavelengths. Its chromaticity will lie at (0.333, 0.333) in the xy chromaticity space. Now consider the same object under the illuminant D65. The spectral power distribution of the body will now be the same as the D65 illuminant, and will lie at (0.313, 0.329) in the xy space. The chromaticity of a ‘white’ object will similarly vary for other illuminants.<p>So a display that emits its own light, trying to mimic ‘white’ will need to take into account the illumination conditions of the environment in order to not appear out of place, and look ‘correct’. Other colours will similarly get distorted, and need to be corrected. Again, similar to how colour addition was approximated as linear, this correction can also be approximated as a simple linear transformation — by scaling the colours linearly, using the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/White_point target=_blank>white point</a> as a reference.<p><canvas id=canvasLocusWhitePoint></canvas><div class=cBox id=divLocusWhitePoint2></div><div class=cBox id=divLocusWhitePoint1></div><input id=sliderLocusWhitePointIntensity0 type=range>Primary A<br><input id=sliderLocusWhitePointIntensity1 type=range>Primary B<br><input id=sliderLocusWhitePointIntensity2 type=range>Primary C<br><p><select id=selectLocusWhitePoint1></select><select id=selectLocusWhitePoint2></select><br> <select id=selectLocusWhitePointSpace></select><br><details open><summary>White point as reference</summary> <p>The chromaticity of a colour that is being lit by the first illuminant (or how it would roughly appear, under that illuminant) is shown in black, while the chromaticity of the same colour being lit by the second illuminant is shown in gray.</p> <p>The chromaticity correction can be approximated by linearly transforming the colour space, such that when the colour space primaries are at their maximum intensity (or equal intensities, in the case of chromaticity), the chromaticity of the colour will be the same as the required illuminant. This acts as a reference [white] point for other colours — they are scaled using the same transformation that was used to transform the original white point to match the chromaticity of the other illuminant.</p></details><details open><summary>True chromaticity</summary> <p>The true chromaticity of a non-emissive object is hard to define, since it is dependent on illumination. Instead, it can be defined using its spectral reflectance, which is independent of illumination. Since an equal energy illuminant has equal energy across wavelengths, it will not distort the spectral reflectance of the object, and so the chromaticity when lit by an equal energy illuminant can be considered its ‘exact colour’.</p></details><p>Take another look at the images of the classroom from earlier. Despite the colours being different (because of the different illuminants), they might appear similar because of <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Chromatic_adaptation target=_blank>chromatic adaptation</a>. Human colour perception adjusts for differences in illumination to preserve colours of objects — by using clues from the surrounding environment. For the classroom images, the white walls may ‘feel’ white despite their chromaticity values being closer to those of yellows and blues. Other colours also can also appear ‘original’ despite being distorted by the illuminant, because of chromatic adaptation.<p><canvas id=canvasChromaticAdaptation></canvas><div class=cBox id=divChromaticAdaptationA></div><div class=cBox id=divChromaticAdaptationB></div><details open><summary>Chromatic adaptation</summary> <p>Notice how the whites (as well as other colours) still ‘feel’ white (or their original colour) despite having distorted chromaticities.</p></details><p>However sometimes, chromatic adaptation can also trick the brain into perceiving wrong colours. A relatively famous, but extreme example of this is <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/The_dress target=_blank>the dress</a>. The same colours of the dress can be perceived as blue and black, or white and gold — depending on how the brain perceives the white point of the light illuminating the dress. If the brain assumes the dress is lit by a bluish light, it tries to correct for it, making the dress look white and gold. Conversely, if the brain assumes a warmer illuminant, the brain tries correcting the colour distortion, making the dress appear blue and black.<p><canvas id=canvasChromaticAdaptationDressBlue></canvas><details open><summary>Chromatic adaptation: Blue and black dress</summary> <p>The above graphic shows how the colours of a blue and black dress would look if it is distorted by a yellowish illuminant. If the brain assumes the illuminant is indeed yellowish, it would try to ‘correct’ the colours to their ‘original’ hues, which in this case would be blue and black.</p> <p>Image sourced <a rel="noopener nofollow noreferrer" href=https://web.archive.org/web/20150227014959/http://swiked.tumblr.com/post/112073818575/guys-please-help-me-is-this-dress-white-and target=_blank>Tumblr (archived)</a>, under fair use.</p></details><p><canvas id=canvasChromaticAdaptationDressGold></canvas><details open><summary>Chromatic adaptation: White and gold dress</summary> <p>Similarly here, how the colours of a white and gold dress might get distorted by a bluish illuminant is shown above. The brain, assuming the illuminant is tinted blue, would try to correct the colours back to white and gold.</p> <p>Notice that the colours of the right image in both the above and below graphic are the exact same. But how the colours are perceived by the brain depends on whether it assumed a warm or cool illuminant. In very ambiguous cases like these, it might be equally likely for people to perceive it as either of the two.</p></details><p>The above scenario is an example of what happens when colours are quantified without correcting for the white point (illumination) — it can look out of place, and in extreme cases like the dress, even lead to completely wrong colour description and reproduction. If the colours of the dress are mapped on the chromaticity diagram directly without any corrections, it will not always describe the ‘real’ chromaticity of the dress.<p>For example, here, the colours of two pixels with blue/white and black/gold are mapped on the xy chromaticity diagram. Notice how the chromaticity values correspond to bluish and yellowish hues, suggesting the colours are actually blue and gold. This is obviously not the case. The colours can be corrected by changing the white point, by applying the same linear white point transformation from <a href=https://ekunazanu.foo/lab/quantifying-colour/#canvasLocusWhitePoint>above</a>.<p><canvas id=canvasChromaticAdaptationDressChroma></canvas><details open><summary>Chromaticity of the dress colours</summary> <p>The chromaticity of the dress on the xy chromaticity diagram maps to values that correspond to (somewhat) bluish and yellowish chromaticities. But the actual colours of the dress are blue and black. Setting the white point to a <a class=linkSwitch id=linkChromaticAdaptationDressChromaWarm>warmer colour</a> and then <a class=linkSwitch id=linkChromaticAdaptationDressChromaCool>transforming it to the equal energy illuminant</a> would transform the chromaticity values to result in more accurate approximations of the ‘true’ colours of the dress.</p></details><p>For accurate colour quantification and reproduction, the illumination of the environment needs to be taken into account too — when quantifying colours of non-emissive objects, which are most of objects around us.<h2 id=-11>Colour Science</h2><p>The original questions should be easy to answer now. Colour blindness exists because of cone anomalies. Addition of colours results in a colour whose brightness (luminance) is the sum of the luminance of the colourants, and its hue or chromaticity is the ratios of its colourants. The multiplication of colours can be thought of as a colour reflecting the colour of another coloured illuminant. Colour hexcodes, even with 16,777,216 possible values, are still limited by their primaries. And the dress appears both white and gold, and blue and black because of chromatic adaptation.<p>Colours are a very interesting topic, because it involves quantifying something that feels innately qualitative. This article mainly discusses <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Additive_color target=_blank>additive colour models</a>, but <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Subtractive_color target=_blank>subtractive</a> and <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_mixing target=_blank>other colour models</a> are just as interesting. Most of these topics involve ways to <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Colorimetry target=_blank>describe and recreate colours</a>. But there are also entirely different branch of science that deal with the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_psychology target=_blank>psychology of colours</a> — why certain <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_scheme target=_blank>colour combinations</a> appear pleasing, how the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_symbolism target=_blank>meaning of colours</a> vary across cultures, or how colours <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_psychology#Influence_of_color_on_perception target=_blank>affect other senses</a>.<p>The subject of colours is vast — spanning scientific domains from quantum physics and electromagnetism to physiology and psychology. This post is a very tiny fraction of what constitutes <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Color_science target=_blank>colour science</a>.<hr><h2 id=-12>References</h2><ul><li>Jamie Wong: <a rel="noopener nofollow noreferrer" href=https://jamie-wong.com/post/color/ target=_blank>Color: From Hexcodes to Eyeballs</a><li>Bartosz Ciechanowski: <a rel="noopener nofollow noreferrer" href=https://ciechanow.ski/color-spaces/ target=_blank>Color Spaces</a><li>Douglas A. Kerr: <a rel="noopener nofollow noreferrer" href=https://graphics.stanford.edu/courses/cs148-10-summer/docs/2010--kerr--cie_xyz.pdf target=_blank>The CIE XYZ and xyY Color Spaces</a></ul><script>// i started writing functions trying to be as general as possible
// so that i can use them in modular way, but that was stupid and
// the code is not modular but it's hack-y & not precise instead
// aslo i gave up on modularity half way through im just tired now

const WIDTH = 1280;

const CONES = ["L", "M", "S"]
const RGBPM = ["R", "G", "B"]
const XYZPM = ["X", "Y", "Z"]
const COLORL = "#000";
const COLORM = "#000";
const COLORS = "#000";
const COLORR = "#000";
const LMSCOLORS = [COLORL, COLORM, COLORS];
const LMSMEANS = [71, 63, 37];
const RODMEANS = 48;
const LMSDEVNS = [34, 35, 20];
const RODDEVNS = 25;
const LMSNORMS = [0.016764, 0.016239, 0.028216];
const RODNORMS = 0.02222;
const LMSMAGNS = [1, 1, 1];

// http://brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
const MATRIX_XYZ_RGB = [
    [ 2.3706743, -0.9000405, -0.4706338],
    [-0.5138850,  1.4253036,  0.0885814],
    [ 0.0052982, -0.0146949,  1.0093968]];
const MATRIX_RGB_XYZ = [
    [0.4887180, 0.3106803, 0.2006017],
    [0.1762044, 0.8129847, 0.0108109],
    [0.0000000, 0.0102048, 0.9897952]];
const MATRIX_XYZ_SRGB = [
    [ 3.2404542, -1.5371385, -0.4985314],
    [-0.9692660,  1.8760108,  0.0415560],
    [ 0.0556434, -0.2040259,  1.0572252]];
const MATRIX_LMS_SRGB = [
    [ 5.4722110, -4.6419592,  0.1696371],
    [-1.1252416,  2.2931704, -0.1678952],
    [ 0.0298016, -0.1931807,  1.1636479]];
const MATRIX_SRGB_XYZ = [
    [ 0.4124564,  0.3575761,  0.1804375],
    [ 0.2126729,  0.7151522,  0.0721750],
    [ 0.0193339,  0.1191920,  0.9503041]];
const MATRIX_TEMP_SRGB = [
    [16.302, -14.322, -0.531],
    [-1.582,   3.516, -0.055],
    [ 0.032,  -0.077,  1.031]];

const arraySPDSaturated = new Array(126).fill(1);

const arraySPDGrey = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5];
const arraySPDPink = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0];
let arraySPDOlive = [0.000, 0.000, 0.000, 0.000, 0.000, 0.001, 0.003, 0.006, 0.010, 0.015, 0.020, 0.026, 0.032, 0.040, 0.045, 0.055, 0.063, 0.071, 0.077, 0.089, 0.100, 0.110, 0.122, 0.134, 0.148, 0.164, 0.182, 0.200, 0.217, 0.239, 0.259, 0.281, 0.305, 0.330, 0.356, 0.382, 0.410, 0.439, 0.468, 0.498, 0.528, 0.559, 0.590, 0.621, 0.653, 0.683, 0.713, 0.744, 0.773, 0.801, 0.827, 0.853, 0.876, 0.899, 0.919, 0.938, 0.953, 0.967, 0.979, 0.988, 0.995, 0.998, 1.000, 0.998, 0.995, 0.988, 0.979, 0.967, 0.953, 0.938, 0.919, 0.899, 0.876, 0.853, 0.827, 0.801, 0.773, 0.744, 0.713, 0.683, 0.653, 0.621, 0.590, 0.559, 0.528, 0.498, 0.468, 0.439, 0.410, 0.382, 0.356, 0.330, 0.305, 0.281, 0.259, 0.239, 0.217, 0.200, 0.182, 0.164, 0.148, 0.134, 0.122, 0.110, 0.100, 0.089, 0.077, 0.071, 0.063, 0.055, 0.045, 0.040, 0.032, 0.026, 0.020, 0.015, 0.010, 0.006, 0.003, 0.001, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000];
const arraySPDPurple = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0];
const arraySPDSun = [0.57, 0.589, 0.609, 0.627, 0.646, 0.664, 0.681, 0.698, 0.714, 0.73, 0.746, 0.76, 0.775, 0.789, 0.802, 0.814, 0.826, 0.838, 0.849, 0.859, 0.869, 0.879, 0.887, 0.896, 0.904, 0.911, 0.918, 0.924, 0.93, 0.935, 0.94, 0.944, 0.948, 0.952, 0.955, 0.958, 0.96, 0.962, 0.964, 0.965, 0.966, 0.967, 0.967, 0.967, 0.967, 0.966, 0.965, 0.964, 0.963, 0.961, 0.959, 0.957, 0.955, 0.952, 0.949, 0.946, 0.943, 0.94, 0.936, 0.933, 0.929, 0.925, 0.921, 0.917, 0.912, 0.908, 0.903, 0.899, 0.894, 0.889, 0.884, 0.879, 0.874, 0.869, 0.864, 0.858, 0.853, 0.848, 0.842, 0.837, 0.831, 0.826, 0.82, 0.814, 0.809, 0.803, 0.797, 0.792, 0.786, 0.78, 0.774, 0.769, 0.763, 0.757, 0.751, 0.746, 0.74, 0.734, 0.728, 0.723, 0.717, 0.711, 0.705, 0.7, 0.694, 0.688, 0.683, 0.677, 0.672, 0.666, 0.661, 0.655, 0.65, 0.644, 0.639, 0.633, 0.628, 0.623, 0.617, 0.612, 0.607, 0.602, 0.597, 0.591, 0.586, 0.581];
const arraySPDD65 = [0.413, 0.431, 0.443, 0.455, 0.487, 0.558, 0.606, 0.677, 0.716, 0.738, 0.761, 0.775, 0.78, 0.785, 0.79, 0.78, 0.769, 0.752, 0.735, 0.781, 0.827, 0.858, 0.899, 0.93, 0.961, 0.992, 0.993, 0.995, 0.997, 0.996, 0.988, 0.983, 0.976, 0.975, 0.978, 0.981, 0.982, 0.964, 0.946, 0.928, 0.923, 0.924, 0.925, 0.927, 0.923, 0.92, 0.916, 0.911, 0.903, 0.896, 0.888, 0.893, 0.9, 0.908, 0.91, 0.901, 0.896, 0.888, 0.884, 0.883, 0.882, 0.882, 0.871, 0.861, 0.851, 0.841, 0.835, 0.826, 0.816, 0.815, 0.814, 0.813, 0.806, 0.788, 0.77, 0.752, 0.754, 0.757, 0.761, 0.762, 0.761, 0.761, 0.76, 0.756, 0.751, 0.748, 0.743, 0.732, 0.721, 0.71, 0.706, 0.707, 0.708, 0.709, 0.7, 0.691, 0.684, 0.678, 0.679, 0.679, 0.68, 0.683, 0.689, 0.694, 0.694, 0.684, 0.677, 0.667, 0.649, 0.627, 0.605, 0.591, 0.596, 0.6, 0.605, 0.612, 0.616, 0.623, 0.63, 0.598, 0.565, 0.544, 0.529, 0.55, 0.571, 0.592];
const arraySPDILLA = [0.044, 0.047, 0.050, 0.053, 0.056, 0.059, 0.062, 0.066, 0.069, 0.073, 0.077, 0.081, 0.085, 0.089, 0.094, 0.098, 0.103, 0.107, 0.112, 0.117, 0.122, 0.128, 0.133, 0.139, 0.144, 0.150, 0.156, 0.162, 0.168, 0.174, 0.180, 0.187, 0.193, 0.200, 0.207, 0.214, 0.221, 0.228, 0.235, 0.242, 0.250, 0.257, 0.265, 0.273, 0.280, 0.288, 0.296, 0.304, 0.313, 0.321, 0.329, 0.337, 0.346, 0.354, 0.363, 0.371, 0.380, 0.389, 0.398, 0.407, 0.415, 0.424, 0.433, 0.442, 0.451, 0.461, 0.470, 0.479, 0.488, 0.497, 0.506, 0.516, 0.525, 0.534, 0.544, 0.553, 0.562, 0.571, 0.581, 0.590, 0.599, 0.609, 0.618, 0.627, 0.636, 0.646, 0.655, 0.664, 0.673, 0.683, 0.692, 0.701, 0.710, 0.719, 0.728, 0.737, 0.746, 0.755, 0.764, 0.772, 0.781, 0.790, 0.799, 0.807, 0.816, 0.824, 0.833, 0.841, 0.850, 0.858, 0.866, 0.874, 0.882, 0.890, 0.898, 0.906, 0.914, 0.922, 0.930, 0.937, 0.945, 0.953, 0.960, 0.967, 0.975, 0.982];

const arrayCOLMATX = [0.001, 0.001, 0.001, 0.002, 0.003, 0.004, 0.006, 0.008, 0.010, 0.013, 0.019, 0.027, 0.038, 0.048, 0.067, 0.092, 0.119, 0.144, 0.158, 0.174, 0.186, 0.192, 0.195, 0.194, 0.191, 0.187, 0.181, 0.174, 0.168, 0.158, 0.145, 0.128, 0.109, 0.096, 0.079, 0.063, 0.048, 0.036, 0.029, 0.020, 0.013, 0.008, 0.004, 0.003, 0.001, 0.002, 0.004, 0.009, 0.013, 0.023, 0.035, 0.050, 0.067, 0.079, 0.098, 0.119, 0.139, 0.161, 0.176, 0.200, 0.224, 0.249, 0.276, 0.293, 0.321, 0.349, 0.377, 0.405, 0.423, 0.451, 0.477, 0.501, 0.524, 0.537, 0.555, 0.570, 0.582, 0.589, 0.590, 0.589, 0.584, 0.573, 0.557, 0.544, 0.521, 0.495, 0.464, 0.429, 0.405, 0.369, 0.334, 0.301, 0.269, 0.249, 0.219, 0.191, 0.166, 0.142, 0.128, 0.109, 0.092, 0.076, 0.063, 0.055, 0.046, 0.038, 0.031, 0.026, 0.023, 0.018, 0.015, 0.012, 0.009, 0.008, 0.007, 0.006, 0.005, 0.004, 0.003, 0.003, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001];
const arrayCOLMATY = [0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.001, 0.001, 0.001, 0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.008, 0.010, 0.012, 0.014, 0.016, 0.018, 0.021, 0.024, 0.028, 0.031, 0.035, 0.039, 0.045, 0.051, 0.055, 0.063, 0.071, 0.080, 0.090, 0.098, 0.111, 0.126, 0.144, 0.164, 0.179, 0.206, 0.236, 0.268, 0.303, 0.326, 0.361, 0.394, 0.423, 0.449, 0.465, 0.485, 0.503, 0.518, 0.530, 0.537, 0.545, 0.550, 0.554, 0.555, 0.555, 0.554, 0.550, 0.544, 0.535, 0.529, 0.517, 0.504, 0.489, 0.472, 0.460, 0.441, 0.421, 0.400, 0.379, 0.365, 0.343, 0.322, 0.301, 0.279, 0.266, 0.245, 0.225, 0.205, 0.185, 0.172, 0.153, 0.136, 0.121, 0.106, 0.097, 0.085, 0.073, 0.063, 0.053, 0.048, 0.040, 0.034, 0.028, 0.023, 0.020, 0.017, 0.014, 0.011, 0.009, 0.008, 0.007, 0.005, 0.004, 0.003, 0.003, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.000, 0.000, 0.000];
const arrayCOLMATZ = [0.004, 0.005, 0.007, 0.009, 0.013, 0.018, 0.026, 0.038, 0.045, 0.061, 0.090, 0.130, 0.184, 0.231, 0.322, 0.443, 0.577, 0.699, 0.770, 0.857, 0.920, 0.961, 0.983, 0.989, 0.990, 0.985, 0.977, 0.963, 0.948, 0.915, 0.869, 0.800, 0.715, 0.660, 0.579, 0.501, 0.428, 0.362, 0.324, 0.273, 0.231, 0.196, 0.167, 0.151, 0.130, 0.112, 0.094, 0.077, 0.067, 0.054, 0.043, 0.036, 0.030, 0.027, 0.022, 0.018, 0.014, 0.011, 0.010, 0.007, 0.006, 0.004, 0.003, 0.003, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000];
const arrayCOLMATR = [0.000, 0.000, 0.000, 0.000, 0.000, 0.001, 0.001, 0.001, 0.002, 0.002, 0.001, 0.001, 0.002, 0.004, 0.005, 0.006, 0.006, 0.007, 0.006, 0.001, -0.001, -0.007, -0.012, -0.019, -0.029, -0.039, -0.052, -0.065, -0.075, -0.087, -0.100, -0.113, -0.124, -0.132, -0.141, -0.150, -0.159, -0.166, -0.171, -0.180, -0.191, -0.202, -0.216, -0.225, -0.244, -0.260, -0.275, -0.287, -0.294, -0.295, -0.291, -0.279, -0.259, -0.243, -0.214, -0.179, -0.143, -0.100, -0.070, -0.019, 0.033, 0.089, 0.153, 0.193, 0.261, 0.331, 0.403, 0.478, 0.526, 0.603, 0.676, 0.747, 0.816, 0.858, 0.918, 0.971, 1.019, 1.054, 1.070, 1.087, 1.094, 1.087, 1.069, 1.050, 1.014, 0.970, 0.915, 0.850, 0.805, 0.737, 0.669, 0.604, 0.542, 0.502, 0.442, 0.387, 0.336, 0.288, 0.260, 0.222, 0.187, 0.154, 0.128, 0.112, 0.093, 0.077, 0.063, 0.053, 0.047, 0.036, 0.031, 0.024, 0.018, 0.016, 0.014, 0.012, 0.010, 0.008, 0.006, 0.006, 0.003, 0.003, 0.001, 0.002, 0.002, 0.002, 0.001];
const arrayCOLMATG = [0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.001, 0.003, 0.006, 0.010, 0.015, 0.021, 0.027, 0.035, 0.041, 0.049, 0.058, 0.069, 0.080, 0.087, 0.100, 0.113, 0.127, 0.141, 0.153, 0.172, 0.193, 0.218, 0.246, 0.266, 0.304, 0.345, 0.388, 0.434, 0.463, 0.507, 0.547, 0.580, 0.608, 0.624, 0.642, 0.657, 0.668, 0.673, 0.675, 0.674, 0.669, 0.662, 0.649, 0.640, 0.624, 0.604, 0.581, 0.554, 0.536, 0.505, 0.473, 0.439, 0.403, 0.379, 0.343, 0.307, 0.271, 0.237, 0.217, 0.186, 0.158, 0.134, 0.111, 0.099, 0.081, 0.066, 0.053, 0.043, 0.037, 0.028, 0.022, 0.017, 0.012, 0.010, 0.008, 0.005, 0.004, 0.002, 0.002, 0.001, 0.001, 0.001, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000];
const arrayCOLMATB = [0.004, 0.005, 0.007, 0.009, 0.013, 0.018, 0.026, 0.038, 0.045, 0.061, 0.090, 0.131, 0.185, 0.233, 0.325, 0.447, 0.582, 0.706, 0.777, 0.865, 0.929, 0.970, 0.993, 0.999, 1.000, 0.994, 0.986, 0.972, 0.957, 0.923, 0.877, 0.807, 0.721, 0.665, 0.583, 0.504, 0.431, 0.364, 0.325, 0.274, 0.231, 0.195, 0.166, 0.149, 0.128, 0.109, 0.090, 0.073, 0.062, 0.049, 0.037, 0.030, 0.024, 0.020, 0.015, 0.011, 0.007, 0.004, 0.003, 0.000, 0.000, -0.002, -0.003, -0.003, -0.004, -0.004, -0.003, -0.004, -0.004, -0.004, -0.003, -0.003, -0.003, -0.002, -0.002, -0.002, -0.001, -0.001, -0.002, -0.001, -0.001, -0.001, -0.001 -0.001, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000];
const arrayCHRMATR = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.001, -0.007, -0.012, -0.019, -0.029, -0.039, -0.054, -0.069, -0.081, -0.098, -0.119, -0.148, -0.183, -0.212, -0.260, -0.321, -0.398, -0.489, -0.557, -0.676, -0.819, -0.957, -1.102, -1.184, -1.297, -1.340, -1.354, -1.304, -1.272, -1.130, -0.993, -0.842, -0.694, -0.605, -0.483, -0.366, -0.268, -0.173, -0.115, -0.029, 0.047, 0.118, 0.191, 0.232, 0.296, 0.355, 0.410, 0.464, 0.497, 0.546, 0.589, 0.631, 0.671, 0.694, 0.729, 0.760, 0.790, 0.817, 0.832, 0.854, 0.874, 0.890, 0.907, 0.913, 0.926, 0.936, 0.945, 0.951, 0.956, 0.963, 0.968, 0.972, 0.978, 0.980, 0.982, 0.987, 0.988, 0.993, 0.992, 0.995, 0.994, 0.993, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
const arrayCHRMATG = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.001, 0.003, 0.006, 0.010, 0.015, 0.021, 0.028, 0.037, 0.044, 0.055, 0.069, 0.090, 0.118, 0.140, 0.184, 0.241, 0.318, 0.415, 0.498, 0.646, 0.828, 1.033, 1.255, 1.400, 1.617, 1.778, 1.911, 1.972, 2.004, 1.942, 1.866, 1.752, 1.630, 1.556, 1.449, 1.343, 1.255, 1.166, 1.110, 1.029, 0.952, 0.883, 0.812, 0.771, 0.708, 0.648, 0.592, 0.538, 0.506, 0.457, 0.412, 0.371, 0.331, 0.306, 0.272, 0.240, 0.210, 0.183, 0.168, 0.146, 0.126, 0.109, 0.094, 0.086, 0.073, 0.063, 0.054, 0.048, 0.043, 0.036, 0.031, 0.027, 0.021, 0.019, 0.017, 0.012, 0.011, 0.006, 0.007, 0.004, 0.005, 0.006, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
const arrayCHRMATB = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.004, 1.006, 1.009, 1.014, 1.018, 1.026, 1.031, 1.036, 1.042, 1.050, 1.057, 1.064, 1.072, 1.075, 1.079, 1.080, 1.073, 1.058, 1.030, 0.991, 0.924, 0.846, 0.784, 0.680, 0.561, 0.443, 0.331, 0.268, 0.187, 0.126, 0.090, 0.064, 0.049, 0.033, 0.022, 0.013, 0.006, 0.004, 0, 0, -0.002, -0.003, -0.003, -0.004, -0.004, -0.003, -0.003, -0.003, -0.003, -0.002, -0.002, -0.002, -0.001, -0.001, -0.001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
const arrayCHRMATX = [0.171, 0.171, 0.171, 0.171, 0.171, 0.171, 0.171, 0.171, 0.171, 0.171, 0.171, 0.171, 0.171, 0.171, 0.171, 0.171, 0.17, 0.170, 0.169, 0.167, 0.166, 0.166, 0.163, 0.162, 0.159, 0.157, 0.153, 0.149, 0.146, 0.143, 0.138, 0.131, 0.124, 0.118, 0.109, 0.099, 0.086, 0.074, 0.064, 0.049, 0.035, 0.023, 0.012, 0.009, 0.003, 0.006, 0.011, 0.023, 0.032, 0.052, 0.074, 0.098, 0.123, 0.138, 0.162, 0.186, 0.207, 0.229, 0.243, 0.266, 0.287, 0.308, 0.331, 0.344, 0.367, 0.387, 0.408, 0.430, 0.444, 0.465, 0.486, 0.506, 0.526, 0.538, 0.557, 0.574, 0.592, 0.608, 0.618, 0.632, 0.644, 0.656, 0.666, 0.672, 0.680, 0.687, 0.693, 0.699, 0.702, 0.707, 0.711, 0.713, 0.717, 0.720, 0.720, 0.723, 0.725, 0.728, 0.727, 0.731, 0.730, 0.730, 0.732, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733, 0.733];
const arrayCHRMATY = [0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.006, 0.007, 0.008, 0.010, 0.011, 0.013, 0.015, 0.017, 0.020, 0.024, 0.027, 0.031, 0.037, 0.046, 0.058, 0.067, 0.087, 0.111, 0.143, 0.184, 0.217, 0.274, 0.340, 0.413, 0.489, 0.537, 0.611, 0.674, 0.732, 0.778, 0.802, 0.824, 0.834, 0.831, 0.822, 0.814, 0.801, 0.785, 0.771, 0.754, 0.742, 0.724, 0.705, 0.686, 0.665, 0.652, 0.631, 0.610, 0.589, 0.568, 0.555, 0.533, 0.513, 0.493, 0.473, 0.460, 0.442, 0.424, 0.406, 0.391, 0.382, 0.368, 0.355, 0.344, 0.333, 0.328, 0.319, 0.312, 0.306, 0.301, 0.298, 0.293, 0.289, 0.286, 0.282, 0.280, 0.279, 0.276, 0.275, 0.271, 0.272, 0.268, 0.269, 0.269, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267, 0.267];
const arrayCHRMATZ = [0.823, 0.823, 0.823, 0.823, 0.823, 0.823, 0.823, 0.823, 0.823, 0.823, 0.823, 0.823, 0.823, 0.823, 0.823, 0.823, 0.824, 0.824, 0.824, 0.824, 0.824, 0.824, 0.824, 0.824, 0.825, 0.825, 0.826, 0.826, 0.826, 0.825, 0.825, 0.822, 0.817, 0.813, 0.803, 0.788, 0.769, 0.741, 0.718, 0.675, 0.624, 0.563, 0.498, 0.453, 0.385, 0.32, 0.256, 0.197, 0.165, 0.123, 0.091, 0.070, 0.054, 0.047, 0.036, 0.028, 0.020, 0.015, 0.013, 0.009, 0.007, 0.004, 0.003, 0.003, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
const arrayCOLMATSR = [0.17, 0.29, 0.38, 0.43, 0.46, 0.49, 0.50, 0.51, 0.50, 0.48, 0.46, 0.43, 0.4, 0.38, 0.35, 0.33, 0.3, 0.26, 0.23, 0.2, 0.17, 0.13, 0.1, 0.06, 0.01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.01, 0.11, 0.1, 0.15, 0.25, 0.3, 0.35, 0.45, 0.5, 0.54, 0.64, 0.69, 0.73, 0.83, 0.87, 0.92, 0.96, 1.05, 1.04, 1.14, 1.18, 1.22, 1.26, 1.3, 1.29, 1.33, 1.31, 1.35, 1.33, 1.37, 1.35, 1.34, 1.37, 1.36, 1.34, 1.33, 1.26, 1.29, 1.23, 1.21, 1.19, 1.18, 1.11, 1.1, 1.09, 1.02, 1.01, 0.94, 0.88, 0.86, 0.85, 0.79, 0.78, 0.72, 0.66, 0.64, 0.64, 0.57, 0.51, 0.51, 0.5, 0.44, 0.39, 0.38, 0.37, 0.32, 0.31, 0.3, 0.25, 0.24];
const arrayCOLMATSG = [0.06, 0.06, 0.07, 0.07, 0.09, 0.11, 0.1, 0.12, 0.14, 0.13, 0.15, 0.16, 0.18, 0.19, 0.21, 0.22, 0.26, 0.27, 0.28, 0.31, 0.32, 0.35, 0.37, 0.39, 0.41, 0.44, 0.46, 0.49, 0.52, 0.54, 0.56, 0.61, 0.63, 0.65, 0.69, 0.71, 0.73, 0.76, 0.78, 0.82, 0.83, 0.87, 0.88, 0.89, 0.93, 0.94, 0.96, 0.97, 0.99, 1, 1.01, 1.02, 1.04, 1.03, 1.05, 1.05, 1.05, 1.05, 1.05, 1.05, 1.04, 1.04, 1.03, 1.01, 1, 1, 0.97, 0.96, 0.94, 0.92, 0.9, 0.88, 0.86, 0.83, 0.82, 0.78, 0.75, 0.73, 0.7, 0.67, 0.65, 0.63, 0.61, 0.57, 0.55, 0.52, 0.49, 0.47, 0.44, 0.42, 0.39, 0.37, 0.36, 0.32, 0.31, 0.29, 0.26, 0.24, 0.23, 0.21, 0.19, 0.18, 0.16, 0.15, 0.15, 0.13, 0.11, 0.11, 0.09, 0.09, 0.09, 0.07, 0.06, 0.05, 0.05, 0.04, 0.03, 0.03, 0.04, 0.03, 0.02, 0.03, 0.02, 0.01, 0.02, 0.01];
const arrayCOLMATSB = [0.17, 0.33, 0.43, 0.46, 0.48, 0.51, 0.53, 0.54, 0.54, 0.53, 0.51, 0.53, 0.54, 0.54, 0.54, 0.55, 0.55, 0.56, 0.58, 0.6, 0.62, 0.64, 0.67, 0.69, 0.7, 0.72, 0.75, 0.78, 0.82, 0.85, 0.89, 0.91, 0.94, 0.96, 0.98, 0.99, 1, 1, 1, 0.99, 0.97, 0.95, 0.93, 0.9, 0.88, 0.83, 0.8, 0.76, 0.72, 0.68, 0.63, 0.58, 0.54, 0.5, 0.46, 0.42, 0.37, 0.33, 0.29, 0.26, 0.23, 0.2, 0.17, 0.15, 0.12, 0.1, 0.08, 0.07, 0.05, 0.04, 0.03, 0.02, 0.01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
const arrayPLANCKX = [0.657, 0.624, 0.596, 0.57, 0.545, 0.521, 0.5, 0.48, 0.462, 0.445, 0.43, 0.416, 0.404, 0.393, 0.383, 0.374, 0.366, 0.358, 0.352, 0.345, 0.34, 0.335, 0.33, 0.325, 0.321, 0.318, 0.314, 0.311, 0.308, 0.305, 0.303, 0.3, 0.298, 0.296, 0.294, 0.292, 0.29, 0.289, 0.287, 0.286, 0.284, 0.283, 0.282, 0.28, 0.279, 0.278, 0.277, 0.276, 0.275, 0.274, 0.274, 0.273, 0.272, 0.271, 0.271, 0.27, 0.269, 0.269, 0.268, 0.267, 0.267, 0.266, 0.266, 0.265, 0.265, 0.264, 0.264, 0.264, 0.263, 0.263, 0.262, 0.262, 0.262, 0.261, 0.261, 0.261, 0.26, 0.26, 0.26, 0.259, 0.259, 0.259, 0.258, 0.258, 0.258, 0.258, 0.257, 0.257, 0.257, 0.257];
const arrayPLANCKY = [0.344, 0.368, 0.387, 0.401, 0.41, 0.414, 0.415, 0.414, 0.411, 0.407, 0.402, 0.396, 0.39, 0.384, 0.378, 0.373, 0.367, 0.362, 0.357, 0.352, 0.347, 0.343, 0.339, 0.335, 0.331, 0.328, 0.324, 0.321, 0.318, 0.315, 0.313, 0.31, 0.308, 0.305, 0.303, 0.301, 0.299, 0.298, 0.296, 0.294, 0.292, 0.291, 0.289, 0.288, 0.287, 0.285, 0.284, 0.283, 0.282, 0.281, 0.28, 0.279, 0.278, 0.277, 0.276, 0.275, 0.274, 0.274, 0.273, 0.272, 0.271, 0.271, 0.27, 0.269, 0.269, 0.268, 0.268, 0.267, 0.267, 0.266, 0.266, 0.265, 0.265, 0.264, 0.264, 0.263, 0.263, 0.262, 0.262, 0.262, 0.261, 0.261, 0.26, 0.26, 0.26, 0.259, 0.259, 0.259, 0.258, 0.258];
const arrayPLANCKZ = [0.003, 0.008, 0.017, 0.03, 0.046, 0.065, 0.085, 0.106, 0.128, 0.148, 0.168, 0.188, 0.206, 0.223, 0.238, 0.253, 0.267, 0.28, 0.292, 0.303, 0.313, 0.323, 0.332, 0.34, 0.348, 0.355, 0.362, 0.368, 0.374, 0.379, 0.385, 0.39, 0.394, 0.399, 0.403, 0.407, 0.41, 0.414, 0.417, 0.42, 0.423, 0.426, 0.429, 0.431, 0.434, 0.436, 0.438, 0.441, 0.443, 0.445, 0.446, 0.448, 0.45, 0.452, 0.453, 0.455, 0.456, 0.458, 0.459, 0.46, 0.462, 0.463, 0.464, 0.465, 0.466, 0.467, 0.468, 0.469, 0.47, 0.471, 0.472, 0.473, 0.474, 0.475, 0.475, 0.476, 0.477, 0.478, 0.478, 0.479, 0.48, 0.48, 0.481, 0.482, 0.482, 0.483, 0.484, 0.484, 0.485, 0.485];

const XYA = [0.448, 0.407, 0.145];
const XYB1 = [0.456, 0.408, 0.136];
const XYB5 = [0.312, 0.324, 0.364];
const XYD50 = [0.346, 0.359, 0.295];
const XYD55 = [0.332, 0.347, 0.321];
const XYD65 = [0.313, 0.329, 0.358];
const XYD75 = [0.299, 0.315, 0.386];
const XYE = [0.333, 0.333, 0.333];
const XYF1 = [0.313, 0.337, 0.350];
const XYF4 = [0.440, 0.403, 0.157];
const XYDCI = [[0.680, 0.320, 0], [0.265, 0.690, 0.045], [0.150, 0.060, 0.79]];
const XYSRGB = [[0.640, 0.330, 0.003], [0.300, 0.600, 0.100], [0.150, 0.060, 0.790]];
const XYPROPH = [[0.7347, 0.2653, 0], [0.1596, 0.8404, 0], [0.0366, 0.0001, 0.9633]];
const XYCIERGB = [[0.733, 0.267, 0], [0.266, 0.724, 0.009], [0.166, 0.008, 0.824]];
const XYADBRGB = [[0.640, 0.330, 0.03], [0.210, 0.710, 0.080], [0.150, 0.060, 0.790]];
const XYRECBT = [[0.708, 0.292, 0], [0.170, 0.797, 0.033], [0.131, 0.046, 0.823]];

const arrayCOLMATRGB = [arrayCOLMATR, arrayCOLMATG, arrayCOLMATB];
const arrayCOLMATXYZ = [arrayCOLMATX, arrayCOLMATY, arrayCOLMATZ];
const arrayCHRMATRGB = [arrayCHRMATR, arrayCHRMATG, arrayCHRMATB];
const arrayCHRMATXYZ = [arrayCHRMATX, arrayCHRMATY, arrayCHRMATZ];
const arrayPLANCKXYZ = [arrayPLANCKX, arrayPLANCKY, arrayPLANCKZ];
const arrayCOLMATSRGB = [arrayCOLMATSR, arrayCOLMATSG, arrayCOLMATSB];
const arrayXYILLS =  [XYA, XYD50, XYD55, XYD65, XYD75, XYE, XYF1, XYF4, XYB1, XYB5];
const COLSPACES = [XYSRGB, XYDCI, XYCIERGB, XYADBRGB, XYRECBT];
const XYILLSPDS = [arraySPDILLA, arraySPDD65, arraySPDSaturated];

const RGBWAVES = [114, 59, 20]; // real wavelength = i * 2.8 + 380
const CMFLABELS = ["700nm", "546nm", "435nm"];
const CMFLABELPOS = [[960, 91], [500, 91], [130, 91]];
const CONELABELS = ["L cones", "M cones", "S cones"];
const CONELABELPOS = [[1156, 165], [900, 165], [104, 165]];
const WAVXYZLABELS = ["450nm", "500nm", "550nm", "600nm", "650nm"];
const WAVXYZLABELPOS = [[175, 585], [80, 215], [400, 105], [620, 325], [685, 395]];
const CCTTEMPS = ["1500K", "2000K", "2500K", "3000K", "4000K", "6000K", "10000K", "Inf"];
const CCTTEMPSPOS = [[572, 305], [548, 285], [492, 267], [426, 275], [362, 291], [316, 315], [266, 343], [283, 431]];
const XYILLNAMES =  ["A (Incandescent)", "D50 (Horizon Daylight)", "D55 (Morning Daylight)", "D65 (Noon Daylight)", "D75 (North Sky Daylight)", "E (Equal Energy Illuminant)", "F1 (Daylight Fluorescent)", "F4 (Warm White Fluorescent)", "LED-B1 (Warm White LED)", "LED-B5 (Daylight LED)"];
const COLSPACENAMES = ["sRGB", "DCI-P3", "CIE-RGB", "Adobe RGB", "BT.2100"];
const XYILLSPDNAMES = ["A (Incandescent)", "D65 (Noon Daylight)", "E (Equal Energy Illuminant)"];

const CCTLINES = [[[0.570, 0.384, 0], [0.595, 0.402, 0]], [[0.502, 0.385, 0], [0.545, 0.443, 0]], [[0.449, 0.373, 0], [0.500, 0.457, 0]], [[0.415, 0.359, 0], [0.452, 0.443, 0]], [[0.365, 0.325, 0], [0.392, 0.433, 0]], [[0.343, 0.335, 0], [0.345, 0.369, 0]], [[0.325, 0.280, 0], [0.321, 0.392, 0]], [[0.309, 0.303, 0], [0.302, 0.333, 0]], [[0.301, 0.288, 0], [0.288, 0.320, 0]], [[0.294, 0.282, 0], [0.279, 0.309, 0]], [[0.308, 0.242, 0], [0.250, 0.345, 0]], [[0.265, 0.248, 0], [0.245, 0.269, 0]]];

const BASEXOFF = 181;
const BASEYOFF = 481;
const BASEAXES = [[3, 0, 0, 1], [0, 3, 0, 1], [0, 0, 3, 1]];
const TRANSFMAT = [[400, 0, -120, BASEXOFF], [0, -400, 80, BASEYOFF]];
const PROJMAT = [[690, 0, 0, 131], [0, -690, 0, 591]];
const CUBEPOINTS = [1, 1, 1];
const CUBELABELPOS = [1.1, 1.2, 1.25];
const CUBELABELOFF = [0.95, 1.1, 0.95];
const IDENTITY = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];

const CHRDIAGRAMDAT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAcCAIAAAAfs1O6AAAAAXNSR0IArs4c6QAAA7tJREFUeF591cuKHFUYwPH/d+rUpaenZ5JMLkaMuBAJQly5EeJCtz6M+AC+khvxIbIw4AVMAsEQJ5kkM+mpnumu7rqdz65zOHQxgvCnqCqoX38f1XQL+gsALTRQwwYquIRzOIHH3/HkM/gQbsF1uKbMlKljryfvyDpsS9JgtrVIi0UNgCQwzsYywMS7KVhIdci6oaTDxCSIkACgEbpSGkV/raShwPVe9FCIJn48muB1346LM4aLUBwwcF40DdKAP5r4cETHXBSTEZ/5AdMe25F4a8SNZ8T+t6uikoXCgHE0qaEOxyjuUB0vl43FFPJtSu5I4/s1NSZyxBODBiimV7ic8MqjmPVerDEbZAOjYzgJECgIoODAoxEhDlgohSNvd5ysI9dAqMWgCTpeOUOj5Z0jHuYcTpRtRUdaY9eYakgqqAaXyrceMuNliSv7im0Zk5t8co2vpnw67Ska0jVmNcQSWQ2xrdqhCT9+DwZklwiAOGge4h6Qf0xx1x3caPYmyxO7wFx6bumttW/jq2EziD9E0SAmnCOAIt3XmPtbUfM7XX6wKrJylsyPWSAXEMTqKmpxFkAUHDpGFeoPSI6or7v9WV1kl2JKlUXC+Z8sy0Gpfa2vC4UXAqh6IkEckgwZ8wC9w+wmzfV2NblMkrKVsqHsKYXF31THnov1Xuyx9BaIa/pIMT2afm7y2/RHrp1VF+l5I/OVzNect5z3LISLnNVz2gDtilsDeBS8C+I+Qm+i19omnztzNpWzKfN93teUHaWjhDJl/gTHOEtnxyAICio4ua1y4HRSrZN3Be9yTgvOJsy3bsu840x5Ba9n0EdPwVm6BAiKvyP0hla+rc2Bo2jVLFveWN5kbN3TCWcbThtetTwXmELnC2jvxdaAh0KdUAuV3Ktkr8XWjguj7ywnGW+35RwX/NGA8VzrC2IXxSbxInQ7jnO5sSKvMRWUom8TfW35J5VHGW4K5r9fnCj2diCAXmiFmoFbyL0TZhuyFeYSPYVjw++WNwXsg0ACqa8NXRENQMtAr+FCOOX+a/ZW2BI5hWeiT42SCYXSCRpQXwM20MTFDWuGKmEJC+E9vOTWS4pn2F/V/AxPcSRKqmThNxeK/8myFoANrIQS3sJfHL6geEwBFgUUo7tNs/hFAST+URroIPFbV16s4IIw4Bc/cQsOIQcTn1QS9QsKveIEBUaoQBK3rhi6JAzIb3wJRzCFDDUAKEIYE+tLNc7rS8MxZFkCccAXfPOIuzCDHLVxRkXUbxdQoSdOSlwiZv4FiZsWgB+yll0AAAAASUVORK5CYII="
const CHRDIAGRAM = new Image(); CHRDIAGRAM.src = CHRDIAGRAMDAT;


const canvasPhoton = initializeCanvas("canvasPhoton", 400);
const sliderPhotonWavelength = document.getElementById("sliderPhotonWavelength");
initializeSliders(sliderPhotonWavelength, 0.1, 0.4, 0.01, 0.3);
sliderPhotonWavelength.addEventListener("input", updatePhoton);
function updatePhoton() {
    canvasPhoton.clearRect(0, 0, WIDTH, 400);
    drawPhoton(canvasPhoton, 0.45 - sliderPhotonWavelength.value, 440, 201, 400, 150);
    drawSpaceLine(canvasPhoton, [0, 201, 0], [440, 201, 0], IDENTITY, "#000", 2);
    drawSpaceLine(canvasPhoton, [WIDTH, 201, 0], [839, 201, 0], IDENTITY, "#000", 2);
    canvasPhoton.stroke();
}
updatePhoton();


const canvasPhotonSpectrum = initializeCanvas("canvasPhotonSpectrum", 300);
const arrayPhotonSpectrumWavelengths = ["1km", "1cm", "10µm", "500nm", "10nm", "0.1nm"];
const arrayPhotonSpectrumNames = ["Radio", "Microwave", "Infrared", "Visible", "Ultraviolet", "X-ray"];
initializeCanvasText(canvasPhotonSpectrum);
for (let i = 0; i < 6; i++) {
    drawPhoton(canvasPhotonSpectrum, i * 0.05 + 0.1, i * 210 + 21, 110, 175);
    canvasPhotonSpectrum.fillText(arrayPhotonSpectrumWavelengths[i], i * 210 + 115, 225);
    canvasPhotonSpectrum.fillText(arrayPhotonSpectrumNames[i], i * 210 + 115, 265);
}


const canvasPhotonPower = initializeCanvas("canvasPhotonPower", 300);
const canvasPhotonPowerSPD = initializeCanvas("canvasPhotonPowerSPD", 300);
const sliderPhotonPowerWavelength = [];
const arrayPhotonPowerNumber = new Array(126).fill(0);
for (let i = 0; i < 5; i++) {
    sliderPhotonPowerWavelength[i] = document.getElementById(`sliderPhotonPowerWavelength${i}`);
    initializeSliders(sliderPhotonPowerWavelength[i], 0, 5, 1, 5);
    sliderPhotonPowerWavelength[i].addEventListener("input", updatePhotonPower);
}
function updatePhotonPower() {
    canvasPhotonPower.clearRect(0, 0, WIDTH, 300);
    for (let i = 0; i < 5; i++) {
        arrayPhotonPowerNumber[i * 18 + 26] = sliderPhotonPowerWavelength[i].value / (5 + i);
        for (let j = 0; j < sliderPhotonPowerWavelength[i].value; j++)
            drawPhoton(canvasPhotonPower, 0.3 - i * 0.05, (j * 510 + i * 100) % 1100 + 15, (i * 310 + j * 20) % 200 + 50);
    }
    canvasPhotonPowerSPD.clearRect(0, 0, WIDTH, 300);
    drawSPD(canvasPhotonPowerSPD, arrayPhotonPowerNumber);
}
updatePhotonPower();


const canvasSPDSun = initializeCanvas("canvasSPDSun", 300);
drawSPD(canvasSPDSun, arraySPDSun);


const canvasSensitivityCurves = initializeCanvas("canvasSensitivityCurves", 300);
drawSSC(canvasSensitivityCurves, [COLORR].concat(LMSCOLORS), [RODMEANS].concat(LMSMEANS), [RODDEVNS].concat(LMSDEVNS), [1, 1, 1, 1]);
drawLabels(canvasSensitivityCurves, CONELABELS, CONELABELPOS);
drawLabels(canvasSensitivityCurves, ["Rods"], [[688, 165]]);


const canvasSimpleSPD = initializeCanvas("canvasSimpleSPD", 300);
const canvasSimpleSSC = initializeCanvas("canvasSimpleSSC", 300);
const canvasSimpleRSP = initializeCanvas("canvasSimpleRSP", 200);
const sliderSimpleWavelength = document.getElementById("sliderSimpleWavelength");
const arraySimpleSPD = new Array(126).fill(0);
let varSimplePrevWavelength = 0;
initializeSliders(sliderSimpleWavelength, 0, 125, 1, 18);
sliderSimpleWavelength.addEventListener("input", updateSimple);
drawSSC(canvasSimpleSSC);
drawLabels(canvasSimpleSSC, CONELABELS, CONELABELPOS);
function updateSimple() {
    canvasSimpleSPD.clearRect(0, 0, WIDTH, 300);
    canvasSimpleRSP.clearRect(0, 0, WIDTH, 200);
    arraySimpleSPD[varSimplePrevWavelength] = 0;
    varSimplePrevWavelength = sliderSimpleWavelength.value;
    arraySimpleSPD[varSimplePrevWavelength] = 1;
    drawSPD(canvasSimpleSPD, arraySimpleSPD);
    drawRSP(canvasSimpleRSP, arraySimpleSPD);
}
updateSimple();


const canvasSimpleColorSPD = initializeCanvas("canvasSimpleColorSPD", 300);
const canvasSimpleColorSSC = initializeCanvas("canvasSimpleColorSSC", 300);
const canvasSimpleColorRSP = initializeCanvas("canvasSimpleColorRSP", 200);
const sliderSimpleColorWavelength = document.getElementById("sliderSimpleColorWavelength");
const divSimpleColor = document.getElementById("divSimpleColor");
initializeSliders(sliderSimpleColorWavelength, 0, 125, 1, 18);
const arraySimpleColorSPD = new Array(126).fill(0);
let arraySimpleColorRSP = [0, 0, 0];
let varSimpleColorPrevWavelength = 0;
sliderSimpleColorWavelength.addEventListener("input", updateSimpleColor);
drawSSC(canvasSimpleColorSSC);
function updateSimpleColor() {
    canvasSimpleColorSPD.clearRect(0, 0, WIDTH, 300);
    canvasSimpleColorRSP.clearRect(0, 0, WIDTH, 200);
    arraySimpleColorSPD[varSimpleColorPrevWavelength] = 0;
    varSimpleColorPrevWavelength = sliderSimpleColorWavelength.value;
    arraySimpleColorSPD[varSimpleColorPrevWavelength] = 1;
    drawSPD(canvasSimpleColorSPD, arraySimpleColorSPD);
    arraySimpleColorRSP = drawRSP(canvasSimpleColorRSP, arraySimpleColorSPD);
    colorBoxRGB(divSimpleColor, vectorMultiply(MATRIX_LMS_SRGB, arraySimpleColorRSP));
    divSimpleColor.innerHTML = getNameWavelength(divSimpleColor, varSimpleColorPrevWavelength * 2.8 + 380);
}
updateSimpleColor();


const canvasRodsLightSPD = initializeCanvas("canvasRodsLightSPD", 300);
const canvasRodsLightSSC = initializeCanvas("canvasRodsLightSSC", 300);
const canvasRodsLightRSP = initializeCanvas("canvasRodsLightRSP", 250);
const sliderRodsLightWavelength = document.getElementById("sliderRodsLightWavelength");
const divRodsLight = document.getElementById("divRodsLight");
const arrayRodsLightSPD = new Array(126).fill(0);
let arrayRodsLightRSP = [0, 0, 0];
let varRodsLightPrevWavelength = 0;
initializeSliders(sliderRodsLightWavelength, 0, 125, 1, 18);
sliderRodsLightWavelength.addEventListener("input", updateRodsLight);
drawSSC(canvasRodsLightSSC, [COLORR].concat(LMSCOLORS), [RODMEANS].concat(LMSMEANS), [RODDEVNS].concat(LMSDEVNS), [1, 0.15, 0.15, 0.15]);
drawLabels(canvasRodsLightSSC, ["Rods"], [[500, 55]]);
function updateRodsLight() {
    canvasRodsLightSPD.clearRect(0, 0, WIDTH, 300);
    canvasRodsLightRSP.clearRect(0, 0, WIDTH, 250);
    arrayRodsLightSPD[varRodsLightPrevWavelength] = 0;
    varRodsLightPrevWavelength = sliderRodsLightWavelength.value;
    arrayRodsLightSPD[varRodsLightPrevWavelength] = 1;
    drawSPD(canvasRodsLightSPD, arrayRodsLightSPD);
    arrayRodsLightRSP = drawRSP(canvasRodsLightRSP, arrayRodsLightSPD, LMSCOLORS.concat(COLORR), LMSMEANS.concat(RODMEANS), LMSDEVNS.concat(RODDEVNS), [1, 1, 1, 9900], LMSNORMS.concat(RODNORMS), CONES.concat("R"));
    colorBoxRGB(divRodsLight, vectorMultiply(MATRIX_LMS_SRGB, arrayRodsLightRSP.slice(0, 3)));
}
updateRodsLight();


const canvasRodsDarkSPD = initializeCanvas("canvasRodsDarkSPD", 300);
const canvasRodsDarkSSC = initializeCanvas("canvasRodsDarkSSC", 300);
const canvasRodsDarkRSP = initializeCanvas("canvasRodsDarkRSP", 250);
const canvasRodsDarkBAR = initializeCanvas("canvasRodsDarkBAR", 50);
const sliderRodsDarkWavelength = document.getElementById("sliderRodsDarkWavelength");
const sliderRodsDarkSensitivityOverlap = document.getElementById("sliderRodsDarkSensitivityOverlap");
const divRodsDarkBox = document.getElementById("divRodsDarkBox");
const linkRodsDarkWavelengthA = document.getElementById("linkRodsDarkWavelengthA");
const linkRodsDarkWavelengthB = document.getElementById("linkRodsDarkWavelengthB");
const arrayRodsDarkSPD = new Array(126).fill(0);
const arrayRodsDarkROD = [0, 0, 0];
let arrayRodsDarkRSP = [0, 0, 0, 0];
let varRodsDarkPrevWavelength = 0;
initializeSliders(sliderRodsDarkWavelength, 0, 125, 1, 18);
sliderRodsDarkWavelength.addEventListener("input", updateRodsDark);
linkRodsDarkWavelengthA.addEventListener("click", () => { sliderRodsDarkWavelength.value = 40; updateRodsDark(); });
linkRodsDarkWavelengthB.addEventListener("click", () => { sliderRodsDarkWavelength.value = 56; updateRodsDark(); });
drawSSC(canvasRodsDarkSSC, [COLORR].concat(LMSCOLORS), [RODMEANS].concat(LMSMEANS), [RODDEVNS].concat(LMSDEVNS), [1, 0.15, 0.15, 0.15]);
drawSpectralBar(canvasRodsDarkBAR, [RODMEANS, RODMEANS, RODMEANS], [RODDEVNS, RODDEVNS, RODDEVNS], 0.75);
function updateRodsDark() {
    canvasRodsDarkSPD.clearRect(0, 0, WIDTH, 300);
    canvasRodsDarkRSP.clearRect(0, 0, WIDTH, 250);
    arrayRodsDarkSPD[varRodsDarkPrevWavelength] = 0;
    varRodsDarkPrevWavelength = sliderRodsDarkWavelength.value;
    arrayRodsDarkSPD[varRodsDarkPrevWavelength] = 0.1;
    drawSPD(canvasRodsDarkSPD, arrayRodsDarkSPD);
    arrayRodsDarkRSP = drawRSP(canvasRodsDarkRSP, arrayRodsDarkSPD, LMSCOLORS.concat(COLORR), LMSMEANS.concat(RODMEANS), LMSDEVNS.concat(RODDEVNS), [0.01, 0.01, 0.01, 10], LMSNORMS.concat(RODNORMS), CONES.concat("R"));
    arrayRodsDarkROD.fill(arrayRodsDarkRSP[3] * 0.75);
    colorBoxRGB(divRodsDarkBox, vectorMultiply(MATRIX_LMS_SRGB, arrayRodsDarkROD));
}
updateRodsDark();


const canvasBlindSPD = initializeCanvas("canvasBlindSPD", 300);
const canvasBlindSSC = initializeCanvas("canvasBlindSSC", 300);
const canvasBlindRSP = initializeCanvas("canvasBlindRSP", 200);
const canvasBlindBAR = initializeCanvas("canvasBlindBAR", 50);
const sliderBlindWavelength = document.getElementById("sliderBlindWavelength");
const sliderBlindSensitivityOverlap = document.getElementById("sliderBlindSensitivityOverlap");
const divBlindBox = document.getElementById("divBlindBox");
const linkBlindWavelengthA = document.getElementById("linkBlindWavelengthA");
const linkBlindWavelengthB = document.getElementById("linkBlindWavelengthB");
const linkBlindOverlap = document.getElementById("linkBlindOverlap");
const arrayBlindSPD = new Array(126).fill(0);
let arrayBlindRSP = [0, 0, 0];
let varBlindPrevWavelength = 0;
initializeSliders(sliderBlindWavelength, 0, 125, 1, 18);
initializeSliders(sliderBlindSensitivityOverlap, LMSMEANS[1], LMSMEANS[0], 0.1, LMSMEANS[0]);
sliderBlindWavelength.addEventListener("input", updateBlind);
sliderBlindSensitivityOverlap.addEventListener("input", updateBlindSensitivity);
linkBlindOverlap.addEventListener("click", () => { sliderBlindSensitivityOverlap.value = LMSMEANS[1]; updateBlindSensitivity(); });
linkBlindWavelengthA.addEventListener("click", () => { sliderBlindWavelength.value = 62; updateBlind(); });
linkBlindWavelengthB.addEventListener("click", () => { sliderBlindWavelength.value = 80; updateBlind(); });
function updateBlind() {
    canvasBlindSPD.clearRect(0, 0, WIDTH, 300);
    canvasBlindRSP.clearRect(0, 0, WIDTH, 200);
    arrayBlindSPD[varBlindPrevWavelength] = 0;
    varBlindPrevWavelength = sliderBlindWavelength.value;
    arrayBlindSPD[varBlindPrevWavelength] = 1;
    drawSPD(canvasBlindSPD, arrayBlindSPD);
    arrayBlindRSP = drawRSP(canvasBlindRSP, arrayBlindSPD, LMSCOLORS, [LMSMEANS[0], sliderBlindSensitivityOverlap.value, LMSMEANS[2]]);
    colorBoxRGB(divBlindBox, vectorMultiply(MATRIX_LMS_SRGB, arrayBlindRSP));
}
function updateBlindSensitivity() {
    canvasBlindSSC.clearRect(0, 0, WIDTH, 300);
    drawSSC(canvasBlindSSC, LMSCOLORS, [LMSMEANS[0], sliderBlindSensitivityOverlap.value, LMSMEANS[2]]);
    drawSpectralBar(canvasBlindBAR, [LMSMEANS[0], sliderBlindSensitivityOverlap.value, LMSMEANS[2]]);
    updateBlind();
}
updateBlindSensitivity();


const canvasBlindBARNR = initializeCanvas("canvasBlindBARNR", 50);
const canvasBlindBARPP = initializeCanvas("canvasBlindBARPP", 50);
const canvasBlindBARDP = initializeCanvas("canvasBlindBARDP", 50);
const canvasBlindBARTP = initializeCanvas("canvasBlindBARTP", 50);
drawSpectralBar(canvasBlindBARNR);
drawSpectralBar(canvasBlindBARPP, [LMSMEANS[1], LMSMEANS[1], LMSMEANS[2]]);
drawSpectralBar(canvasBlindBARDP, [LMSMEANS[0], LMSMEANS[0], LMSMEANS[2]]);
drawSpectralBar(canvasBlindBARTP, [LMSMEANS[0], LMSMEANS[1], LMSMEANS[0]], [LMSDEVNS[0], LMSDEVNS[1], LMSDEVNS[1]]);


const canvasAggregateSSC = initializeCanvas("canvasAggregateSSC", 300);
const GRAYS = ["#aaa", "#aaa", "#aaa"];
drawSSC(canvasAggregateSSC, GRAYS, [72, 64, 36], [33, 35, 20], [0.96, 1, 0.96]);
drawSSC(canvasAggregateSSC, GRAYS, [71, 62, 38], [34, 38, 19], [0.95, 0.93, 0.98]);
drawSSC(canvasAggregateSSC, GRAYS, [70, 63, 37], [32, 34, 20], [1.03, 0.95, 1.03]);
drawSSC(canvasAggregateSSC, GRAYS, [69, 63, 37], [34, 37, 19], [1, 0.98, 0.98]);
canvasAggregateSSC.clearRect(0, 250, WIDTH, 50)
drawSSC(canvasAggregateSSC);


const canvasMonochromaticSPD = initializeCanvas("canvasMonochromaticSPD", 300);
const canvasNonMonochromaticSPD = initializeCanvas("canvasNonMonochromaticSPD", 300);
const arrayMonochromaticSPD = new Array(126).fill(0); arrayMonochromaticSPD[38] = 1;
drawSPD(canvasMonochromaticSPD, arrayMonochromaticSPD);
drawSPD(canvasNonMonochromaticSPD, arraySPDSun);


const canvasPointWiseSPD = initializeCanvas("canvasPointWiseSPD", 300);
const canvasPointWiseSSC = initializeCanvas("canvasPointWiseSSC", 300);
const canvasPointWiseRSP = initializeCanvas("canvasPointWiseRSP", 200);
drawSSC(canvasPointWiseSSC);
drawSPD(canvasPointWiseSPD, arraySPDPurple);
drawRSP(canvasPointWiseRSP, arraySPDPurple);


const canvasSensitivityUndefinedSPD = initializeCanvas("canvasSensitivityUndefinedSPD", 300);
const canvasSensitivityUndefinedSSC = initializeCanvas("canvasSensitivityUndefinedSSC", 300);
const canvasSensitivityUndefinedRSP = initializeCanvas("canvasSensitivityUndefinedRSP", 200);
const arraySensitivityUndefined = new Array(126).fill(0); arraySensitivityUndefined[124] = "NaN";
drawSPD(canvasSensitivityUndefinedSPD, arraySPDPurple);
drawRSP(canvasSensitivityUndefinedRSP, arraySensitivityUndefined);
drawWavelengthAxes(canvasSensitivityUndefinedSSC);
drawLabels(canvasSensitivityUndefinedSSC, ["Undefined"], [[641, 135]]);


const canvasXYChromaticityDiagram = initializeCanvas("canvasXYChromaticityDiagram", 600);
function updateXYChromaticityDiagram() {
    drawSpaceChroma(canvasXYChromaticityDiagram);
    drawSpaceLocus(canvasXYChromaticityDiagram, arrayCHRMATXYZ, PROJMAT);
    drawSpaceLocus(canvasXYChromaticityDiagram, arrayPLANCKXYZ, PROJMAT);
    drawLabels(canvasXYChromaticityDiagram, WAVXYZLABELS, WAVXYZLABELPOS);
    drawLabels(canvasXYChromaticityDiagram, CCTTEMPS, CCTTEMPSPOS, "#000", "20px JetBrains Mono");
    for (let i = 0; i < CCTLINES.length; i++)
        drawSpaceLine(canvasXYChromaticityDiagram, CCTLINES[i][0], CCTLINES[i][1], PROJMAT);
    for (let i = 0; i < COLSPACES.length; i++)
        drawGamut(canvasXYChromaticityDiagram, COLSPACES[i], [0, 0, 0]);
}


const canvasNonSpectralSPD = initializeCanvas("canvasNonSpectralSPD", 300);
const canvasNonSpectralSSC = initializeCanvas("canvasNonSpectralSSC", 300);
const canvasNonSpectralRSP = initializeCanvas("canvasNonSpectralRSP", 200);
const divNonSpectral = document.getElementById("divNonSpectral");
const linkNonSpectralSPDGrey = document.getElementById("linkNonSpectralSPDGrey");
const linkNonSpectralSPDWhite = document.getElementById("linkNonSpectralSPDWhite");
const linkNonSpectralSPDOlive = document.getElementById("linkNonSpectralSPDOlive");
const linkNonSpectralSPDPink = document.getElementById("linkNonSpectralSPDPink");
const linkNonSpectralSPDPurple = document.getElementById("linkNonSpectralSPDPurple");
let arrayNonSpectralSPD = new Array(126).fill(0);
let arrayNonSpectralRSP = [0, 0, 0];
let varNonSpectralMousedown = false;
drawSSC(canvasNonSpectralSSC);
linkNonSpectralSPDGrey.addEventListener("click", () => { arrayNonSpectralSPD = [...arraySPDGrey]; updateNonSpectral(); });
linkNonSpectralSPDWhite.addEventListener("click", () => { arrayNonSpectralSPD = [...arraySPDSaturated]; updateNonSpectral(); });
linkNonSpectralSPDOlive.addEventListener("click", () => { arrayNonSpectralSPD = [...arraySPDOlive]; updateNonSpectral(); });
linkNonSpectralSPDPink.addEventListener("click", () => { arrayNonSpectralSPD = [...arraySPDPink]; updateNonSpectral(); });
linkNonSpectralSPDPurple.addEventListener("click", () => { arrayNonSpectralSPD = [...arraySPDPurple]; updateNonSpectral(); });
canvasNonSpectralSPD.canvas.addEventListener("mousedown", () => varNonSpectralMousedown = true); // unfortunately
canvasNonSpectralSPD.canvas.addEventListener("mouseup", () => varNonSpectralMousedown = false);  // idk a better way
canvasNonSpectralSPD.canvas.addEventListener("mouseout", () => varNonSpectralMousedown = false);
canvasNonSpectralSPD.canvas.addEventListener("touchstart", () => varNonSpectralMousedown = true);
canvasNonSpectralSPD.canvas.addEventListener("touchend", () => varNonSpectralMousedown = false);
canvasNonSpectralSPD.canvas.addEventListener("touchcancel", () => varNonSpectralMousedown = false);
canvasNonSpectralSPD.canvas.addEventListener("mousemove", (evt) => {
    if (varNonSpectralMousedown) {
        getSPD(canvasNonSpectralSPD.canvas, arrayNonSpectralSPD, evt);
        updateNonSpectral(); } });
canvasNonSpectralSPD.canvas.addEventListener("touchmove", (evt) => {
    if (varNonSpectralMousedown) {
        getSPD(canvasNonSpectralSPD.canvas, arrayNonSpectralSPD, evt);
        updateNonSpectral(); } });
function updateNonSpectral() {
    canvasNonSpectralSPD.clearRect(0, 0, WIDTH, 300);
    canvasNonSpectralRSP.clearRect(0, 0, WIDTH, 200);
    drawSPD(canvasNonSpectralSPD, arrayNonSpectralSPD);
    arrayNonSpectralRSP = drawRSP(canvasNonSpectralRSP, arrayNonSpectralSPD);
    colorBoxRGB(divNonSpectral, vectorMultiply(MATRIX_LMS_SRGB, arrayNonSpectralRSP));
}
updateNonSpectral();


const canvasMetamerSPD = initializeCanvas("canvasMetamerSPD", 300);
const canvasMetamerSSC = initializeCanvas("canvasMetamerSSC", 300);
const canvasMetamerRSP = initializeCanvas("canvasMetamerRSP", 200);
const linkMetamerDistributionX = document.getElementById("linkMetamerDistributionX");
const linkMetamerDistributionA = document.getElementById("linkMetamerDistributionA");
const linkMetamerDistributionB = document.getElementById("linkMetamerDistributionB");
const divMetamer = document.getElementById("divMetamer");
const arrayMetamerSPDX = new Array(126).fill(0);
const arrayMetamerSPDA = new Array(126).fill(0);
const arrayMetamerSPDB = new Array(126).fill(0);
for (let i = 82; i < 112; i++) arrayMetamerSPDX[i] = 0.7;
arrayMetamerSPDA[90] = 0.48; arrayMetamerSPDA[100] = 0.55;
arrayMetamerSPDB[80] = 0.36; arrayMetamerSPDB[109] = 0.96;
let arrayMetamerSPD = [...arrayMetamerSPDX];
let arrayMetamerRSP = [0, 0, 0];
let varMetamerMousedown = false;
drawSSC(canvasMetamerSSC);
linkMetamerDistributionX.addEventListener("click", () => { arrayMetamerSPD = [...arrayMetamerSPDX]; updateMetamer(); });
linkMetamerDistributionA.addEventListener("click", () => { arrayMetamerSPD = [...arrayMetamerSPDA]; updateMetamer(); });
linkMetamerDistributionB.addEventListener("click", () => { arrayMetamerSPD = [...arrayMetamerSPDB]; updateMetamer(); });
function updateMetamer() {
    canvasMetamerSPD.clearRect(0, 0, WIDTH, 300);
    canvasMetamerRSP.clearRect(0, 0, WIDTH, 200);
    drawSPD(canvasMetamerSPD, arrayMetamerSPD);
    arrayMetamerRSP = drawRSP(canvasMetamerRSP, arrayMetamerSPD);
    colorBoxRGB(divMetamer, vectorMultiply(MATRIX_LMS_SRGB, arrayMetamerRSP));
}
updateMetamer();


const canvasColorMatchingCMF = initializeCanvas("canvasColorMatchingCMF", 330);
const canvasColorMatchingSPD = initializeCanvas("canvasColorMatchingSPD", 330);
const canvasColorMatchingSSC = initializeCanvas("canvasColorMatchingSSC", 300);
const canvasColorMatchingRSP = initializeCanvas("canvasColorMatchingRSP", 200);
const sliderColorMatchingWavelength = document.getElementById("sliderColorMatchingWavelength");
const linkColorMatchingWavelengthA = document.getElementById("linkColorMatchingWavelengthA");
const divColorMatching = document.getElementById("divColorMatching");
const arrayColorMatchingSPD = new Array(126).fill(0);
let arrayColorMatchingRSP = [0, 0, 0];
let varColorMatchingPrevWavelength = 0;
initializeSliders(sliderColorMatchingWavelength, 0, 125, 1, 18);
sliderColorMatchingWavelength.addEventListener("input", updateColorMatching);
linkColorMatchingWavelengthA.addEventListener("click", () => { sliderColorMatchingWavelength.value = 43; updateColorMatching(); });
drawSSC(canvasColorMatchingSSC);
function updateColorMatching() {
    canvasColorMatchingCMF.clearRect(0, 0, WIDTH, 330);
    canvasColorMatchingSPD.clearRect(0, 0, WIDTH, 330);
    canvasColorMatchingRSP.clearRect(0, 0, WIDTH, 200);
    getCMFSPD(sliderColorMatchingWavelength.value, arrayColorMatchingSPD);
    drawCMF(canvasColorMatchingCMF, sliderColorMatchingWavelength.value);
    drawLabels(canvasColorMatchingCMF, CMFLABELS, CMFLABELPOS);
    drawSPD(canvasColorMatchingSPD, arrayColorMatchingSPD);
    arrayColorMatchingRSP = drawRSP(canvasColorMatchingRSP, arrayColorMatchingSPD, LMSCOLORS, LMSMEANS, LMSDEVNS, LMSMAGNS, LMSNORMS, CONES, 5);
    colorBoxRGB(divColorMatching, vectorMultiply(MATRIX_LMS_SRGB, arrayColorMatchingRSP));
}
updateColorMatching();


const canvasColorMatchCircle = initializeCanvas("canvasColorMatchCircle", 300);
const sliderColorMatchCircleIntensity = document.getElementById("sliderColorMatchCircleIntensity");
const spanColorMatchingCircleR = document.getElementById("spanColorMatchingCircleR");
const linkColorMatchCircle = document.getElementById("linkColorMatchCircle");
let varColorMatchingCircleR = sliderColorMatchCircleIntensity.value;
initializeSliders(sliderColorMatchCircleIntensity, -1, 1, 0.05, 0.85);
sliderColorMatchCircleIntensity.addEventListener("input", updateColorMatchCircle);
linkColorMatchCircle.addEventListener("click", () => { sliderColorMatchCircleIntensity.value = -0.80; updateColorMatchCircle(); });
canvasColorMatchCircle.globalCompositeOperation = "lighter";
function updateColorMatchCircle() {
    varColorMatchingCircleR = sliderColorMatchCircleIntensity.value;
    canvasColorMatchCircle.clearRect(0, 0, WIDTH, 300);
    canvasColorMatchCircle.fillStyle = "#000";
    canvasColorMatchCircle.fillRect(0, 0, WIDTH, 300);
    drawCircles(canvasColorMatchCircle, 300, 150, "rgb(80, 50, 200)");
    drawCircles(canvasColorMatchCircle, 340, 150, "rgb(100, 180, 0)");
    drawCircles(canvasColorMatchCircle, 980, 150, "rgb(0, 230, 200)");
    if (varColorMatchingCircleR < 0)
        drawCircles(canvasColorMatchCircle, 940, 150, `rgb(${varColorMatchingCircleR * -225}, 0, 0)`);
    else
        drawCircles(canvasColorMatchCircle, 320, 150, `rgb(${varColorMatchingCircleR * 225}, 0, 0)`);
    spanColorMatchingCircleR.innerHTML = (varColorMatchingCircleR * 1).toFixed(2);
}
updateColorMatchCircle();


const canvasColorSpaceLMS = initializeCanvas("canvasColorSpaceLMS", 600);
const divColorSpaceLMS = document.getElementById("divColorSpaceLMS");
const sliderColorSpaceLMSL = document.getElementById("sliderColorSpaceLMSL");
const sliderColorSpaceLMSM = document.getElementById("sliderColorSpaceLMSM");
const sliderColorSpaceLMSS = document.getElementById("sliderColorSpaceLMSS");
const linkColorSpaceLMSImp = document.getElementById("linkColorSpaceLMSImp");
let arrayColorSpaceLMSRSP = [0, 0, 0];
initializeSliders(sliderColorSpaceLMSL, 0, 1, 0.025, 0.7);
initializeSliders(sliderColorSpaceLMSM, 0, 1, 0.025, 0.7);
initializeSliders(sliderColorSpaceLMSS, 0, 1, 0.025, 0.5);
sliderColorSpaceLMSL.addEventListener("input", updateColorSpaceLMS);
sliderColorSpaceLMSM.addEventListener("input", updateColorSpaceLMS);
sliderColorSpaceLMSS.addEventListener("input", updateColorSpaceLMS);
linkColorSpaceLMSImp.addEventListener("click", () => {
    sliderColorSpaceLMSL.value = 0;
    sliderColorSpaceLMSM.value = 0.7;
    sliderColorSpaceLMSS.value = 0;
    updateColorSpaceLMS(); });
function updateColorSpaceLMS() {
    canvasColorSpaceLMS.clearRect(0, 0, WIDTH, 600);
    arrayColorSpaceLMSRSP = [sliderColorSpaceLMSL.value, sliderColorSpaceLMSM.value, sliderColorSpaceLMSS.value];
    drawSpaceAxes(canvasColorSpaceLMS);
    drawSpacePlane(canvasColorSpaceLMS, arrayColorSpaceLMSRSP, LMStoRGBClip);
    drawSpaceCube(canvasColorSpaceLMS);
    drawSpacePoint(canvasColorSpaceLMS, arrayColorSpaceLMSRSP);
    drawSpaceLabels(canvasColorSpaceLMS, CONES);
    colorBoxRGB(divColorSpaceLMS, LMStoRGBClip(arrayColorSpaceLMSRSP));
}
updateColorSpaceLMS();


const canvasColorSpaceRGB = initializeCanvas("canvasColorSpaceRGB", 600);
const divColorSpaceRGB = document.getElementById("divColorSpaceRGB");
const sliderColorSpaceRGBR = document.getElementById("sliderColorSpaceRGBR");
const sliderColorSpaceRGBG = document.getElementById("sliderColorSpaceRGBG");
const sliderColorSpaceRGBB = document.getElementById("sliderColorSpaceRGBB");
let arrayColorSpaceRGBRSP = [0, 0, 0];
initializeSliders(sliderColorSpaceRGBR, 0, 1, 0.025, 0.2);
initializeSliders(sliderColorSpaceRGBG, 0, 1, 0.025, 0.7);
initializeSliders(sliderColorSpaceRGBB, 0, 1, 0.025, 0.5);
sliderColorSpaceRGBR.addEventListener("input", updateColorSpaceRGB);
sliderColorSpaceRGBG.addEventListener("input", updateColorSpaceRGB);
sliderColorSpaceRGBB.addEventListener("input", updateColorSpaceRGB);
function updateColorSpaceRGB() {
    canvasColorSpaceRGB.clearRect(0, 0, WIDTH, 600);
    arrayColorSpaceRGBRSP = [sliderColorSpaceRGBR.value, sliderColorSpaceRGBG.value, sliderColorSpaceRGBB.value];
    drawSpaceAxes(canvasColorSpaceRGB);
    drawSpacePlane(canvasColorSpaceRGB, arrayColorSpaceRGBRSP);
    drawSpaceCube(canvasColorSpaceRGB);
    drawSpacePoint(canvasColorSpaceRGB, arrayColorSpaceRGBRSP);
    drawSpaceLabels(canvasColorSpaceRGB);
    colorBoxRGB(divColorSpaceRGB, arrayColorSpaceRGBRSP);
}
updateColorSpaceRGB();


const canvasColorSpaceRGBLocus = initializeCanvas("canvasColorSpaceRGBLocus", 600);
const canvasColorSpaceRGBLocusCMF = initializeCanvas("canvasColorSpaceRGBLocusCMF", 330);
const sliderColorSpaceRGBLocusWavelength = document.getElementById("sliderColorSpaceRGBLocusWavelength");
const arrayColorSpaceRGBLocusRSP = [0, 0, 0];
initializeSliders(sliderColorSpaceRGBLocusWavelength, 0, 125, 1, 18);
sliderColorSpaceRGBLocusWavelength.addEventListener("input", updateColorSpaceRGBLocus);
function updateColorSpaceRGBLocus() {
    canvasColorSpaceRGBLocus.clearRect(0, 0, WIDTH, 600);
    canvasColorSpaceRGBLocusCMF.clearRect(0, 0, WIDTH, 330);
    drawCMF(canvasColorSpaceRGBLocusCMF, sliderColorSpaceRGBLocusWavelength.value);
    drawLabels(canvasColorSpaceRGBLocusCMF, RGBPM, CMFLABELPOS);
    getCMFValues(sliderColorSpaceRGBLocusWavelength.value, arrayColorSpaceRGBLocusRSP);
    drawSpaceAxes(canvasColorSpaceRGBLocus);
    drawSpaceAxes(canvasColorSpaceRGBLocus, TRANSFMAT, [[-1, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);
    drawSpaceCube(canvasColorSpaceRGBLocus);
    drawSpaceLocus(canvasColorSpaceRGBLocus);
    drawSpacePointLines(canvasColorSpaceRGBLocus, arrayColorSpaceRGBLocusRSP)
    drawSpacePoint(canvasColorSpaceRGBLocus, arrayColorSpaceRGBLocusRSP);
    drawSpaceLabels(canvasColorSpaceRGBLocus);
}
updateColorSpaceRGBLocus();


const canvasColorSpaceTransformCMF = initializeCanvas("canvasColorSpaceTransformCMF", 330);
const canvasColorSpaceTransform = initializeCanvas("canvasColorSpaceTransform", 600);
const linkColorSpaceTransformMat = document.getElementById("linkColorSpaceTransformMatRandom");
const arrayColorSpaceTransformBasis = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
const arrayColorSpaceTransformCMF = new Array(3).fill(0).map(() => new Array(126).fill(0));
const sliderColorSpaceTransform = [];
let arrayColorSpaceTransformMatrix = [[0, 0, 0, 0], [0, 0, 0, 0]];
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        sliderColorSpaceTransform[3 * i + j] = document.getElementById(`sliderColorSpaceTransform${i * 3 + j}`);
        initializeSliders(sliderColorSpaceTransform[i * 3 + j], -1, 2, 0.01, IDENTITY[i][j]);
        sliderColorSpaceTransform[3 * i + j].addEventListener("input", updateColorSpaceTransform);
    }
}
linkColorSpaceTransformMatRandom.addEventListener("click", () => {
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            sliderColorSpaceTransform[3 * i + j].value = Math.random();
    updateColorSpaceTransform(); });
function updateColorSpaceTransform() {
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            arrayColorSpaceTransformBasis[i][j] = sliderColorSpaceTransform[i * 3 + j].value;
    arrayColorSpaceTransformMatrix = matrixMultiply(TRANSFMAT, arrayColorSpaceTransformBasis);
    getCMFTransform(arrayColorSpaceTransformBasis, arrayColorSpaceTransformCMF);
    canvasColorSpaceTransform.clearRect(0, 0, WIDTH, 600);
    canvasColorSpaceTransformCMF.clearRect(0, 0, WIDTH, 330);
    drawCMF(canvasColorSpaceTransformCMF, 0, arrayColorSpaceTransformCMF);
    drawSpaceAxes(canvasColorSpaceTransform);
    drawSpaceAxes(canvasColorSpaceTransform, TRANSFMAT, [[-1, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);
    drawSpaceCube(canvasColorSpaceTransform);
    drawSpaceCube(canvasColorSpaceTransform, arrayColorSpaceTransformMatrix, CUBEPOINTS, true);
    drawSpaceLocus(canvasColorSpaceTransform, arrayCOLMATRGB, arrayColorSpaceTransformMatrix);
    drawSpaceLabels(canvasColorSpaceTransform, RGBPM, arrayColorSpaceTransformMatrix);
    drawSpaceMatrix(canvasColorSpaceTransform, arrayColorSpaceTransformBasis);
}
updateColorSpaceTransform();


const canvasColorSpaceTransformSpecificCMF = initializeCanvas("canvasColorSpaceTransformSpecificCMF", 330);
const canvasColorSpaceTransformSpecific = initializeCanvas("canvasColorSpaceTransformSpecific", 600);
const linkColorSpaceTransformSpecificMat = document.getElementById("linkColorSpaceTransformSpecificMat");
const arrayColorSpaceTransformSpecificBasis = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
const arrayColorSpaceTransformSpecificCMF = new Array(3).fill(0).map(() => new Array(126).fill(0));
const sliderColorSpaceTransformSpecific = [];
let arrayColorSpaceTransformSpecificMatrix = [[0, 0, 0, 0], [0, 0, 0, 0]];
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        sliderColorSpaceTransformSpecific[3 * i + j] = document.getElementById(`sliderColorSpaceTransformSpecific${i * 3 + j}`);
        initializeSliders(sliderColorSpaceTransformSpecific[i * 3 + j], -1, 2, 0.01, MATRIX_RGB_XYZ[i][j]);
        sliderColorSpaceTransformSpecific[3 * i + j].addEventListener("input", updateColorSpaceTransformSpecific);
    }
}
linkColorSpaceTransformSpecificMat.addEventListener("click", () => {
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            sliderColorSpaceTransformSpecific[3 * i + j].value = MATRIX_RGB_XYZ[i][j];
    updateColorSpaceTransformSpecific(); });
function updateColorSpaceTransformSpecific() {
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            arrayColorSpaceTransformSpecificBasis[i][j] = sliderColorSpaceTransformSpecific[i * 3 + j].value;
    arrayColorSpaceTransformSpecificMatrix = matrixMultiply(TRANSFMAT, arrayColorSpaceTransformSpecificBasis);
    getCMFTransform(arrayColorSpaceTransformSpecificBasis, arrayColorSpaceTransformSpecificCMF);
    canvasColorSpaceTransformSpecific.clearRect(0, 0, WIDTH, 600);
    canvasColorSpaceTransformSpecificCMF.clearRect(0, 0, WIDTH, 330);
    drawCMF(canvasColorSpaceTransformSpecificCMF, 0, arrayColorSpaceTransformSpecificCMF);
    drawSpaceAxes(canvasColorSpaceTransformSpecific);
    drawSpaceAxes(canvasColorSpaceTransformSpecific, TRANSFMAT, [[-1, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);
    drawSpaceCube(canvasColorSpaceTransformSpecific);
    drawSpaceCube(canvasColorSpaceTransformSpecific, arrayColorSpaceTransformSpecificMatrix, CUBEPOINTS, true);
    drawSpaceLocus(canvasColorSpaceTransformSpecific, arrayCOLMATRGB, arrayColorSpaceTransformSpecificMatrix);
    drawSpaceLabels(canvasColorSpaceTransformSpecific, RGBPM, arrayColorSpaceTransformSpecificMatrix);
    drawSpaceMatrix(canvasColorSpaceTransformSpecific, arrayColorSpaceTransformSpecificBasis);
}
updateColorSpaceTransformSpecific();


const canvasColorSpaceXYZLocus = initializeCanvas("canvasColorSpaceXYZLocus", 600);
const canvasColorSpaceXYZLocusCMF = initializeCanvas("canvasColorSpaceXYZLocusCMF", 330);
const sliderColorSpaceXYZLocusWavelength = document.getElementById("sliderColorSpaceXYZLocusWavelength");
const arrayColorSpaceXYZLocusRSP = [0, 0, 0];
let arrayColorSpaceXYZTransform = [[...MATRIX_RGB_XYZ[0], 0], [...MATRIX_RGB_XYZ[1], 0], [...MATRIX_RGB_XYZ[2], 0], [0, 0, 0, 1]];
arrayColorSpaceXYZTransform = matrixMultiply(TRANSFMAT, arrayColorSpaceXYZTransform);
initializeSliders(sliderColorSpaceXYZLocusWavelength, 0, 125, 1, 18);
sliderColorSpaceXYZLocusWavelength.addEventListener("input", updateColorSpaceXYZLocus);
function updateColorSpaceXYZLocus() {
    canvasColorSpaceXYZLocus.clearRect(0, 0, WIDTH, 600);
    canvasColorSpaceXYZLocusCMF.clearRect(0, 0, WIDTH, 330);
    drawCMF(canvasColorSpaceXYZLocusCMF, sliderColorSpaceXYZLocusWavelength.value, arrayCOLMATXYZ);
    drawLabels(canvasColorSpaceXYZLocusCMF, XYZPM, [[920, 131], [500, 131], [130, 131]]);
    getCMFValues(sliderColorSpaceXYZLocusWavelength.value, arrayColorSpaceXYZLocusRSP, arrayCOLMATXYZ);
    drawSpaceAxes(canvasColorSpaceXYZLocus);
    drawSpaceCube(canvasColorSpaceXYZLocus);
    drawSpaceCube(canvasColorSpaceXYZLocus, arrayColorSpaceXYZTransform, CUBEPOINTS, true);
    drawSpaceLabels(canvasColorSpaceXYZLocus, RGBPM, arrayColorSpaceXYZTransform, CUBELABELOFF, CUBELABELPOS, "#aaa");
    drawSpaceLocus(canvasColorSpaceXYZLocus, arrayCOLMATXYZ);
    drawSpacePointLines(canvasColorSpaceXYZLocus, arrayColorSpaceXYZLocusRSP)
    drawSpacePoint(canvasColorSpaceXYZLocus, arrayColorSpaceXYZLocusRSP);
    drawSpaceLabels(canvasColorSpaceXYZLocus, XYZPM);
}
updateColorSpaceXYZLocus();


const canvasColorSpaceXYZ = initializeCanvas("canvasColorSpaceXYZ", 600);
const sliderColorSpaceXYZX = document.getElementById("sliderColorSpaceXYZX");
const sliderColorSpaceXYZY = document.getElementById("sliderColorSpaceXYZY");
const sliderColorSpaceXYZZ = document.getElementById("sliderColorSpaceXYZZ");
const linkColorSpaceXYZCyan = document.getElementById("linkColorSpaceXYZCyan");
let arrayColorSpaceXYZRSP = [0, 0, 0];
initializeSliders(sliderColorSpaceXYZX, 0, 1, 0.025, 0.4);
initializeSliders(sliderColorSpaceXYZY, 0, 1, 0.025, 0.5);
initializeSliders(sliderColorSpaceXYZZ, 0, 1, 0.025, 0.5);
sliderColorSpaceXYZX.addEventListener("input", updateColorSpaceXYZ);
sliderColorSpaceXYZY.addEventListener("input", updateColorSpaceXYZ);
sliderColorSpaceXYZZ.addEventListener("input", updateColorSpaceXYZ);
linkColorSpaceXYZCyan.addEventListener("click", () => {
    sliderColorSpaceXYZX.value = 0.001;
    sliderColorSpaceXYZY.value = 0.206;
    sliderColorSpaceXYZZ.value = 0.130;
    updateColorSpaceXYZ();
});
function updateColorSpaceXYZ() {
    canvasColorSpaceXYZ.clearRect(0, 0, WIDTH, 600);
    arrayColorSpaceXYZRSP = [sliderColorSpaceXYZX.value, sliderColorSpaceXYZY.value, sliderColorSpaceXYZZ.value];
    drawSpaceAxes(canvasColorSpaceXYZ);
    drawSpacePlane(canvasColorSpaceXYZ, arrayColorSpaceXYZRSP, RGBtoXYZClip);
    drawSpaceCube(canvasColorSpaceXYZ, arrayColorSpaceXYZTransform, CUBEPOINTS, true);
    drawSpaceCube(canvasColorSpaceXYZ);
    drawSpaceLocus(canvasColorSpaceXYZ, arrayCOLMATXYZ);
    drawSpaceLabels(canvasColorSpaceXYZ, XYZPM);
    drawSpacePoint(canvasColorSpaceXYZ, arrayColorSpaceXYZRSP);
}
updateColorSpaceXYZ();


const canvasColorSpaceRGBChroma = initializeCanvas("canvasColorSpaceRGBChroma", 600);
const divColorSpaceRGBChroma = document.getElementById("divColorSpaceRGBChroma");
const sliderColorSpaceRGBChroma = [];
const progressColorSpaceRGBChroma = [];
let arrayColorSpaceRGBChromaRSP = [0, 0, 0];
for (let i = 0; i < 3; i++) {
    sliderColorSpaceRGBChroma[i] = document.getElementById(`sliderColorSpaceRGBChroma${i}`);
    progressColorSpaceRGBChroma[i] = document.getElementById(`progressColorSpaceRGBChroma${i}`);
    initializeSliders(sliderColorSpaceRGBChroma[i], 0.01, 0.98, 0.01, 0.33);
    initializeProgressBar(progressColorSpaceRGBChroma[i], 0.98, 0.33);
    sliderColorSpaceRGBChroma[i].addEventListener("input", () => { normalizeSliders(sliderColorSpaceRGBChroma, i); updateColorSpaceRGBChroma();});
}
function updateColorSpaceRGBChroma() {
    canvasColorSpaceRGBChroma.clearRect(0, 0, WIDTH, 600);
    arrayColorSpaceRGBChromaRSP = [sliderColorSpaceRGBChroma[0].value, sliderColorSpaceRGBChroma[1].value, sliderColorSpaceRGBChroma[2].value];
    arrayColorSpaceRGBChromaRSP.forEach((val, i) => progressColorSpaceRGBChroma[i].value = val);
    drawSpaceAxes(canvasColorSpaceRGBChroma);
    drawSpaceSlice(canvasColorSpaceRGBChroma);
    drawSpaceCube(canvasColorSpaceRGBChroma);
    drawSpacePoint(canvasColorSpaceRGBChroma, arrayColorSpaceRGBChromaRSP);
    drawSpaceLabels(canvasColorSpaceRGBChroma);
    colorBoxRGB(divColorSpaceRGBChroma, arrayColorSpaceRGBChromaRSP);
}
updateColorSpaceRGBChroma();


const canvasColorSpaceRGBChromaProject = initializeCanvas("canvasColorSpaceRGBChromaProject", 600);
const divColorSpaceRGBChromaProject = document.getElementById("divColorSpaceRGBChromaProject");
const linkColorSpaceRGBChromaProjectPan = document.getElementById("linkColorSpaceRGBChromaProjectPan");
const arrayColorSpaceRGBChromaProjectGreens = [[0.15, 0.45, 0.15], [0.2, 0.6, 0.2], [0.3, 0.9, 0.3]];
const arrayColorSpaceRGBChromaProjectNorms = [0, 0, 0];
const arrayColorSpaceRGBChromaProjectTransMat =  TRANSFMAT.map(row => row.slice());
const sliderColorSpaceRGBChromaProject = [];
const progressColorSpaceRGBChromaProject = [];
const linkColorSpaceRGBChromaProjectGreens = [];
let arrayColorSpaceRGBChromaProjectRSP = [0, 0, 0];
let varColorSpaceRGBChromaProjectSum = 0;
for (let i = 0; i < 3; i++) {
    linkColorSpaceRGBChromaProjectGreens[i] = document.getElementById(`linkColorSpaceRGBChromaProjectGreen${i}`);
    sliderColorSpaceRGBChromaProject[i] = document.getElementById(`sliderColorSpaceRGBChromaProject${i}`);
    progressColorSpaceRGBChromaProject[i] = document.getElementById(`progressColorSpaceRGBChromaProject${i}`);
    initializeSliders(sliderColorSpaceRGBChromaProject[i], 0.01, 0.98, 0.01, 0.33);
    initializeProgressBar(progressColorSpaceRGBChromaProject[i], 0.98, 0.33);
    sliderColorSpaceRGBChromaProject[i].addEventListener("input", updateColorSpaceRGBChromaProject);
    linkColorSpaceRGBChromaProjectGreens[i].addEventListener("click", () => {
        sliderColorSpaceRGBChromaProject.forEach((slider, index) => slider.value = arrayColorSpaceRGBChromaProjectGreens[i][index]);
        updateColorSpaceRGBChromaProject(); });
}
sliderColorSpaceRGBChromaProjectPan = document.getElementById("sliderColorSpaceRGBChromaProjectPan");
initializeSliders(sliderColorSpaceRGBChromaProjectPan, -120, 180, 1, -120);
linkColorSpaceRGBChromaProjectPan.addEventListener("click", () => {
    sliderColorSpaceRGBChromaProjectPan.value = 180;
    changeTransformation(arrayColorSpaceRGBChromaProjectTransMat, sliderColorSpaceRGBChromaProjectPan.value, sliderColorSpaceRGBChromaProjectPan.min);
    updateColorSpaceRGBChromaProject(); });
sliderColorSpaceRGBChromaProjectPan.addEventListener("input", () => {
    changeTransformation(arrayColorSpaceRGBChromaProjectTransMat, sliderColorSpaceRGBChromaProjectPan.value, sliderColorSpaceRGBChromaProjectPan.min);
    updateColorSpaceRGBChromaProject(); });
function updateColorSpaceRGBChromaProject() {
    canvasColorSpaceRGBChromaProject.clearRect(0, 0, WIDTH, 600);
    varColorSpaceRGBChromaProjectSum = 0;
    arrayColorSpaceRGBChromaProjectRSP = [sliderColorSpaceRGBChromaProject[0].value, sliderColorSpaceRGBChromaProject[1].value, sliderColorSpaceRGBChromaProject[2].value];
    arrayColorSpaceRGBChromaProjectRSP.forEach((val, i) => varColorSpaceRGBChromaProjectSum += Number(val));
    arrayColorSpaceRGBChromaProjectRSP.forEach((val, i) => {
        arrayColorSpaceRGBChromaProjectNorms[i] = val / varColorSpaceRGBChromaProjectSum;
        progressColorSpaceRGBChromaProject[i].value = arrayColorSpaceRGBChromaProjectNorms[i];
    });
    drawSpaceAxes(canvasColorSpaceRGBChromaProject, arrayColorSpaceRGBChromaProjectTransMat);
    drawSpaceSlice(canvasColorSpaceRGBChromaProject, varColorSpaceRGBChromaProjectSum, arrayColorSpaceRGBChromaProjectTransMat);
    drawSpaceTriangle(canvasColorSpaceRGBChromaProject, 1, arrayColorSpaceRGBChromaProjectTransMat);
    drawSpaceTriangle(canvasColorSpaceRGBChromaProject, varColorSpaceRGBChromaProjectSum, arrayColorSpaceRGBChromaProjectTransMat, "#aaa");
    drawSpaceCube(canvasColorSpaceRGBChromaProject, arrayColorSpaceRGBChromaProjectTransMat);
    drawSpaceLine(canvasColorSpaceRGBChromaProject, arrayColorSpaceRGBChromaProjectNorms, arrayColorSpaceRGBChromaProjectRSP, arrayColorSpaceRGBChromaProjectTransMat);
    drawSpaceLine(canvasColorSpaceRGBChromaProject, arrayColorSpaceRGBChromaProjectNorms, [0, 0, 0], arrayColorSpaceRGBChromaProjectTransMat);
    drawSpacePoint(canvasColorSpaceRGBChromaProject, arrayColorSpaceRGBChromaProjectRSP, arrayColorSpaceRGBChromaProjectTransMat, "#aaa");
    drawSpacePoint(canvasColorSpaceRGBChromaProject, arrayColorSpaceRGBChromaProjectNorms, arrayColorSpaceRGBChromaProjectTransMat);
    drawSpaceLabels(canvasColorSpaceRGBChromaProject, RGBPM, arrayColorSpaceRGBChromaProjectTransMat);
    colorBoxRGB(divColorSpaceRGBChromaProject, arrayColorSpaceRGBChromaProjectRSP);
}
changeTransformation(arrayColorSpaceRGBChromaProjectTransMat, sliderColorSpaceRGBChromaProjectPan.value, sliderColorSpaceRGBChromaProjectPan.min);
updateColorSpaceRGBChromaProject();

const canvasChromaSpaceRG = initializeCanvas("canvasChromaSpaceRG", 600);
const sliderChromaSpaceRGPan = document.getElementById("sliderChromaSpaceRGPan");
const linkChromaSpaceRGPan = document.getElementById("linkChromaSpaceRGPan");
const arrayChromaSpaceRGBasisMat = [[410, 0, -120, BASEXOFF], [0, -400, 80, BASEYOFF]];
const arrayChromaSpaceRGTransMat = arrayChromaSpaceRGBasisMat.map(row => row.slice());
initializeSliders(sliderChromaSpaceRGPan, -120, 0, 0.5, -120);
sliderChromaSpaceRGPan.addEventListener("input", () => {
    changeTransformation(arrayChromaSpaceRGTransMat, sliderChromaSpaceRGPan.value, sliderChromaSpaceRGPan.min, 1, -0.66, -0.1, arrayChromaSpaceRGBasisMat);
    updateChromaSpaceRG(); });
linkChromaSpaceRGPan.addEventListener("click", () => {
    sliderChromaSpaceRGPan.value = 0;
    changeTransformation(arrayChromaSpaceRGTransMat, sliderChromaSpaceRGPan.value, sliderChromaSpaceRGPan.min, 1, -0.66, -0.1, arrayChromaSpaceRGBasisMat);
    updateChromaSpaceRG(); });
function updateChromaSpaceRG() {
    canvasChromaSpaceRG.clearRect(0, 0, WIDTH, 600);
    drawSpaceAxes(canvasChromaSpaceRG, arrayChromaSpaceRGTransMat);
    drawSpaceSlice(canvasChromaSpaceRG, 1, arrayChromaSpaceRGTransMat);
    drawSpaceCube(canvasChromaSpaceRG, arrayChromaSpaceRGTransMat);
    drawSpaceLabels(canvasChromaSpaceRG, RGBPM, arrayChromaSpaceRGTransMat);
}
updateChromaSpaceRG();

const canvasChromaRGBLocus = initializeCanvas("canvasChromaRGBLocus", 600);
const sliderChromaRGBLocusWavelength = document.getElementById("sliderChromaRGBLocusWavelength");
const sliderChromaRGBLocusPan = document.getElementById("sliderChromaRGBLocusPan");
const linkChromaRGBLocusPan = document.getElementById("linkChromaRGBLocusPan");
const switchChromaRGBLocusSlice = document.getElementById("switchChromaRGBLocusSlice");
const arrayChromaRGBLocusBasisMat = [[205, 0, -60, BASEXOFF + 350], [0, -200, 40, BASEYOFF + 20]];
const arrayChromaRGBLocusRSP = [0, 0, 0];
const arrayChromaRGBLocusNorms = [0, 0, 0];
const arrayChromaRGBLocusTransMat = arrayChromaRGBLocusBasisMat.map(row => row.slice());
let varChromaRGBLocusSum = 0;
initializeSliders(sliderChromaRGBLocusWavelength, 0, 125, 1, 10);
initializeSliders(sliderChromaRGBLocusPan, -120, 0, 0.5, -120);
sliderChromaRGBLocusWavelength.addEventListener("input", updateChromaRGBLocus);
sliderChromaRGBLocusPan.addEventListener("input", () => {
    changeTransformation(arrayChromaRGBLocusTransMat, sliderChromaRGBLocusPan.value, sliderChromaRGBLocusPan.min, 0.5, -0.33, -0.05, arrayChromaRGBLocusBasisMat);
    updateChromaRGBLocus(); });
linkChromaRGBLocusPan.addEventListener("click", () => {
    sliderChromaRGBLocusPan.value = 0;
    changeTransformation(arrayChromaRGBLocusTransMat, sliderChromaRGBLocusPan.value, sliderChromaRGBLocusPan.min, 0.5, -0.33, -0.05, arrayChromaRGBLocusBasisMat);
    updateChromaRGBLocus(); });
switchChromaRGBLocusSlice.addEventListener("click", () => {
    updateChromaRGBLocus(); });
function updateChromaRGBLocus() {
    canvasChromaRGBLocus.clearRect(0, 0, WIDTH, 600);
    varChromaRGBLocusSum = 0;
    getCMFValues(sliderChromaRGBLocusWavelength.value, arrayChromaRGBLocusRSP);
    arrayChromaRGBLocusRSP.forEach((val, i) => varChromaRGBLocusSum += Number(val));
    getCMFValues(sliderChromaRGBLocusWavelength.value, arrayChromaRGBLocusNorms, arrayCHRMATRGB);
    if (switchChromaRGBLocusSlice.checked) drawSpaceSlice(canvasChromaRGBLocus, 1, arrayChromaRGBLocusTransMat, 2.1);
    drawSpaceAxes(canvasChromaRGBLocus, arrayChromaRGBLocusTransMat);
    drawSpaceLocus(canvasChromaRGBLocus, arrayCOLMATRGB, arrayChromaRGBLocusTransMat, "#aaa");
    drawSpaceTriangle(canvasChromaRGBLocus, 1, arrayChromaRGBLocusTransMat);
    drawSpaceCube(canvasChromaRGBLocus, arrayChromaRGBLocusTransMat);
    drawSpaceLocus(canvasChromaRGBLocus, arrayCHRMATRGB, arrayChromaRGBLocusTransMat);
    drawSpaceLine(canvasChromaRGBLocus, arrayChromaRGBLocusNorms, arrayChromaRGBLocusRSP, arrayChromaRGBLocusTransMat);
    drawSpaceLine(canvasChromaRGBLocus, arrayChromaRGBLocusNorms, [0, 0, 0], arrayChromaRGBLocusTransMat);
    drawSpacePoint(canvasChromaRGBLocus, arrayChromaRGBLocusNorms, arrayChromaRGBLocusTransMat);
    drawSpacePoint(canvasChromaRGBLocus, arrayChromaRGBLocusRSP, arrayChromaRGBLocusTransMat, "#aaa");
    drawSpaceLabels(canvasChromaRGBLocus, RGBPM, arrayChromaRGBLocusTransMat);
}
updateChromaRGBLocus();


const canvasChromaRGUndefined = initializeCanvas("canvasChromaRGUndefined", 600);
const PROJRGBBASEMAT = [[205, 0, -60, BASEXOFF + 350], [0, -200, 40, BASEYOFF + 20]];
const PROJRGBMAT = PROJRGBBASEMAT.map(row => row.slice());
changeTransformation(PROJRGBMAT, 0, -120, 0.5, -0.33, -0.05, PROJRGBBASEMAT);
function updateChromaRGUndefined() {
    canvasChromaRGUndefined.clearRect(0, 0, WIDTH, 600);
    for (let i = 0; i < 75; i++) drawSpaceLine(canvasChromaRGUndefined, [-600 + i * 25, 600], [0 + i * 25, 0], IDENTITY, "#aaa");
    drawSpaceTriangle(canvasChromaRGUndefined, 1, PROJRGBMAT, "#000", 0, "#fff");
    drawSpaceSlice(canvasChromaRGUndefined, 1, PROJRGBMAT, 2.1);
    drawSpaceAxes(canvasChromaRGUndefined, PROJRGBMAT);
    drawSpaceLocus(canvasChromaRGUndefined, arrayCHRMATRGB, PROJRGBMAT);
    drawSpaceLabels(canvasChromaRGUndefined, RGBPM, PROJRGBMAT);
    drawLabels(canvasChromaRGUndefined, ["Undefined chromaticity"], [[285, 250]]);
    drawLabels(canvasChromaRGUndefined, ["(Except for the CIE RGB"], [[285, 290]]);
    drawLabels(canvasChromaRGUndefined, ["and spectral colours)"], [[285, 330]]);
}
updateChromaRGUndefined();


const canvasChromaRGDefined = initializeCanvas("canvasChromaRGDefined", 600);
function updateChromaRGDefined() {
    canvasChromaRGDefined.clearRect(0, 0, WIDTH, 600);
    drawSpaceChromaFill(canvasChromaRGDefined, arrayCHRMATRGB, PROJRGBMAT, "#cff");
    drawSpaceTriangle(canvasChromaRGDefined, 1, PROJRGBMAT, "#000", 0, "#fff");
    drawSpaceSlice(canvasChromaRGDefined, 1, PROJRGBMAT, 2.1);
    drawSpaceAxes(canvasChromaRGDefined, PROJRGBMAT);
    drawSpaceLocus(canvasChromaRGDefined, arrayCHRMATRGB, PROJRGBMAT);
    drawSpaceLabels(canvasChromaRGDefined, RGBPM, PROJRGBMAT);
}
updateChromaRGDefined();


const canvasChromaRGLinear = initializeCanvas("canvasChromaRGLinear", 600);
const spanChromaRGLinearChromaValues = document.getElementById("spanChromaRGLinearChromaValues");
const spanChromaRGLinearChromaResult = document.getElementById("spanChromaRGLinearChromaResult");
const arrayChromaRGLinearWavelengthVals = [35, 52];
const arrayChromaRGLinearIntensities = [0.5, 0.5];
const arrayChromaRGLinearCtrlPoints = [[0, 0, 0], [0, 0, 0]];
const arrayChromaRGLinearCtrlColors = [[0, 0, 0], [0, 0, 0]];
const arrayChromaRGLinearPoint = [0, 0, 0];
const arrayChromaRGLinearColor = [0, 0, 0];
const sliderChromaRGLinearWavelength = [];
const sliderChromaRGLinearIntensity = [];
const spanChromaRGLinearWavelengthR = [];
const spanChromaRGLinearWavelengthG = [];
const spanChromaRGLinearWavelength = [];
const spanChromaRGLinearIntensity = [];
for (let i = 0; i < 2; i++) {
    spanChromaRGLinearWavelengthR[i] = document.getElementById(`spanChromaRGLinearWavelength${i}R`);
    spanChromaRGLinearWavelengthG[i] = document.getElementById(`spanChromaRGLinearWavelength${i}G`);
    spanChromaRGLinearWavelength[i] = document.getElementById(`spanChromaRGLinearWavelength${i}`);
    spanChromaRGLinearIntensity[i] = document.getElementById(`spanChromaRGLinearIntensity${i}`);
    sliderChromaRGLinearWavelength[i] = document.getElementById(`sliderChromaRGLinearWavelength${i}`);
    sliderChromaRGLinearIntensity[i] = document.getElementById(`sliderChromaRGLinearIntensity${i}`);
    initializeSliders(sliderChromaRGLinearWavelength[i], 0, 125, 1, arrayChromaRGLinearWavelengthVals[i]);
    initializeSliders(sliderChromaRGLinearIntensity[i], 0.01, 0.99, 0.01, arrayChromaRGLinearIntensities[i]);
    sliderChromaRGLinearWavelength[i].addEventListener("input", updateChromaRGLinear);
    sliderChromaRGLinearIntensity[i].addEventListener("input", () => { normalizeSliders(sliderChromaRGLinearIntensity, i, 1); updateChromaRGLinear(); });
}
function updateChromaRGLinear() {
    for (let i = 0; i < 2; i++) {
        getCMFValues(sliderChromaRGLinearWavelength[i].value, arrayChromaRGLinearCtrlPoints[i], arrayCHRMATRGB);
        getCMFValues(sliderChromaRGLinearWavelength[i].value, arrayChromaRGLinearCtrlColors[i], arrayCOLMATSRGB);
        arrayChromaRGLinearIntensities[i] = Number(sliderChromaRGLinearIntensity[i].value);
        spanChromaRGLinearWavelengthR[i].innerHTML = arrayChromaRGLinearCtrlPoints[i][0].toFixed(3);
        spanChromaRGLinearWavelengthG[i].innerHTML = arrayChromaRGLinearCtrlPoints[i][1].toFixed(3);
        spanChromaRGLinearIntensity[i].innerHTML = (sliderChromaRGLinearIntensity[i].value * 1).toFixed(2);
        spanChromaRGLinearWavelength[i].innerHTML = (sliderChromaRGLinearWavelength[i].value * 2.8 + 380).toFixed(0);
    }
    spanChromaRGLinearChromaValues.innerHTML = (sliderChromaRGLinearIntensity[0].value * 1).toFixed(2) + " × (" + arrayChromaRGLinearCtrlPoints[0][0].toFixed(2) + "r + " + arrayChromaRGLinearCtrlPoints[0][1].toFixed(2) + "g) + " + (sliderChromaRGLinearIntensity[1].value * 1).toFixed(2) + " × (" + arrayChromaRGLinearCtrlPoints[1][0].toFixed(2) + "r + " + arrayChromaRGLinearCtrlPoints[1][1].toFixed(2) + "g)";
    spanChromaRGLinearChromaResult.innerHTML = (sliderChromaRGLinearIntensity[0].value * arrayChromaRGLinearCtrlPoints[0][0] + sliderChromaRGLinearIntensity[1].value * arrayChromaRGLinearCtrlPoints[1][0]).toFixed(2) + "r + " + (sliderChromaRGLinearIntensity[0].value * arrayChromaRGLinearCtrlPoints[0][1] + sliderChromaRGLinearIntensity[1].value * arrayChromaRGLinearCtrlPoints[1][1]).toFixed(2) + "g";
    canvasChromaRGLinear.clearRect(0, 0, WIDTH, 600);
    drawSpaceSlice(canvasChromaRGLinear, 1, PROJRGBMAT, 2.1);
    drawSpaceAxes(canvasChromaRGLinear, PROJRGBMAT);
    drawSpaceLabels(canvasChromaRGLinear, RGBPM, PROJRGBMAT);
    drawSpaceLocus(canvasChromaRGLinear, arrayCHRMATRGB, PROJRGBMAT);
    drawSpaceLine(canvasChromaRGLinear, arrayChromaRGLinearCtrlPoints[0], arrayChromaRGLinearCtrlPoints[1], PROJRGBMAT);
    drawSpacePoint(canvasChromaRGLinear, arrayChromaRGLinearCtrlPoints[0], PROJRGBMAT, "#000", 6);
    drawSpacePoint(canvasChromaRGLinear, arrayChromaRGLinearCtrlPoints[1], PROJRGBMAT, "#000", 6);
    getChromaticity(arrayChromaRGLinearCtrlPoints, arrayChromaRGLinearIntensities, arrayChromaRGLinearPoint, arrayChromaRGLinearColor);
    drawSpacePoint(canvasChromaRGLinear, arrayChromaRGLinearPoint, PROJRGBMAT);
    colorBoxRGB(divChromaRGLinear, arrayChromaRGLinearColor);
}
updateChromaRGLinear();


const canvasChromaXYZLocus = initializeCanvas("canvasChromaXYZLocus", 600);
const sliderChromaXYZLocusWavelength = document.getElementById("sliderChromaXYZLocusWavelength");
const sliderChromaXYZLocusPan = document.getElementById("sliderChromaXYZLocusPan");
const arrayChromaXYZLocusBasisMat = [[410, 0, -120, BASEXOFF], [0, -400, 80, BASEYOFF]];
const arrayChromaXYZLocusRSP = [0, 0, 0];
const arrayChromaXYZLocusNorms = [0, 0, 0];
const arrayChromaXYZLocusTransMat = arrayChromaXYZLocusBasisMat.map(row => row.slice());
let varChromaXYZLocusSum = 0;
initializeSliders(sliderChromaXYZLocusWavelength, 0, 125, 1, 10);
initializeSliders(sliderChromaXYZLocusPan, -120, 0, 0.5, -120);
sliderChromaXYZLocusWavelength.addEventListener("input", updateChromaXYZLocus);
sliderChromaXYZLocusPan.addEventListener("input", () => {
    changeTransformation(arrayChromaXYZLocusTransMat, sliderChromaXYZLocusPan.value, sliderChromaXYZLocusPan.min, 1, -0.66, -0.1, arrayChromaXYZLocusBasisMat);
    updateChromaXYZLocus(); });
function updateChromaXYZLocus() {
    canvasChromaXYZLocus.clearRect(0, 0, WIDTH, 600);
    varChromaXYZLocusSum = 0;
    getCMFValues(sliderChromaXYZLocusWavelength.value, arrayChromaXYZLocusRSP, arrayCOLMATXYZ);
    arrayChromaXYZLocusRSP.forEach((val, i) => varChromaXYZLocusSum += Number(val));
    getCMFValues(sliderChromaXYZLocusWavelength.value, arrayChromaXYZLocusNorms, arrayCHRMATXYZ);
    drawSpaceAxes(canvasChromaXYZLocus, arrayChromaXYZLocusTransMat);
    drawSpaceLocus(canvasChromaXYZLocus, arrayCOLMATXYZ, arrayChromaXYZLocusTransMat, "#aaa");
    drawSpaceTriangle(canvasChromaXYZLocus, 1, arrayChromaXYZLocusTransMat);
    drawSpaceCube(canvasChromaXYZLocus, arrayChromaXYZLocusTransMat);
    drawSpaceLocus(canvasChromaXYZLocus, arrayCHRMATXYZ, arrayChromaXYZLocusTransMat);
    drawSpaceLine(canvasChromaXYZLocus, arrayChromaXYZLocusNorms, arrayChromaXYZLocusRSP, arrayChromaXYZLocusTransMat);
    drawSpaceLine(canvasChromaXYZLocus, arrayChromaXYZLocusNorms, [0, 0, 0], arrayChromaXYZLocusTransMat);
    drawSpacePoint(canvasChromaXYZLocus, arrayChromaXYZLocusNorms, arrayChromaXYZLocusTransMat);
    drawSpacePoint(canvasChromaXYZLocus, arrayChromaXYZLocusRSP, arrayChromaXYZLocusTransMat, "#aaa");
    drawSpaceLabels(canvasChromaXYZLocus, XYZPM, arrayChromaXYZLocusTransMat);
}
updateChromaXYZLocus();


const canvasLocusRatio = initializeCanvas("canvasLocusRatio", 600);
const spanLocusRatiox = document.getElementById("spanLocusRatiox");
const spanLocusRatioy = document.getElementById("spanLocusRatioy");
const arrayLocusRatioWavelengthVals = [40, 82];
const arrayLocusRatioIntensities = [1.56, 1.44];
const arrayLocusRatioCtrlPoints = [[0, 0, 0], [0, 0, 0]];
const arrayLocusRatioPoint = [0, 0, 0];
const arrayLocusRatioColor = [0, 0, 0];
const sliderLocusRatioWavelength = [];
const sliderLocusRatioIntensity = [];
for (let i = 0; i < 2; i++) {
    sliderLocusRatioWavelength[i] = document.getElementById(`sliderLocusRatioWavelength${i}`);
    sliderLocusRatioIntensity[i] = document.getElementById(`sliderLocusRatioIntensity${i}`);
    initializeSliders(sliderLocusRatioWavelength[i], 0, 125, 1, arrayLocusRatioWavelengthVals[i]);
    initializeSliders(sliderLocusRatioIntensity[i], 0.01, 2.99, 0.01, arrayLocusRatioIntensities[i]);
    sliderLocusRatioWavelength[i].addEventListener("input", updateLocusRatio);
    sliderLocusRatioIntensity[i].addEventListener("input", () => { normalizeSliders(sliderLocusRatioIntensity, i, 3); updateLocusRatio(); });
}
function updateLocusRatio() {
    for (let i = 0; i < 2; i++) {
        getCMFValues(sliderLocusRatioWavelength[i].value, arrayLocusRatioCtrlPoints[i], arrayCHRMATXYZ);
        arrayLocusRatioIntensities[i] = Number(sliderLocusRatioIntensity[i].value);
    }
    canvasLocusRatio.clearRect(0, 0, WIDTH, 600);
    drawSpaceChroma(canvasLocusRatio);
    drawSpaceAxes(canvasLocusRatio, PROJMAT);
    drawLabels(canvasLocusRatio, ["x", "y"], [[PROJMAT[0][3] - 30, 31], [PROJMAT[0][0] + 30, PROJMAT[1][3] - 30]]);
    drawSpaceLocus(canvasLocusRatio, arrayCHRMATXYZ, PROJMAT);
    drawSpaceLine(canvasLocusRatio, arrayLocusRatioCtrlPoints[0], arrayLocusRatioCtrlPoints[1], PROJMAT);
    drawSpacePoint(canvasLocusRatio, arrayLocusRatioCtrlPoints[0], PROJMAT, "#000", 6);
    drawSpacePoint(canvasLocusRatio, arrayLocusRatioCtrlPoints[1], PROJMAT, "#000", 6);
    getChromaticity(arrayLocusRatioCtrlPoints, arrayLocusRatioIntensities, arrayLocusRatioPoint, arrayLocusRatioColor);
    drawSpacePoint(canvasLocusRatio, arrayLocusRatioPoint, PROJMAT);
    colorBoxRGB(divLocusRatio, vectorMultiply(MATRIX_XYZ_RGB, arrayLocusRatioColor));
    spanLocusRatiox.innerHTML = "x: " + arrayLocusRatioPoint[0].toFixed(3);
    spanLocusRatioy.innerHTML = "y: " + arrayLocusRatioPoint[1].toFixed(3);
}


const canvasLocusGamutTwo = initializeCanvas("canvasLocusGamutTwo", 600);
const arrayLocusGamutTwoWavelengthVals = [20, 59];
const arrayLocusGamutTwoIntensities = [1, 2];
const arrayLocusGamutTwoCtrlPoints = XYCIERGB.slice(1);
const arrayLocusGamutTwoPoint = [0, 0, 0];
const arrayLocusGamutTwoColor = [0, 0, 0];
const sliderLocusGamutTwoIntensity = [];
for (let i = 0; i < 2; i++) {
    sliderLocusGamutTwoIntensity[i] = document.getElementById(`sliderLocusGamutTwoIntensity${i}`);
    initializeSliders(sliderLocusGamutTwoIntensity[i], 0.01, 2.99, 0.01, arrayLocusGamutTwoIntensities[i]);
    sliderLocusGamutTwoIntensity[i].addEventListener("input", () => { normalizeSliders(sliderLocusGamutTwoIntensity, i, 3); updateLocusGamutTwo(); });
}
function updateLocusGamutTwo() {
    for (let i = 0; i < 2; i++) arrayLocusGamutTwoIntensities[i] = Number(sliderLocusGamutTwoIntensity[i].value);
    canvasLocusGamutTwo.clearRect(0, 0, WIDTH, 600);
    drawSpaceChroma(canvasLocusGamutTwo);
    drawSpaceLocus(canvasLocusGamutTwo, arrayCHRMATXYZ, PROJMAT);
    drawSpaceLine(canvasLocusGamutTwo, arrayLocusGamutTwoCtrlPoints[0], arrayLocusGamutTwoCtrlPoints[1], PROJMAT);
    drawSpacePoint(canvasLocusGamutTwo, arrayLocusGamutTwoCtrlPoints[0], PROJMAT, "#000", 6);
    drawSpacePoint(canvasLocusGamutTwo, arrayLocusGamutTwoCtrlPoints[1], PROJMAT, "#000", 6);
    drawLabels(canvasLocusGamutTwo, WAVXYZLABELS, WAVXYZLABELPOS);
    getChromaticity(arrayLocusGamutTwoCtrlPoints, arrayLocusGamutTwoIntensities, arrayLocusGamutTwoPoint, arrayLocusGamutTwoColor);
    drawSpacePoint(canvasLocusGamutTwo, arrayLocusGamutTwoPoint, PROJMAT);
    colorBoxRGB(divLocusGamutTwo, vectorMultiply(MATRIX_XYZ_RGB, arrayLocusGamutTwoColor));
}


const canvasLocusGamutCIE = initializeCanvas("canvasLocusGamutCIE", 600);
const spanLocusGamutCIEChromaticity = document.getElementById("spanLocusGamutCIEChromaticity");
const arrayLocusGamutCIECtrlPoints = XYCIERGB;
const arrayLocusGamutCIEWhitePoint = [1, 1, 1];
const arrayLocusGamutCIEIntensities = [0, 0];
const arrayLocusGamutCIEPoint = [0, 0, 0];
const arrayLocusGamutCIEColor = [0, 0, 0];
const sliderLocusGamutCIEIntensity = [];
const spanLocusGamutCIEIntensity = [];
for (let i = 0; i < 3; i++) {
    sliderLocusGamutCIEIntensity[i] = document.getElementById(`sliderLocusGamutCIEIntensity${i}`);
    spanLocusGamutCIEIntensity[i] = document.getElementById(`spanLocusGamutCIEIntensity${i}`);
    initializeSliders(sliderLocusGamutCIEIntensity[i], 0.01, 2.99, 0.01, 1);
    sliderLocusGamutCIEIntensity[i].addEventListener("input", () => { normalizeSliders(sliderLocusGamutCIEIntensity, i, 3); updateLocusGamutCIE(); });
}
function updateLocusGamutCIE() {
    for (let i = 0; i < 3; i++) {
        arrayLocusGamutCIEIntensities[i] = sliderLocusGamutCIEIntensity[i].value * arrayLocusGamutCIEWhitePoint[i];
        spanLocusGamutCIEIntensity[i].innerHTML = (sliderLocusGamutCIEIntensity[i].value / 3).toFixed(2);
    }
    canvasLocusGamutCIE.clearRect(0, 0, WIDTH, 600);
    drawSpaceChroma(canvasLocusGamutCIE);
    drawSpaceLocus(canvasLocusGamutCIE, arrayCHRMATXYZ, PROJMAT);
    drawGamut(canvasLocusGamutCIE, arrayLocusGamutCIECtrlPoints, arrayLocusGamutCIEIntensities);
    getChromaticity(arrayLocusGamutCIECtrlPoints, arrayLocusGamutCIEIntensities, arrayLocusGamutCIEPoint, arrayLocusGamutCIEColor);
    drawSpacePoint(canvasLocusGamutCIE, arrayLocusGamutCIEPoint, PROJMAT);
    drawLabels(canvasLocusGamutCIE, WAVXYZLABELS, WAVXYZLABELPOS);
    colorBoxRGB(divLocusGamutCIE, vectorMultiply(MATRIX_XYZ_RGB, arrayLocusGamutCIEColor));
    spanLocusGamutCIEChromaticity.innerHTML = ((sliderLocusGamutCIEIntensity[0].value * 0.733 + sliderLocusGamutCIEIntensity[1].value * 0.266 + sliderLocusGamutCIEIntensity[2].value * 0.166) / 3).toFixed(2) + "r + " + ((sliderLocusGamutCIEIntensity[0].value * 0.267 + sliderLocusGamutCIEIntensity[1].value * 0.724 + sliderLocusGamutCIEIntensity[2].value * 0.008) / 3).toFixed(2) + "g";
}


const canvasLocusGamutMultiple = initializeCanvas("canvasLocusGamutMultiple", 600);
const selectLocusGamutMultipleSpace = document.getElementById("selectLocusGamutMultipleSpace");
let varLocusGamutMultipleCurrentName = [COLSPACENAMES[0]];
let arrayLocusGamutMultipleCtrlPoints = COLSPACES[0];
const arrayLocusGamutMultipleWhitePoint = [0.638, 1.175, 1.186];
const arrayLocusGamutMultipleIntensities = [0, 0, 0];
const arrayLocusGamutMultiplePoint = [0, 0, 0];
const arrayLocusGamutMultipleColor = [0, 0, 0];
const sliderLocusGamutMultipleIntensity = [];
const linkLocusGamutMultiple = [];
for (let i = 0; i < 3; i++) {
    sliderLocusGamutMultipleIntensity[i] = document.getElementById(`sliderLocusGamutMultipleIntensity${i}`);
    initializeSliders(sliderLocusGamutMultipleIntensity[i], 0.01, 2.99, 0.01, 1);
    sliderLocusGamutMultipleIntensity[i].addEventListener("input", () => {
        normalizeSliders(sliderLocusGamutMultipleIntensity, i, 3); updateLocusGamutMultiple(); });
}
COLSPACENAMES.forEach((element, index) => {
    let newOption = document.createElement("option");
    newOption.value = index; newOption.text = element;
    selectLocusGamutMultipleSpace.appendChild(newOption);
});
selectLocusGamutMultipleSpace.value = 0;
selectLocusGamutMultipleSpace.addEventListener("input", () => {
    arrayLocusGamutMultipleCtrlPoints = COLSPACES[selectLocusGamutMultipleSpace.value];
    varLocusGamutMultipleCurrentName = [COLSPACENAMES[selectLocusGamutMultipleSpace.value]];
    getWhitePoint(arrayLocusGamutMultipleCtrlPoints, XYD65, arrayLocusGamutMultipleWhitePoint);
    updateLocusGamutMultiple();
});
function updateLocusGamutMultiple() {
    for (let i = 0; i < 3; i++) arrayLocusGamutMultipleIntensities[i] = sliderLocusGamutMultipleIntensity[i].value * arrayLocusGamutMultipleWhitePoint[i];
    canvasLocusGamutMultiple.clearRect(0, 0, WIDTH, 600);
    drawSpaceChroma(canvasLocusGamutMultiple);
    drawSpaceLocus(canvasLocusGamutMultiple, arrayCHRMATXYZ, PROJMAT);
    drawGamut(canvasLocusGamutMultiple, arrayLocusGamutMultipleCtrlPoints, arrayLocusGamutMultipleIntensities);
    getChromaticity(arrayLocusGamutMultipleCtrlPoints, arrayLocusGamutMultipleIntensities, arrayLocusGamutMultiplePoint, arrayLocusGamutMultipleColor);
    drawSpacePoint(canvasLocusGamutMultiple, arrayLocusGamutMultiplePoint, PROJMAT);
    drawLabels(canvasLocusGamutMultiple, WAVXYZLABELS, WAVXYZLABELPOS);
    drawLabels(canvasLocusGamutMultiple, varLocusGamutMultipleCurrentName, [[801, 151]]);
    colorBoxRGB(divLocusGamutMultiple, vectorMultiply(MATRIX_XYZ_RGB, arrayLocusGamutMultipleColor));
}


const canvasHexDeconstruction = initializeCanvas("canvasHexDeconstruction", 250);
drawLabels(canvasHexDeconstruction, ["A49D2F"], [[641, 130]], "#000", "192px JetBrains Mono");
drawLabels(canvasHexDeconstruction, ["#"], [[250, 86]], "#000", "96px JetBrains Mono");
drawLabels(canvasHexDeconstruction, ["10100100"], [[406, 221]], "#a00", "36px JetBrains Mono");
drawLabels(canvasHexDeconstruction, ["10011101"], [[641, 221]], "#080", "36px JetBrains Mono");
drawLabels(canvasHexDeconstruction, ["00101111"], [[876, 221]], "#00e", "36px JetBrains Mono");


const canvasBlackbodyColorSPD = initializeCanvas("canvasBlackbodyColorSPD", 300);
const canvasBlackbodyColorSSC = initializeCanvas("canvasBlackbodyColorSSC", 300);
const canvasBlackbodyColorRSP = initializeCanvas("canvasBlackbodyColorRSP", 200);
const canvasLocusPlanckian = initializeCanvas("canvasLocusPlanckian", 600);
const sliderBlackbodyColorTemperature = document.getElementById("sliderBlackbodyColorTemperature");
const spanBlackbodyColor = document.getElementById("spanBlackbodyColor");
const arrayBlackbodyColorSPD = new Array(126).fill(0);
var arrayLocusPlanckianPoint = [0, 0, 0];
let arrayBlackbodyColorRSP = [0, 0, 0];
initializeSliders(sliderBlackbodyColorTemperature, 0.02, 0.9, 0.02, 0.54);
sliderBlackbodyColorTemperature.addEventListener("input", updateBlackbodyColor);
drawSSC(canvasBlackbodyColorSSC);
function updateBlackbodyColor() {
    canvasBlackbodyColorSPD.clearRect(0, 0, WIDTH, 300);
    canvasBlackbodyColorRSP.clearRect(0, 0, WIDTH, 200);
    canvasLocusPlanckian.clearRect(0, 0, WIDTH, 600);
    getCMFValues(Math.round(sliderBlackbodyColorTemperature.value * 50 - 1), arrayLocusPlanckianPoint, arrayPLANCKXYZ);
    getSPDBlackbody(sliderBlackbodyColorTemperature.value, arrayBlackbodyColorSPD);
    drawSPD(canvasBlackbodyColorSPD, arrayBlackbodyColorSPD);
    arrayBlackbodyColorRSP = drawRSP(canvasBlackbodyColorRSP, arrayBlackbodyColorSPD);
    drawSpaceChroma(canvasLocusPlanckian);
    drawSpaceLocus(canvasLocusPlanckian, arrayCHRMATXYZ, PROJMAT);
    drawSpaceLocus(canvasLocusPlanckian, arrayPLANCKXYZ, PROJMAT);
    drawSpacePoint(canvasLocusPlanckian, arrayLocusPlanckianPoint, PROJMAT);
    drawLabels(canvasLocusPlanckian, WAVXYZLABELS, WAVXYZLABELPOS);
    colorBoxRGB(divBlackbodyColor, vectorMultiply(MATRIX_TEMP_SRGB, arrayBlackbodyColorRSP));
}


const canvasLocusPlanckianLED = initializeCanvas("canvasLocusPlanckianLED", 600);
const arrayLocusPlanckianLEDPoints = [[0.330, 0.320, 0], [0.355, 0.385, 0], [0.345, 0.355, 0], [0.355, 0.325, 0], [0.308, 0.305, 0], [0.313, 0.345, 0]];
function updateLocusPlanckianLED() {
    drawSpaceChroma(canvasLocusPlanckianLED);
    drawSpaceLocus(canvasLocusPlanckianLED, arrayCHRMATXYZ, PROJMAT);
    drawSpaceLocus(canvasLocusPlanckianLED, arrayPLANCKXYZ, PROJMAT);
    drawLabels(canvasLocusPlanckianLED, WAVXYZLABELS, WAVXYZLABELPOS);
    for (let i = 0; i < arrayLocusPlanckianLEDPoints.length; i++)
        drawSpacePoint(canvasLocusPlanckianLED, arrayLocusPlanckianLEDPoints[i], PROJMAT, "#000", 6);
}


const canvasLocusPlanckianCCT = initializeCanvas("canvasLocusPlanckianCCT", 600);
const arrayLocusPlanckianCCTWavelengths =  [...WAVXYZLABELS.slice(0, 3), ...WAVXYZLABELS.slice(4)];
const arrayLocusPlanckianCCTWavelengthsPos =  [...WAVXYZLABELPOS.slice(0, 3), ...WAVXYZLABELPOS.slice(4)];
function updateLocusPlanckianCCT() {
    drawSpaceChroma(canvasLocusPlanckianCCT);
    drawSpaceLocus(canvasLocusPlanckianCCT, arrayCHRMATXYZ, PROJMAT);
    drawSpaceLocus(canvasLocusPlanckianCCT, arrayPLANCKXYZ, PROJMAT);
    drawLabels(canvasLocusPlanckianCCT, arrayLocusPlanckianCCTWavelengths, arrayLocusPlanckianCCTWavelengthsPos);
    drawLabels(canvasLocusPlanckianCCT, CCTTEMPS, CCTTEMPSPOS, "#000", "20px JetBrains Mono");
    for (let i = 0; i < CCTLINES.length; i++)
        drawSpaceLine(canvasLocusPlanckianCCT, CCTLINES[i][0], CCTLINES[i][1], PROJMAT);
}


const canvasLocusIlluminants = initializeCanvas("canvasLocusIlluminants", 600);
const selectLocusIlluminants = document.getElementById("selectLocusIlluminants");
const linkLocusIlluminants = document.getElementById("linkLocusIlluminants");
XYILLNAMES.forEach((element, index) => {
    let newOption = document.createElement("option");
    newOption.value = index; newOption.text = element;
    selectLocusIlluminants.appendChild(newOption);
});
selectLocusIlluminants.value = 3;
selectLocusIlluminants.addEventListener("input", updateLocusIlluminants);
linkLocusIlluminants.addEventListener("click", () => {
    selectLocusIlluminants.value = (selectLocusIlluminants.value * 1 + 1) % arrayXYILLS.length;
    updateLocusIlluminants(); });
function updateLocusIlluminants() {
    canvasLocusIlluminants.clearRect(0, 0, WIDTH, 600);
    varLocusIlluminantsCurrent = arrayXYILLS[selectLocusIlluminants.value];
    drawSpaceChroma(canvasLocusIlluminants);
    drawSpaceLocus(canvasLocusIlluminants, arrayCHRMATXYZ, PROJMAT);
    drawSpaceLocus(canvasLocusIlluminants, arrayPLANCKXYZ, PROJMAT);
    drawSpacePoint(canvasLocusIlluminants, varLocusIlluminantsCurrent, PROJMAT, "#000", 6);
    drawLabels(canvasLocusIlluminants, WAVXYZLABELS, WAVXYZLABELPOS);
    colorBoxRGB(divLocusIlluminants, vectorMultiply([[3, 0, 0], [0, 3, 0], [0, 0, 3]], vectorMultiply(MATRIX_XYZ_RGB, varLocusIlluminantsCurrent)));
    for (let i = 0; i < CCTLINES.length; i++)
        drawSpaceLine(canvasLocusIlluminants, CCTLINES[i][0], CCTLINES[i][1], PROJMAT);
}


const canvasReflectanceIlluminant = initializeCanvas("canvasReflectanceIlluminant", 300);
const canvasReflectanceReflectance = initializeCanvas("canvasReflectanceReflectance", 300);
const canvasReflectanceProduct = initializeCanvas("canvasReflectanceProduct", 300);
const canvasReflectanceRSP = initializeCanvas("canvasReflectanceRSP", 200);
const linkReflectanceIlluminantA = document.getElementById("linkReflectanceIlluminantA");
const linkReflectanceD65 = document.getElementById("linkReflectanceD65");
const selectReflectanceIlluminants = document.getElementById("selectReflectanceIlluminants");
let arrayReflectanceReflectanceSPD = arraySPDPink;
let arrayReflectanceReflectanceRSP = [0, 0, 0];
let arrayReflectanceIlluminantSPD = [];
let arrayReflectanceProductSPD = [];
XYILLSPDNAMES.forEach((element, index) => {
    let newOption = document.createElement("option");
    newOption.value = index; newOption.text = element;
    selectReflectanceIlluminants.appendChild(newOption);
});
selectReflectanceIlluminants.value = 2;
selectReflectanceIlluminants.addEventListener("input", updateReflectance);
linkReflectanceIlluminantA.addEventListener("click", () => { selectReflectanceIlluminants.value = 0; updateReflectance(); });
linkReflectanceD65.addEventListener("click", () => { selectReflectanceIlluminants.value = 1; updateReflectance(); });
linkReflectanceSPDGrey.addEventListener("click", () => { arrayReflectanceReflectanceSPD = arraySPDGrey; updateReflectance(); });
linkReflectanceSPDWhite.addEventListener("click", () => { arrayReflectanceReflectanceSPD = arraySPDSaturated; updateReflectance(); });
linkReflectanceSPDOlive.addEventListener("click", () => { arrayReflectanceReflectanceSPD = arraySPDOlive; updateReflectance(); });
linkReflectanceSPDPink.addEventListener("click", () => { arrayReflectanceReflectanceSPD = arraySPDPink; updateReflectance(); });
linkReflectanceSPDPurple.addEventListener("click", () => { arrayReflectanceReflectanceSPD = arraySPDPurple; updateReflectance(); });
function updateReflectance() {
    canvasReflectanceIlluminant.clearRect(0, 0, WIDTH, 300);
    canvasReflectanceReflectance.clearRect(0, 0, WIDTH, 300);
    canvasReflectanceProduct.clearRect(0, 0, WIDTH, 300);
    canvasReflectanceRSP.clearRect(0, 0, WIDTH, 200);
    arrayReflectanceIlluminantSPD = XYILLSPDS[selectReflectanceIlluminants.value];
    arrayReflectanceProductSPD = arrayReflectanceReflectanceSPD.map((value, index) => value * arrayReflectanceIlluminantSPD[index]);
    drawSPD(canvasReflectanceReflectance, arrayReflectanceReflectanceSPD);
    drawSPD(canvasReflectanceIlluminant, arrayReflectanceIlluminantSPD);
    drawSPD(canvasReflectanceProduct, arrayReflectanceProductSPD);
    arrayReflectanceRSP = drawRSP(canvasReflectanceRSP, arrayReflectanceProductSPD);
    colorBoxRGB(divReflectance, vectorMultiply(MATRIX_LMS_SRGB, arrayReflectanceRSP));
}
updateReflectance();


const canvasWhitePointsCompare = initializeCanvas("canvasWhitePointsCompare", 900);
const divWhitePointsCompareA = document.getElementById("divWhitePointsCompareA");
const divWhitePointsCompareB = document.getElementById("divWhitePointsCompareB");
const imgWhitePointsCompare = initializeImage("/media/lab/quantifying-colour/whitepoint.avif");
placeImage(imgWhitePointsCompare, canvasWhitePointsCompare);
canvasWhitePointsCompare.canvas.addEventListener("mousemove", (evt) => getColorPicker(evt, canvasWhitePointsCompare, divWhitePointsCompareA, divWhitePointsCompareB));
canvasWhitePointsCompare.canvas.addEventListener("touchmove", (evt) => getColorPicker(evt, canvasWhitePointsCompare, divWhitePointsCompareA, divWhitePointsCompareB));


const canvasLocusWhitePoint = initializeCanvas("canvasLocusWhitePoint", 600);
const selectLocusWhitePoint1 = document.getElementById("selectLocusWhitePoint1");
const selectLocusWhitePoint2 = document.getElementById("selectLocusWhitePoint2");
const selectLocusWhitePointSpace = document.getElementById("selectLocusWhitePointSpace");
const divLocusWhitePoint1 = document.getElementById("divLocusWhitePoint1");
const divLocusWhitePoint2 = document.getElementById("divLocusWhitePoint2");
const arrayLocusWhitePointWhitePoint1 = [0.638, 1.175, 1.186];
const arrayLocusWhitePointWhitePoint2 = [0.775, 1.129, 1.096];
const arrayLocusWhitePointIntensities = [0, 0, 0];
const arrayLocusWhitePointPoint = [0, 0, 0];
const arrayLocusWhitePointColor = [0, 0, 0];
const sliderLocusWhitePointIntensity = [];
let varLocusWhitePointCurrentName = [COLSPACENAMES[0]];
let arrayLocusWhitePointCtrlPoints = COLSPACES[0];
for (let i = 0; i < 3; i++) {
    sliderLocusWhitePointIntensity[i] = document.getElementById(`sliderLocusWhitePointIntensity${i}`);
    initializeSliders(sliderLocusWhitePointIntensity[i], 0.01, 2.99, 0.01, 1);
    sliderLocusWhitePointIntensity[i].addEventListener("input", () => {
        normalizeSliders(sliderLocusWhitePointIntensity, i, 3); updateLocusWhitePoint(); });
}
XYILLNAMES.forEach((element, index) => {
    let newOption1 = document.createElement("option");
    let newOption2 = document.createElement("option");
    newOption1.value = index; newOption1.text = element;
    newOption2.value = index; newOption2.text = element;
    selectLocusWhitePoint1.appendChild(newOption1);
    selectLocusWhitePoint2.appendChild(newOption2);
});
COLSPACENAMES.forEach((element, index) => {
    let newOption = document.createElement("option");
    newOption.value = index; newOption.text = element;
    selectLocusWhitePointSpace.appendChild(newOption);
});
selectLocusWhitePoint1.value = 3;
selectLocusWhitePoint2.value = 5;
selectLocusWhitePoint1.addEventListener("input", () => {
    getWhitePoint(arrayLocusWhitePointCtrlPoints, arrayXYILLS[selectLocusWhitePoint1.value], arrayLocusWhitePointWhitePoint1);
    updateLocusWhitePoint();
});
selectLocusWhitePoint2.addEventListener("input", () => {
    getWhitePoint(arrayLocusWhitePointCtrlPoints, arrayXYILLS[selectLocusWhitePoint2.value], arrayLocusWhitePointWhitePoint2);
    updateLocusWhitePoint();
});
selectLocusWhitePointSpace.addEventListener("input", () => {
    arrayLocusWhitePointCtrlPoints = COLSPACES[selectLocusWhitePointSpace.value];
    varLocusWhitePointCurrentName = [COLSPACENAMES[selectLocusWhitePointSpace.value]];
    getWhitePoint(arrayLocusWhitePointCtrlPoints, arrayXYILLS[selectLocusWhitePoint1.value], arrayLocusWhitePointWhitePoint1);
    getWhitePoint(arrayLocusWhitePointCtrlPoints, arrayXYILLS[selectLocusWhitePoint2.value], arrayLocusWhitePointWhitePoint2);
    updateLocusWhitePoint();
});
function updateLocusWhitePoint() {
    canvasLocusWhitePoint.clearRect(0, 0, WIDTH, 600);
    drawSpaceChroma(canvasLocusWhitePoint);
    for (let i = 0; i < 3; i++) arrayLocusWhitePointIntensities[i] = sliderLocusWhitePointIntensity[i].value * arrayLocusWhitePointWhitePoint2[i];
    getChromaticity(arrayLocusWhitePointCtrlPoints, arrayLocusWhitePointIntensities, arrayLocusWhitePointPoint, arrayLocusWhitePointColor);
    drawGamut(canvasLocusWhitePoint, arrayLocusWhitePointCtrlPoints, arrayLocusWhitePointIntensities, PROJMAT, "#999");
    drawSpacePoint(canvasLocusWhitePoint, arrayLocusWhitePointPoint, PROJMAT, "#999");
    colorBoxRGB(divLocusWhitePoint2, vectorMultiply(MATRIX_XYZ_RGB, arrayLocusWhitePointColor));
    for (let i = 0; i < 3; i++) arrayLocusWhitePointIntensities[i] = sliderLocusWhitePointIntensity[i].value * arrayLocusWhitePointWhitePoint1[i];
    getChromaticity(arrayLocusWhitePointCtrlPoints, arrayLocusWhitePointIntensities, arrayLocusWhitePointPoint, arrayLocusWhitePointColor);
    drawGamut(canvasLocusWhitePoint, arrayLocusWhitePointCtrlPoints, arrayLocusWhitePointIntensities);
    drawSpacePoint(canvasLocusWhitePoint, arrayLocusWhitePointPoint, PROJMAT);
    colorBoxRGB(divLocusWhitePoint1, vectorMultiply(MATRIX_XYZ_RGB, arrayLocusWhitePointColor));
    drawSpaceLocus(canvasLocusWhitePoint, arrayCHRMATXYZ, PROJMAT);
    drawLabels(canvasLocusWhitePoint, WAVXYZLABELS, WAVXYZLABELPOS);
    drawLabels(canvasLocusWhitePoint, varLocusWhitePointCurrentName, [[801, 151]]);
}


const canvasChromaticAdaptation = initializeCanvas("canvasChromaticAdaptation", 900);
const divChromaticAdaptationA = document.getElementById("divChromaticAdaptationA");
const divChromaticAdaptationB = document.getElementById("divChromaticAdaptationB");
const imgChromaticAdaptation = initializeImage("/media/lab/quantifying-colour/whitepoint.avif");
placeImage(imgChromaticAdaptation, canvasChromaticAdaptation);
canvasChromaticAdaptation.canvas.addEventListener("mousemove", (evt) => getColorPicker(evt, canvasChromaticAdaptation, divChromaticAdaptationA, divChromaticAdaptationB));
canvasChromaticAdaptation.canvas.addEventListener("touchmove", (evt) => getColorPicker(evt, canvasChromaticAdaptation, divChromaticAdaptationA, divChromaticAdaptationB));


const imgChromaticAdaptationDress = initializeImage("/media/lab/quantifying-colour/dress.avif");

const canvasChromaticAdaptationDressBlue = initializeCanvas("canvasChromaticAdaptationDressBlue", 600);
const imgChromaticAdaptationDressBlue = initializeImage("/media/lab/quantifying-colour/dress.blue.avif");
placeImage(imgChromaticAdaptationDressBlue, canvasChromaticAdaptationDressBlue, 0, 0, 400, 600);
placeImage(imgChromaticAdaptationDress, canvasChromaticAdaptationDressBlue, 400, 0, 400, 600);


const canvasChromaticAdaptationDressGold = initializeCanvas("canvasChromaticAdaptationDressGold", 600);
const imgChromaticAdaptationDressGold = initializeImage("/media/lab/quantifying-colour/dress.gold.avif");
placeImage(imgChromaticAdaptationDressGold, canvasChromaticAdaptationDressGold, 0, 0, 400, 600);
placeImage(imgChromaticAdaptationDress, canvasChromaticAdaptationDressGold, 400, 0, 400, 600);


const canvasChromaticAdaptationDressChroma = initializeCanvas("canvasChromaticAdaptationDressChroma", 600);
const linkChromaticAdaptationDressChromaCool = document.getElementById("linkChromaticAdaptationDressChromaCool");
const linkChromaticAdaptationDressChromaWarm = document.getElementById("linkChromaticAdaptationDressChromaWarm");
const varChromaticAdaptationDressChromaX1 = 180;
const varChromaticAdaptationDressChromaY1 = 40;
const varChromaticAdaptationDressChromaX2 = 280;
const varChromaticAdaptationDressChromaY2 = 140;
const arrayChromaticAdaptationDressChromaPoint1 = [varChromaticAdaptationDressChromaX1 + 880, varChromaticAdaptationDressChromaY1]
const arrayChromaticAdaptationDressChromaPoint2 = [varChromaticAdaptationDressChromaX2 + 880, varChromaticAdaptationDressChromaY2]
let arrayChromaticAdaptationDressChromaChroma1 = [];
let arrayChromaticAdaptationDressChromaChroma2 = [];
placeImage(imgChromaticAdaptationDress, canvasChromaticAdaptationDressChroma, 880, 0, 400, 600);
linkChromaticAdaptationDressChromaCool.addEventListener("click", () => {
    canvasChromaticAdaptationDressChroma.clearRect(0, 0, WIDTH, 600);
    canvasChromaticAdaptationDressChroma.drawImage(imgChromaticAdaptationDressBlue, 880, 0, 400, 600);
    updateChromaticAdaptationDressChroma(); });
linkChromaticAdaptationDressChromaWarm.addEventListener("click", () => {
    canvasChromaticAdaptationDressChroma.clearRect(0, 0, WIDTH, 600);
    canvasChromaticAdaptationDressChroma.drawImage(imgChromaticAdaptationDress, 880, 0, 400, 600);
    updateChromaticAdaptationDressChroma(); });
function updateChromaticAdaptationDressChroma() {
    drawSpaceChroma(canvasChromaticAdaptationDressChroma);
    drawSpaceLocus(canvasChromaticAdaptationDressChroma, arrayCHRMATXYZ, PROJMAT);
    drawLabels(canvasChromaticAdaptationDressChroma, WAVXYZLABELS, WAVXYZLABELPOS);
    arrayChromaticAdaptationDressChromaChroma1 = getXYPixel(canvasChromaticAdaptationDressChroma, varChromaticAdaptationDressChromaX1, varChromaticAdaptationDressChromaY1, 880, 0);
    arrayChromaticAdaptationDressChromaChroma2 = getXYPixel(canvasChromaticAdaptationDressChroma, varChromaticAdaptationDressChromaX2, varChromaticAdaptationDressChromaY2, 880, 0);
    arrayChromaticAdaptationDressChromaChroma1 = vectorMultiply(PROJMAT, arrayChromaticAdaptationDressChromaChroma1.concat(1));
    arrayChromaticAdaptationDressChromaChroma2 = vectorMultiply(PROJMAT, arrayChromaticAdaptationDressChromaChroma2.concat(1));
    drawSpaceLine(canvasChromaticAdaptationDressChroma, arrayChromaticAdaptationDressChromaChroma1, arrayChromaticAdaptationDressChromaPoint1, IDENTITY);
    drawSpaceLine(canvasChromaticAdaptationDressChroma, arrayChromaticAdaptationDressChromaChroma2, arrayChromaticAdaptationDressChromaPoint2, IDENTITY);
    drawSpacePoint(canvasChromaticAdaptationDressChroma, arrayChromaticAdaptationDressChromaChroma1, IDENTITY);
    drawSpacePoint(canvasChromaticAdaptationDressChroma, arrayChromaticAdaptationDressChromaChroma2, IDENTITY);
    drawSpacePoint(canvasChromaticAdaptationDressChroma, arrayChromaticAdaptationDressChromaPoint1, IDENTITY);
    drawSpacePoint(canvasChromaticAdaptationDressChroma, arrayChromaticAdaptationDressChromaPoint2, IDENTITY);
}


Promise.all([loadImage(imgChromaticAdaptationDress), loadImage(CHRDIAGRAM)]).then(() => {
    updateXYChromaticityDiagram();
    updateLocusRatio();
    updateLocusGamutTwo();
    updateLocusGamutCIE();
    updateLocusGamutMultiple();
    updateBlackbodyColor();
    updateLocusPlanckianLED();
    updateLocusPlanckianCCT();
    updateLocusIlluminants();
    updateLocusWhitePoint();
    updateChromaticAdaptationDressChroma();
});



// functions

function loadImage(imageObject) {
    return new Promise((resolve, reject) => {
        imageObject.onload = resolve;
        imageObject.onerror = reject;
    });
}

function initializeImage(imagePath) {
    const imageObject = new Image();
    imageObject.src = imagePath;
    return imageObject;
}

function placeImage(imageObject, canvas, x = 0, y = 0, dw = null, dh = null) {
    imageObject.addEventListener("load", () => {
        if (dw || dh) { canvas.drawImage(imageObject, x, y, dw, dh); }
        else { canvas.drawImage(imageObject, x, y); }
        imageObject.style.display = "none";
    });
}

function getXYPixel(canvas, x, y, sx = 0, sy = 0) {
    const img = canvas.getImageData(sx, sy, canvas.canvas.width - sx, canvas.canvas.height - sy).data;
    const srgbPos = y * ((canvas.canvas.width - sx) * 4) + x * 4;
    const srgbVector = [img[srgbPos] / 255, img[srgbPos + 1] / 255, img[srgbPos + 2] / 255];
    const XYZ = vectorMultiply(MATRIX_SRGB_XYZ, srgbVector);
    const sum = XYZ[0] + XYZ[1] + XYZ[2];
    return [XYZ[0] / sum, XYZ[1] / sum, XYZ[2] / sum];
}

function getColorPicker(evt, canvas, colorBox, colorBoxOpt = null) {
    canvas.canvas.style.cursor = "crosshair";
    const rect = canvas.canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.canvas.width / rect.width);
    const y = (evt.clientY - rect.top) * (canvas.canvas.height / rect.height);
    let data = canvas.getImageData(x, y, 1, 1).data;
    if (colorBoxOpt == null) {
        colorBox.style.background = `rgb(${data[0]} ${data[1]} ${data[2]} / ${data[3] / 255})`;
        return data;
    }
    if (y > canvas.canvas.height / 2) {
        colorBox.style.background = `rgb(${data[0]} ${data[1]} ${data[2]} / ${data[3] / 255})`;
        data = canvas.getImageData(x, y - canvas.canvas.height / 2, 1, 1).data;
        colorBoxOpt.style.background = `rgb(${data[0]} ${data[1]} ${data[2]} / ${data[3] / 255})`;
    }
    else {
        colorBoxOpt.style.background = `rgb(${data[0]} ${data[1]} ${data[2]} / ${data[3] / 255})`;
        data = canvas.getImageData(x, y + canvas.canvas.height / 2, 1, 1).data;
        colorBox.style.background = `rgb(${data[0]} ${data[1]} ${data[2]} / ${data[3] / 255})`;
    }
    return;
}

function getWhitePoint(points, whitePoint, intensities) {
    let det = ((points[0][0] - points[2][0]) * (points[1][1] - points[2][1])) - ((points[1][0] - points[2][0]) * (points[0][1] - points[2][1]));
    intensities[0] = 3 * (((points[1][1] - points[2][1]) * (whitePoint[0] - points[2][0])) - ((points[1][0] - points[2][0]) * (whitePoint[1] - points[2][1]))) / det;
    intensities[1] = 3 * (((points[0][0] - points[2][0]) * (whitePoint[1] - points[2][1])) - ((points[0][1] - points[2][1]) * (whitePoint[0] - points[2][0]))) / det;
    intensities[2] = 3 - intensities[0] - intensities[1];
}

function getSPDBlackbody(temperature, spdArray) {
    let k = 0.005 * 0.005 * temperature * temperature;
    let c = 2.1 ** (1 / temperature);
    for (let i = 70; i < 196; i++)
        spdArray[i - 70] = 1 / ((i ** 2) * k * (c ** (200 / i)));
//    more accurate curve
//    let k = (temperature ** -5) * 0.047;
//    for (let i = 100; i < 226; i++)
//        spdArray[i - 100] = k / (((i / 600) ** 5) * (2.72 ** (600 / (i * temperature))));
}

function drawCircles(canvas, x, y, color = "#000", radius = 100) {
    canvas.fillStyle = color;
    canvas.beginPath();
    canvas.arc(x, y, radius, 0, 2 * Math.PI);
    canvas.fill();
}

function drawGamut(canvas, points, intensities, projection = PROJMAT, color = "#000") {
    let endPoints = [[0, 0, 0], [0, 0, 0]];
    let median = [0, 0, 0];
    let endIntensities = [0, 0];
    for (let i = 0; i < 3; i++) {
        drawSpaceLine(canvas, points[i], points[(i + 1) % 3], projection, color);
        drawSpacePoint(canvas, points[i], projection, color, 6);
        endPoints[0] = points[i]; endPoints[1] = points[(i + 1) % 3];
        endIntensities[0] = intensities[i]; endIntensities[1] = intensities[(i + 1) % 3];
        getChromaticity(endPoints, endIntensities, median, median);
        drawSpaceLine(canvas, points[(i + 2) % 3], median, projection, color);
        drawSpacePoint(canvas, median, projection, color, 6);
    }
}

function drawSpaceChroma(canvas, diagram = CHRDIAGRAM, locus = arrayCHRMATXYZ, projection = PROJMAT) {
    canvas.drawImage(diagram, 130, 10, 550, 590);
    canvas.fillStyle = "#fff";
    canvas.beginPath();
    canvas.moveTo(120, 10);
    canvas.lineTo(690, 10);
    canvas.lineTo(690, 610);
    canvas.lineTo(120, 610);
    canvas.moveTo(locus[0][0] * projection[0][0] + projection[0][3], locus[1][0] * projection[1][1] + projection[1][3])
    for (let i = 1; i < locus[0].length; i++)
        canvas.lineTo(locus[0][i] * projection[0][0] + projection[0][3], locus[1][i] * projection[1][1] + projection[1][3])
    canvas.fill('evenodd');
}

function drawSpaceChromaFill(canvas, locus = arrayCHRMATRGB, projection = PROJMAT, color = "#fff") {
    canvas.fillStyle = color;
    canvas.beginPath();
    canvas.moveTo(locus[0][0] * projection[0][0] + projection[0][3], locus[1][0] * projection[1][1] + projection[1][3])
    for (let i = 1; i < locus[0].length; i++)
        canvas.lineTo(locus[0][i] * projection[0][0] + projection[0][3], locus[1][i] * projection[1][1] + projection[1][3])
    canvas.fill();
}

function getChromaticity(array, intensities, norms, total) {
    let totalIntensity = 0;
    for (let i = 0; i < array.length; i++) totalIntensity += intensities[i];
    for (let i = 0; i < 3; i++) total[i] = 0;
    for (let i = 0; i < array.length; i++) {
        total[0] += intensities[i] * array[i][0];
        total[1] += intensities[i] * array[i][1];
        total[2] += intensities[i] * array[i][2];
    }
    for (let i = 0; i < array.length; i++) norms[i] = total[i] / totalIntensity;
}

function changeTransformation(array, value, range, xz = 0.85, yz = -0.25, xx = -0.05, original = TRANSFMAT) {
    array[0][2] = original[0][2] - range * xz + value * xz;
    array[1][2] = original[1][2] - range * yz + value * yz;
    array[0][0] = original[0][0] - range * xx + value * xx;
}

function normalizeSliders(sliderArray, current, total = 1) {
    let norm = 0;
    let sliders = sliderArray.length;
    for (let i = 1; i < sliders; i++) norm += Number(sliderArray[(current + i) % sliders].value);
    norm = (total - sliderArray[current].value) / norm;
    for (let i = 1; i < sliders; i++)
    sliderArray[(current + i) % sliders].value *= norm;
}

function drawSpaceMatrix(canvas, matrix, offsetX = 861, offsetY = 151, color = "#000", width = 2) {
    let bracketX = [[-45, -60], [245, 260]];
    let bracketY = [-40, 136];
    let labels = [];
    let coordinates = [];
    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
            labels.push(Number(matrix[i][j]).toFixed(2));
            coordinates.push([j * 100 + offsetX, i * 50 + offsetY]);
        }
    }
    drawLabels(canvas, labels, coordinates, color);
    for (let i = 0; i < 2; i++) {
        canvas.moveTo(offsetX + bracketX[i][0], offsetY + bracketY[0]);
        canvas.lineTo(offsetX + bracketX[i][1], offsetY + bracketY[0]);
        canvas.lineTo(offsetX + bracketX[i][1], offsetY + bracketY[1]);
        canvas.lineTo(offsetX + bracketX[i][0], offsetY + bracketY[1]);
    } canvas.stroke();
}

function drawSpaceLabels(canvas, labels = RGBPM, transformation = TRANSFMAT, offsets = CUBELABELOFF, endpoints = CUBELABELPOS, color = "#000") {
    let coordinates = [];
    let vertex = [];
    for (let i = 0; i < labels.length; i++) {
        vertex = [0, 0, 0, 0.95];
        vertex[i] = endpoints[i]
        vertex[3] = offsets[i];
        coordinates.push(vectorMultiply(transformation, vertex));
}
    drawLabels(canvas, labels, coordinates, color);
}

function drawSpaceLocus(canvas, locus = arrayCOLMATRGB, transformation = TRANSFMAT, color = "#000", width = 2) {
    let coordinates = [locus[0][0], locus[1][0], locus[2][0], 1];
    let points = vectorMultiply(transformation, coordinates);
    canvas.lineWidth = width;
    canvas.strokeStyle = color;
    canvas.beginPath();
    canvas.moveTo(points[0], points[1]);
    for (let i = 1; i < locus[0].length; i++) {
        coordinates = [locus[0][i], locus[1][i], locus[2][i], 1];
        points = vectorMultiply(transformation, coordinates);
        canvas.lineTo(points[0], points[1]);
    }
    canvas.stroke();
}

function drawSpaceLine(canvas, pointA, pointB, transformation = TRANSFMAT, color = "#000", width = 2) {
    canvas.lineWidth = width;
    canvas.strokeStyle = color;
    pointA = vectorMultiply(transformation, pointA.concat(1));
    pointB = vectorMultiply(transformation, pointB.concat(1));
    canvas.beginPath();
    canvas.moveTo(pointA[0], pointA[1]);
    canvas.lineTo(pointB[0], pointB[1]);
    canvas.stroke();
}

function drawSpaceTriangle(canvas, k = 1, transformation = TRANSFMAT, color = "#000", width = 2, fill = null) {
    let points = [[k, 0, 0, 1], [0, k, 0, 1], [0, 0, k, 1], [k, 0, 0, 1]];
    let vertex = vectorMultiply(transformation, points[0]);
    if (fill) canvas.fillStyle = fill;
    canvas.strokeStyle = color;
    canvas.lineWidth = width;
    canvas.beginPath();
    canvas.moveTo(vertex[0], vertex[1]);
    for (let i = 1; i < points.length; i++) {
        vertex = vectorMultiply(transformation, points[i]);
        canvas.lineTo(vertex[0], vertex[1]);
    }
    if (fill) canvas.fill();
    canvas.stroke();
}

function drawSpaceSlice(canvas, k = 1, transformation = TRANSFMAT, res = 1) {
    const resolution = res / (50 * k);
    let vertex = [0, 0, 0, 1];
    let points = [0, 0];
    let color = [0, 0, 0];
    let r = g = 0;
    for (let i = 0; i < 1; i += resolution) {
        for (let j = resolution; j < 1; j += resolution) {
            r = i * k; g = j * k;
            if (r > 1 || g > 1 || k - r - g > 1 || r + g - k > 0) continue;
            vertex[0] = color[0] = r;
            vertex[1] = color[1] = g;
            vertex[2] = color[2] = k - r - g;
            point = vectorMultiply(transformation, vertex);
            canvas.fillStyle = getColor(color);
            canvas.fillRect(point[0], point[1], 5, 5);
        }
    }
}

function drawSpacePlane(canvas, values, colorTransform = identityTransform, transformation = TRANSFMAT) {
    const iterationsX = [16, 40, 40];
    const iterationsY = [40, 16, 40];
    const weights = [[[-7.5, 0], [5, 10]], [[10, -7.8125], [0, -5]], [[0, 10], [-10, 0]]];
    const bias = [[-6, -4], [0, 2], [2, -8]];
    const sizes = [[4, 7], [6, 3], [6, 6]];
    let vertex = [0, 0, 0, 1];
    let color = [0, 0, 0];
    for (let i = 0; i < 3 ; i++) {
        color[i] = values[i];
        vertex = [0, 0, 0, 1]; vertex[i] = values[i]; vertex = vectorMultiply(transformation, vertex);
        for (let x = 0; x < iterationsX[i]; x++) {
            for (let y = 0; y < iterationsY[i]; y++) {
                color[(i + 1) % 3] = y / iterationsY[i];
                color[(i + 2) % 3] = x / iterationsX[i];
                canvas.fillStyle = getColor(colorTransform(color));
                canvas.fillRect(vertex[0] + x * weights[i][0][0] + y * weights[i][0][1] + bias[i][0], vertex[1] + x * weights[i][1][0] - y * weights[i][1][1] + bias[i][1], sizes[i][0], sizes[i][1]);
            }
        }
    }
}

function LMStoRGBClip(lmsArray) {
    let rgb = vectorMultiply(MATRIX_LMS_SRGB, lmsArray);
    if (rgb[0] > 1 || rgb[1] > 1.1 || rgb[2] > 1) rgb[0] = rgb[1] = rgb[2] = 0;
    if (rgb[0] < 0 || rgb[1] < 0 || rgb[2] < 0) rgb[0] = rgb[1] = rgb[2] = 0;
    return rgb;
}

function RGBtoXYZClip(rgbArray) {
    let xyz = vectorMultiply(MATRIX_XYZ_RGB, rgbArray);
    if (xyz[0] > 1 || xyz[1] > 1 || xyz[2] > 1) xyz[0] = xyz[1] = xyz[2] = 0.85;
    if (xyz[0] < 0 || xyz[1] < 0 || xyz[2] < 0) xyz[0] = xyz[1] = xyz[2] = 0.85;
    return xyz;
}

function drawSpaceCube(canvas, transformation = TRANSFMAT, oppVertex = CUBEPOINTS, inner = false, color = "#999", width = 2) {
    let verticesShell = [[oppVertex[0], 0, 0, 1], [oppVertex[0], oppVertex[1], 0, 1], [0, oppVertex[1], 0, 1], [0, oppVertex[1], oppVertex[2], 1], [0, 0, oppVertex[2], 1], [oppVertex[0], 0, oppVertex[2], 1], [oppVertex[0], 0, 0, 1]];
    let vertexOpp = [0, 0, 0, 0];
    let vertex = vectorMultiply(transformation, verticesShell[0]);
    canvas.lineWidth = width;
    canvas.strokeStyle = color;
    canvas.beginPath();
    canvas.moveTo(vertex[0], vertex[1]);
    for (let i = 1; i < verticesShell.length; i++) {
        vertex = vectorMultiply(transformation, verticesShell[i]);
        canvas.lineTo(vertex[0], vertex[1]);
    }
    for (let i = 0; i < 3; i++) {
        vertexOpp = oppVertex.concat(1);
        vertex = vectorMultiply(transformation, vertexOpp);
        canvas.moveTo(vertex[0], vertex[1]);
        vertexOpp[i] = 0;
        vertex = vectorMultiply(transformation, vertexOpp);
        canvas.lineTo(vertex[0], vertex[1]);
    }
    if (inner) {
        for (let i = 0; i < 3; i++) {
            vertex = vectorMultiply(transformation, [0, 0, 0, 1]);
            canvas.moveTo(vertex[0], vertex[1]);
            vertexOpp = [0, 0, 0, 1];
            vertexOpp[i] = oppVertex[i];
            vertex = vectorMultiply(transformation, vertexOpp);
            canvas.lineTo(vertex[0], vertex[1]);
        }
    }
    canvas.stroke();
}

function drawSpacePointLines(canvas, coordinates, transformation = TRANSFMAT, color = "#000", width = 6) {
    let points = vectorMultiply(transformation, coordinates.concat(1));
    let vertex = coordinates.concat(1);
    canvas.lineWidth = width;
    canvas.strokeStyle = color;
    canvas.beginPath();
    canvas.moveTo(points[0], points[1]);
    for (let i = 0; i < coordinates.length; i++) {
        vertex[i] = 0; points = vectorMultiply(transformation, vertex);
        canvas.lineTo(points[0], points[1]);
    }
    canvas.stroke();
}

function drawSpacePoint(canvas, coordinates, transformation = TRANSFMAT, color = "#000", radius = 8) {
    let coords = vectorMultiply(transformation, coordinates.concat(1));
    canvas.fillStyle = color;
    canvas.beginPath();
    canvas.arc(coords[0], coords[1], radius, 0, 2 * Math.PI);
    canvas.fill();
}

function drawSpaceAxes(canvas, transformation = TRANSFMAT, axes = BASEAXES, colors = LMSCOLORS, width = 2) {
    canvas.lineWidth = width;
    let origin = vectorMultiply(transformation, [0, 0, 0, 1]);
    let vertex;
    for (let c = 0; c < axes.length; c++) {
        canvas.strokeStyle = colors[c];
        canvas.beginPath();
        canvas.moveTo(origin[0], origin[1]);
        vertex = vectorMultiply(transformation, axes[c]);
        canvas.lineTo(vertex[0], vertex[1]);
        canvas.stroke();
    }
}

function drawLabels(canvas, labels, positions, color = "#000", font = "25px JetBrains Mono", horizontal = "center", vertical = "middle") {
    initializeCanvasText(canvas, color, horizontal, vertical, font);
    for (let i = 0; i < labels.length; i++)
        canvas.fillText(labels[i], positions[i][0], positions[i][1]);
}

function getCMFTransform(matrix, transformedArray, cmfArray = arrayCOLMATRGB) {
    for (let i = 0; i < cmfArray[0].length; i++) {
        transformedArray[0][i] = matrix[0][0] * cmfArray[0][i] + matrix[0][1] * cmfArray[1][i] + matrix[0][2] * cmfArray[2][i];
        transformedArray[1][i] = matrix[1][0] * cmfArray[0][i] + matrix[1][1] * cmfArray[1][i] + matrix[1][2] * cmfArray[2][i];
        transformedArray[2][i] = matrix[2][0] * cmfArray[0][i] + matrix[2][1] * cmfArray[1][i] + matrix[2][2] * cmfArray[2][i];
    }
}

function getCMFValues(wavelength, values, cmfArray = arrayCOLMATRGB) {
    for (let i = 0; i < cmfArray.length; i++)
        values[i] = cmfArray[i][wavelength];
}

function getCMFSPD(wavelength, spdArray, cmfArray = arrayCOLMATRGB, cmfWavelengths = RGBWAVES) {
    for (let i = 0; i < cmfWavelengths.length; i++)
        spdArray[cmfWavelengths[i]] = Math.max(0.0001, cmfArray[i][wavelength]);
}

function getSPD(canvas, spdArray, evt) {
    let x, y = 0;
    const rect = canvas.getBoundingClientRect();
    if (evt.touches) { x = evt.touches[0].clientX; y = evt.touches[0].clientY; }
    else { x = evt.clientX; y = evt.clientY; }
    let wavelengthBin = (x - rect.left) * (canvas.width / rect.width);
    let intensity = (y - rect.top) * (canvas.height / rect.height);
    wavelengthBin = Math.floor((wavelengthBin - 15) / 10);
    intensity = Math.min(1, Math.max(0, (canvas.height - 49 - intensity) / (canvas.height - 64)));
    spdArray[wavelengthBin] = intensity;
}

function drawCMF(canvas, wavelength, cmfArray = arrayCOLMATRGB, colors = LMSCOLORS, color = "#000", width = 2) {
    for (let i = 0; i < cmfArray.length; i++)
        drawSPD(canvas, cmfArray[i], colors[i]);
    canvas.lineWidth = width;
    canvas.strokeStyle = color;
    canvas.beginPath();
    canvas.moveTo(wavelength * 10 + 15, 3);
    canvas.lineTo(wavelength * 10 + 15, 255);
    canvas.stroke();
}

function drawSpectralBar(canvas, means = LMSMEANS, deviations = LMSDEVNS, correction = 1, height = 50) {
    let spd = new Array(126).fill(0)
    canvas.lineWidth = 10;
    for (let i = 0; i < 126; i++) {
        spd[i] = 0;
        spd[i + 1] = correction;
        responses = getResponses(spd, means, deviations);
        let color = vectorMultiply(MATRIX_LMS_SRGB, responses);
        canvas.strokeStyle = getColor(color);
        canvas.beginPath();
        canvas.moveTo(i * 10 + 15, 0);
        canvas.lineTo(i * 10 + 15, height);
        canvas.stroke();
    }
}

function drawRSP(canvas, values = arraySPDSaturated, colors = LMSCOLORS, means = LMSMEANS, deviations = LMSDEVNS, magnitudes = LMSMAGNS, norms = LMSNORMS, cones = CONES, correction = 1, y = 200, width = 2) {
    canvas.lineWidth = width;
    initializeCanvasText(canvas, "#000", "right");
    let responseSum = new Array(colors.length).fill(0);
    let valueSum = new Array(colors.length).fill(0);
    let y_n = 0;
    for (let c = 0; c < colors.length; c++) {
        canvas.strokeStyle = colors[c];
        canvas.beginPath();
        canvas.moveTo(15, c * 60 + 65);
        for (let i = 0; i < 126; i++) {
            y_n = Math.min(values[i] * magnitudes[c] * (2.7 ** -(((i - means[c])/deviations[c]) ** 2)), 1);
            canvas.lineTo(i * 10 + 15, c * 60 + 65 - (y * 0.25 * y_n));
            responseSum[c] += y_n;
            if (values[i] != 0) valueSum[c] += 1;
        }
        canvas.stroke();
        canvas.lineTo(1265, c * 60 + 65);
        canvas.fillStyle = colors[c];
        canvas.fill();
        if (valueSum[c] == 0) { responseSum[c] = 0; } // prevent div by zero
        else { responseSum[c] = correction * responseSum[c] * Math.max((valueSum[c] ** -1.1), norms[c]); }
        canvas.fillText(cones[c] + ":" + responseSum[c].toFixed(3), 1265, c * 60 + 49);
    }
    return responseSum;
}

function drawSSC(canvas, colors = LMSCOLORS, means = LMSMEANS, deviations = LMSDEVNS, magnitudes = LMSMAGNS, y = 300, width = 2) {
    canvas.lineWidth = width;
    for (let c = 0; c < colors.length; c++) {
        canvas.strokeStyle = colors[c];
        canvas.beginPath();
        canvas.moveTo(15, y - 49);
        for (let i = 0; i < 126; i++)
            canvas.lineTo(i * 10 + 15, y * (1 - 0.76 * magnitudes[c] * (2.7 ** -(((i - means[c])/deviations[c]) ** 2))) - 49);
        canvas.stroke();
    }
    drawWavelengthAxes(canvas, y, "#000", 2);
}

function drawSPD(canvas, values, color = "#000", colorAxes = "#000", y = 300, width = 2) {
    canvas.lineWidth = width;
    canvas.strokeStyle = color;
    canvas.beginPath();
    canvas.moveTo(15, y - 55);
    for (let i = 0; i < 126; i++)
        canvas.lineTo(i * 10 + 15, y * (1 - values[i] * 0.76) - 49);
    canvas.stroke();
    drawWavelengthAxes(canvas, y, colorAxes, 2);
}

function drawWavelengthAxes(canvas, y = 300, color = "#000", width = 2) {
    canvas.lineWidth = width;
    canvas.strokeStyle = color;
    canvas.beginPath();
    canvas.moveTo(15, 15);
    canvas.lineTo(15, y - 45);
    canvas.lineTo(WIDTH - 15, y - 45);
    canvas.stroke();
    initializeCanvasText(canvas);
    for (let i = 0; i < 7; i++)
        canvas.fillText(i * 50 + 400 + "nm", i * 180 + 100, y - 25);
}

function drawPhoton(canvas, wavelength, x, y, length = 200, amplitude = 75, color = "#000", width = 2) {
    canvas.lineWidth = width;
    canvas.strokeStyle = color;
    canvas.beginPath();
    canvas.moveTo(x, y);
    for (let i = 0; i <= length; i++) {
        canvas.lineTo(x + i, y + amplitude * Math.sin(3.14 * i / length) * Math.sin(i * wavelength));
    }
    canvas.stroke();
}

function getResponses(values = arraySPDSaturated, means = LMSMEANS, deviations = LMSDEVNS, magnitudes = LMSMAGNS, norms = LMSNORMS) {
    let responseSum = new Array(means.length).fill(0);
    let valueSum = new Array(means.length).fill(0);
    let y_n = 0;
    for (let c = 0; c < means.length; c++) {
        for (let i = 0; i < 126; i++) {
            responseSum[c] += values[i] * magnitudes[c] * (2.7 ** -(((i - means[c])/deviations[c]) ** 2));
            if (values[i] != 0) valueSum[c] += 1;
        }
        if (valueSum[c] == 0) { responseSum[c] = 0; } // prevent div by zero
        else { responseSum[c] = responseSum[c] * Math.max((valueSum[c] ** -1.1), norms[c]); }
    }
    return responseSum;
}

function getColor(rgbArray) {
    let r = Math.floor(Math.max(0, Math.min(rgbArray[0], 1)) * 255);
    let g = Math.floor(Math.max(0, Math.min(rgbArray[1], 1)) * 255);
    let b = Math.floor(Math.max(0, Math.min(rgbArray[2], 1)) * 255);
    return `rgb(${r}, ${g}, ${b})`
}

function colorBoxRGB(div, rgbArray) {
    div.style.backgroundColor = getColor(rgbArray);
}

function getNameWavelength(div, wavelength) {
    if (wavelength < 460 || wavelength > 610) { div.style.color = "#fff";
    } else div.style.color = "#000";
    if (wavelength >= 380 && wavelength < 430) { return "Violet"; }
    else if (wavelength >= 430 && wavelength < 500) { return "Blue"; }
    else if (wavelength >= 500 && wavelength < 520) { return "Cyan"; }
    else if (wavelength >= 520 && wavelength < 570) { return "Green"; }
    else if (wavelength >= 570 && wavelength < 580) { return "Yellow"; }
    else if (wavelength >= 580 && wavelength < 630) { return "Orange"; }
    else if (wavelength >= 630 && wavelength < 740) { return "Red"; }
    else { return "None"; }
}

function matrixMultiply(matrixA, matrixB) {
    let result = new Array(matrixA.length).fill(0).map(() => Array(matrixB[0].length).fill(0));
    for (let i = 0; i < matrixA.length; i++)
        for (let j = 0; j < matrixB[0].length; j++)
            for (let k = 0; k < matrixB.length; k++)
                result[i][j] += matrixA[i][k] * matrixB[k][j];
    return result;
}

function vectorMultiply(matrix, vector) {
    let result = new Array(matrix.length).fill(0);
    for (let i = 0; i < matrix.length; i++)
        for (let j = 0; j < vector.length; j++)
        result[i] += matrix[i][j] * vector[j];
    return result;
}

function initializeCanvas(canvasID, height, width = WIDTH) {
    const canvas = document.getElementById(canvasID).getContext("2d");
    canvas.canvas.width = width;
    canvas.canvas.height = height;
    return canvas;
}

function initializeCanvasText(canvas, color = "#000", horizontal = "center", vertical = "middle", font = "25px JetBrains Mono") {
    canvas.font = font;
    canvas.textBaseline = vertical;
    canvas.textAlign = horizontal;
    canvas.fillStyle = color;
}

function initializeProgressBar(bar, maximum, value) {
    bar.max = maximum;
    bar.value = value;
}

function initializeSliders(slider, minimum, maximum, step, value) {
    slider.min = minimum;
    slider.max = maximum;
    slider.step = step;
    slider.value = value;
}

function identityTransform(array) {
    return array;
}</script><style>progress{width:5rem}.cBox{float:right;text-align:center;vertical-align:middle;border:.0625rem solid #000;width:4rem;height:2.5rem;margin:0 .5rem;font:.75rem/2.5rem JetBrains Mono}.linkSwitch{cursor:pointer;text-decoration-style:dotted}</style></article></main><footer><a href=https://ekunazanu.foo/more#Terms_of_Use>© 2025</a> <a href=https://ekunazanu.foo/about>ekunazanu</a> · <a rel="noopener nofollow noreferrer" href=https://creativecommons.org/licenses/by/4.0/ target=_blank>CC BY 4.0</a> · <a rel="noopener nofollow noreferrer" href=https://github.com/ekunazanu/ekunazanu.foo target=_blank>Source</a></footer>