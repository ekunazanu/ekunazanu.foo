<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content=ekunazanu name=author><meta content="A primer on Bloom Filters, Count-min Sketch, and HyperLogLog." name=description><meta content="Probabilistic Data Structures" property=og:title><meta content=article property=og:type><meta content="A primer on Bloom Filters, Count-min Sketch, and HyperLogLog." property=og:description><meta content=https://ekunazanu.foo/lab/probabilistic-data-structures/ property=og:url><meta content=https://ekunazanu.foo/thumbnails/lab.die.svg.png property=og:image><meta content="A die showing the face with five dots." property=og:image:alt><meta content=image/png property=og:image:type><meta content=1200 property=og:image:width><meta content=900 property=og:image:height><meta content=en_US property=og:locale><meta content=ekunazanu.foo property=og:site_name><title>Probabilistic Data Structures ~ ekunazanu.foo</title><link href=https://ekunazanu.foo/lab/probabilistic-data-structures/ rel=cannonical><link href=https://ekunazanu.foo/atom.xml rel=alternate type=application/atom+xml><link href=https://ekunazanu.foo/misc/main.css rel=stylesheet><link href=https://ekunazanu.foo/misc/favicon.png rel=icon><meta content=Zola name=generator><body><nav><ul><li><h2><a href=https://ekunazanu.foo>ekunazanu.foo</a></h2><li><a href=https://ekunazanu.foo/log>Log</a><li><a href=https://ekunazanu.foo/lab>Lab</a> ⟶</ul></nav><div class=print>https://ekunazanu.foo</div><main><article><h1>Probabilistic Data Structures</h1><p>Probabilistic data structures are what their names suggest — these are <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Data_structure target=_blank>data structures</a> that give probabilistic answers to queries. What is lost in <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Accuracy_and_precision#/media/File:Accuracy_and_precision.svg target=_blank>precision</a> however, is more than made up for in extremely efficient use of memory and/or computational resources.<h2 id=Hashing>Hashing</h2><p>A hash function is simply a mathematical function that maps an input to an output. In practice however, the output of hash functions have certain properties:<ul><li><strong>Deterministic</strong> — Hash functions produce the same output for the same input.<li><strong>Fixed Length</strong> — For any input, most hash functions produce a fixed length output.<li><strong>Pseudorandom</strong> — Most hash functions produce a hash that is <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Pseudorandomness target=_blank>pseudorandom</a>; hash outputs appear and behave random, but are ultimately deterministic.<li><strong>One-Way</strong> — For most hash functions, it is difficult to determine the input just from the output. This is useful for <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Cryptographic_hash_function target=_blank>cryptographic applications</a>; this is not necessarily useful for probabilistic data structures.<li><strong>Collision Resistant</strong> — Despite having fixed length outputs, hash functions are designed to minimize cases where two inputs output the same hash. Collisions are not impossible however, because of the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Pigeonhole_principle target=_blank>limited output space</a>.</ul><p><input id=hashBoxInput value=hello><button id=hashBoxButton>Hash</button><br> Hash: <code id=hashBoxOutput>44</code><p>Some of these properties form the basis for most probabilistic data structures.<h2 id=Bloom_Filters>Bloom Filters</h2><p>Bloom filters are one of the most popular probabilistic data structures. These are used to check for membership in sets or multisets — or in simpler words, they are used to check if an element is present in a set or not. Bloom filters cannot predict the membership of an element with absolute certainty, but it can report with certainty if it does <strong>not</strong> exist in a set. And it does it for big datasets using very little space.<h3 id=Approaches>Approaches</h3><p>Rather than outright disclosing how bloom filters work, it is much more effective to discuss possible solutions first. It will help build a natural intuition as to why bloom filters are a better approach — at least when accuracy is not a big priority.<p>Consider these elements:<div class=setContainer id=setContainerStatic></div><p>We need to know if <code>hello</code> is in the multiset. One possible solution is to store the entire multiset, and then performing a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Linear_search target=_blank>linear search</a> — going through each element one-by-one and checking if it exists.<div class=setContainer id=setContainerLinear></div><input id=setInputLinear value=hello><button id=setButtonLinear>Search</button><br><span id=setOutputLinear>Element state unknown.</span><p>Or if you’ve studied computer science, the multiset can be stored in <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Lexicographic_order target=_blank>lexicographic order</a> and then a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Binary_search_algorithm target=_blank>binary search</a> can be performed.<div class=setContainer id=setContainerBinary></div><input id=setInputBinary value=hello><button id=setButtonBinary>Search</button><br><span id=setOutputBinary>Element state unknown.</span><p>That makes querying faster, but the space required to store the elements remains the same. One way to reduce the space used could be by storing only the unique values and purging all the duplicates. Rephrased formally, the multiset can be made into a set:<div class=setContainer id=setContainerUnique></div><input id=setInputUnique value=hello><button id=setButtonUnique>Search</button><br><span id=setOutputUnique>Element state unknown.</span><p>While this is a decent solution, it can be made better. The space required is roughly dependent on the number of elements, and the size of each element. What if, instead of storing all the individual elements, only the hashes of the elements are stored instead? In this case, we will need to search for <code>44</code> — the hash for <code>hello</code>.<div class=setContainer id=setContainerHashes></div><input id=setInputHashes value=hello><button id=setButtonHashes>Search</button><br> Hash: <code id=setOutputHashesHash>44</code> <span id=setOutputHashes>Element state unknown.</span><p>Using hashes is arguably better than storing individual long variable-length elements. But it can be optimized even further. Since most hashing functions always produce a fixed length output for any input, it can be exploited to decrease the amount of space needed to store the hashes even more.<p>The above hash function produces an output between <code>0</code> and <code>255</code>. Instead of allocating arrays to store all the individual hashes, a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Bit_array target=_blank>bit-array</a> of size of 256-bits can be created to represent the existing hashes. All the bits are initially set to zero. A bit is set to one only if its corresponding hash is in the set.<p><canvas id=bfCanvasCompare></canvas><p>For example if the output hash is <code>44</code>, the 44th bit is flipped to one.<p><canvas id=bfCanvasAdd></canvas> <input id=bfInputAdd value=hello><button id=bfButtonAdd>Add</button><br> Hash: <code id=bfOutputAddHash>44</code> <span id=bfOutputAddMessage></span><details><summary>Bit ordinality</summary> <p>The n-th bit is in reference to a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Zero-based_numbering target=_blank>zero based indexing</a> system. Because the range of the hash is from 0 to 255, instead of from 1 to 256, the ‘first’ bit is considered as the 0-th bit and the ordinality of all the bits are considered as one lesser than their ‘actual’ ordinality.</p></details><p>It should be obvious that using a bit-array is analogous to storing the hash itself. But while in the previous approach multiple bits were needed to store the individual hashes, the new bit-array approach requires only one bit per hash.<p>This is what a bloom filter is. It is fundamentally a bit-array, where a bit corresponds to an individual hash output — and that hash output corresponds to an element (or more) in the set. But in ‘real’ bloom filters, multiple hash functions are used. More about why that is, is discussed later.<h3 id=Queries>Queries</h3><p>It is apparent that checking for membership of an element simply involves verifying if the hash exists — checking if the corresponding bit in the bit-array is set to one. So to query an element: It is first hashed, and then the bit corresponding to its hash is checked to see if it is set (to one).<p><canvas id=bfCanvasQuery></canvas> <input id=bfInputQuery value=hello><button id=bfButtonQuery>Search</button><br> Hash: <code id=bfOutputQueryHash>44</code> <span id=bfOutputQueryMessage></span><h3 id=Hash_Collisions>Hash Collisions</h3><p>While hash functions are designed to be collision resistant, they are not collision proof. Sometimes two elements may have the same hash. In such cases, an element that was added may have the same hash as a different element being queried, leading to a false positive.<p>For example, <code>hello</code> having the hash <code>44</code> is added in the bloom filter. Another word, <code>foo</code> might have the same hash <code>44</code>. If the bloom filter is queried for <code>foo</code>, it would wrongly report that <code>foo</code> exists in the set since the 44th bit in the bit-array is already set to one by a different word — <code>hello</code>.<p><canvas id=bfCanvasCollision></canvas> <input id=bfInputCollisionAdd value=hello><button id=bfButtonCollisionAdd>Add</button><br> <input id=bfInputCollisionQuery value=foo><button id=bfButtonCollisionQuery>Search</button><br> Hash: <code id=bfOutputCollisionHash>44</code> <span id=bfOutputCollisionMessage></span><p>To reduce the probability of collisions, multiple hash functions can be used for each element. In that case, querying an element will return true only if <strong>all</strong> bits corresponding to the hashes are one.<p><canvas id=bfCanvasMultiple></canvas> <input id=bfInputMultipleAdd value=hello><button id=bfButtonMultipleAdd>Add</button><br> <input id=bfInputMultipleQuery value=foo><button id=bfButtonMutlipleQuery>Search</button><br> <input id=bfInputMultipleSlider type=range><br> Hash depth: <span id=bfOutputMultipleHashDepth>3</span><br> Hash: <code id=bfOutputMultipleHash>44, 242, 77</code> <span id=bfOutputMultipleMessage></span><details><summary>Universal hashing</summary> <p>The hash depth refers to the number of hash functions used. The output of the hash functions should be randomly distributed and should not be correlated to each other. Formally, the hash functions should be selected from a <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Universal_hashing target=_blank>universal family</a>, and should ideally be <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Pairwise_independence target=_blank>pairwise independent</a>. These assumptions are used when calculating the probability of collisions when using multiple hash functions.</p></details><p>The probability of two elements having the same hash outputs is <code>1/m</code> where <code>m</code> is the size of the bloom filter. However, if two hash functions are used for every element, the probability of two elements having the same hash outputs is roughly <code>1/m * 1/m</code>. In general, using more hashing functions exponentially decreases the probability that <strong>all</strong> the hash outputs of two elements will collide.<p>However using too many hashing functions can also increase the false positive rate. It might feel counter-intuitive, especially right after showing it <em>decreases</em> false positives, but consider this: The bloom filter is finite. The more the number of hash functions, the higher the probability that it fills up quickly and most bits are set to one. When querying from a bloom filter where most bits are set to one, the higher the probability that <em>any</em> query results in a positive — even if the element is not in the set.<p>In the extreme case when all the bits in a bloom filter are set to one, the bloom filter would <strong>always</strong> report positive for membership — regardless of whether the element actually exists in the set.<p><canvas id=bfCanvasSaturated></canvas> <input id=bfInputSaturatedQuery value=foo><button id=bfButtonSaturatedQuery>Search</button><br> Hash: <code id=bfOutputSaturatedHash>44, 38, 180</code> <span id=bfOutputSaturatedMessage></span><p>Other than using a large number of hashing functions, a bloom filter can also be quickly saturated if the number elements to be hashed (added) is huge. The only solution to decreasing the number of false positives then, is by increasing the size of the bloom filter itself. Increasing the size of the bloom filter bit-array equates to a larger output space for the hash functions, reducing the probability for collisions.<p><canvas id=bfCanvasBigger></canvas> <input id=bfInputBiggerAdd value=hello><button id=bfButtonBiggerAdd>Add</button><button id=bfButtonBiggerAddRandom>Add Random</button><br> <span id=bfOutputBiggerMessage style=display:none></span> <code id=bfOutputBiggerHash style=display:none></code><p>In effect, the false positive rate is also dependent on the <strong>size of the bloom filter</strong> and the <strong>number of (unique) elements</strong> to be added.<h3 id=Space_Efficiency>Space Efficiency</h3><p>The false positive rate depends on the number of hash functions used per element, the number of elements hashed/added, and the size of the bloom filter. Conversely, the size of the bloom filter and the ideal number of hash functions depends on the tolerance for false positives and the number elements to be added.<p>More precisely, the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions target=_blank>optimal size for a bloom filter</a> is <code>-2.08·ln(p)·n</code> bits, where <code>p</code> is the tolerance for the false positive rate and <code>n</code> is the number of unique elements one expects to observe. The <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions target=_blank>optimal number of hash functions</a> is <code>ln(2)·(m/n)</code>, where <code>m</code> is the size of the bloom filter and <code>n</code> is the number of expected elements. Thomas Hurst visualizes how the factors affect each other in his <a rel="noopener nofollow noreferrer" href=https://hur.st/bloomfilter/ target=_blank>bloom filter calculator</a>.<h3 id=Deletion>Deletion</h3><p>Deletions can be achieved by unsetting the bits corresponding to the hash of the element to be deleted, to zero. But if one of the bits was previously set by some different element, then checking membership for that element would lead to a false negative.<p><canvas id=bfCanvasDeletion></canvas> <input id=bfInputDeletionAdd value=hello><button id=bfButtonDeletionAdd>Add</button><br> <input id=bfInputDeletionRemove value=foo><button id=bfButtonDeletionRemove>Remove</button><br> <input id=bfInputDeletionQuery value=hello><button id=bfButtonDeletionQuery>Search</button><br> Hash: <code id=bfOutputDeletionHash>44, 242, 77</code> <span id=bfOutputDeletionMessage></span><br><p>The general consensus is to forbid deletions in bloom filters to remove the possibility of getting false negatives.<h2 id=Count-Min_Sketch>Count-Min Sketch</h2><p>A count-min sketch is a probabilistic data structure that calculates the multiplicity (the number of occurrences) of elements in a multiset. It is what a bloom filter would have been if it was a frequency table instead.<h3 id=Counting_Bloom_Filter>Counting Bloom Filter</h3><p>Count-min sketches are very similar to bloom filters, so it’s helpful to start off with a bloom filter.<p><canvas id=bfCanvasCounting></canvas> <input id=bfInputCountingAdd value=hello><button id=bfButtonCountingAdd>Add</button><br> <input id=bfInputCountingQuery value=hello><button id=bfButtonCountingQuery>Search</button><br> Hash: <code id=bfOutputCountingHash>44, 242, 77</code> <span id=bfOutputCountingMessage></span><br><p>Now, instead of using one bit per hash, what if a few more bits (per hash) were used?<p><canvas id=cmsCanvasComparisonStatic></canvas><p>A way to utilize the extra bits is by using them as ‘counters’ to store information about frequency — the bit-counter can be incremented by one whenever a hash (an element) is added. This expands the ability of the array from being able to only store information about the <strong>existence</strong> of an element to store information about its <strong>frequency</strong> as well.<p><canvas id=cmsCanvasComparison></canvas> <input id=cmsInputComparisonAdd value=hello><button id=cmsButtonComparisonAdd>Add</button><br> <input id=cmsInputComparisonQuery value=hello><button id=cmsButtonComparisonQuery>Search</button><br> Hash: <code id=cmsOutputComparisonHash>44, 242, 77</code><br> Bloom Filter: <span id=cmsOutputComparisonMessage>-</span><br> Counting Bloom Filter: <span id=cmsOutputComparisonValues>-</span><br><p>The array on top is a bloom filter, which only only be used for binary queries — that is, whether it exists or not. The array below the bloom filter is a counting bloom filter which can give slightly richer information in the form of frequency estimates.<p>Hash collisions are again possible in counting bloom filters, which increase the counters of other elements. The frequency of an element is calculated by taking the minimum of the values in the hash counters to minimize the overestimation. However, as there is no way to under-count, the minimum of the values is the necessarily the upper bound of the estimate — the true frequency is guaranteed to be equal or lower than the estimate.<p>As an example, try adding both <code>hello</code> and <code>foo</code> and notice how the 44th counter is affected. The counter increases to two. If the 44th counter is the only counter used for calculating the estimate, it would over-count the frequency of both elements. However, using more hashes and counters can decrease the probability of over-counting — but only when the minimum of the counters is used for estimation.<p><canvas id=cmsCanvasMain></canvas> <input id=cmsInputMainAdd value=hello><button id=cmsButtonMainAdd>Add</button><br> <input id=cmsInputMainQuery value=hello><button id=cmsButtonMainQuery>Search</button><br> Hash: <code id=cmsOutputMainHash>44, 242, 77</code><br> Counters: <span id=cmsOutputMainValues>0, 0, 0</span><br> Frequency estimate: <span id=cmsOutputMainEstimate>0</span> <span id=cmsOutputMainMessage style=display:none></span><p>The only possible way counters can under-count is when they <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Integer_overflow target=_blank>overflow</a> and reset back to zero. Here, four bits are used per hash so the counter will overflow when the count exceeds fifteen. This is not a big issue however, since the number of bits per counter can easily be increased a little — even thirty-two bits for each counter is enough for storing frequency estimates up to more than four billion.<h3 id=Hash_Collisions-1>Hash Collisions</h3><p>To reduce over-counting, hash collisions should be reduced. Two approaches used in bloom filters can be applied: By increasing the size of the array, and using multiple hash functions. The solutions might look plausible on the surface because of the counting bloom filter’s similarities to a bloom filter, but that is not the case — or at least, it is not that simple.<p>The first solution is easy to verify and is intuitive to follow. Increasing the size of the array increases the range of the hash functions, reducing collisions. Just like bloom filters, discussed above. The second approach however, does reduce errors. In fact it leads to <em>slightly</em> higher errors.<p>It’s important to mention that in both bloom filters and counting bloom filters, increasing the number of hash functions per element increases the probability of a collision. But in the case of bloom filters, any hash collision did not change the value of a bit in the bloom filter itself — it would be set to one regardless. In fact hash collisions <a rel="noopener nofollow noreferrer" href=https://stackoverflow.com/a/72509014 target=_blank>decrease overall error</a> by preventing the bloom filter from getting saturated too quickly.<p>Compare that to a counting bloom filter, where every collision increases the value of the counter by one. Having more hashing function increases the probability of collisions, and therefore, over-counting. The probability of over-counting an element only increases as the number of hash functions per element increases.<p>Notice how collisions do not affect the bits that are already set in the bloom filter, but affects the bits of the counting bloom filter:<p><canvas id=cmsCanvasComparisonErrors></canvas> <input id=cmsInputComparisonErrorsAdd value=hello><button id=cmsButtonComparisonErrorsAdd>Add</button><br> <code id=cmsOutputComparisonErrorsHash style=display:none>44, 242, 77</code> <span id=cmsOutputComparisonErrorsMessage style=display:none> </span> <span id=cmsOutputComparisonErrorsValues style=display:none>0, 0, 0</span> <input id=cmsInputComparisonErrorsSlider type=range><br> Hash depth: <span id=cmsOutputComparisonErrorsHashDepth>32</span><br><p>The solution to reducing errors then would be to increase the size of the array and to minimize the number hash functions. And while that is acceptable, there are better ways to go about it.<h3 id=Disjoint_Hash_Ranges>Disjoint Hash Ranges</h3><p>There is an upside in using multiple hash functions — while querying the frequency of an element, it gets exponentially less probable that the <strong>all</strong> hashes of <strong>one</strong> element will collide. The downside to using more hash functions is that it increases <strong>overall</strong> collisions, which leads to over-counting and less precise estimates.<p>A simple way to resolve the downside is by assigning the output of each hash function to separate output spaces. This prevents from collisions between hash functions. That is, while collisions from different elements having the same hashes are possible, collisions between different hash functions are now impossible.<p><canvas id=cmsCanvasDifferentRange></canvas><p>The resulting data structure is a count-min sketch. It can also be thought of as a two dimensional array with <code>w</code> columns and <code>d</code> rows — where <code>d</code> is the total number of hash functions and <code>w</code> is the range for the hash outputs. Each hash function outputs to their respective row, and the hash functions are again assumed to be pairwise independent.<p>Here, the count-min sketch is thirty two counters wide and eight hashes deep.<p><canvas id=cmsCanvasSketch></canvas> <input id=cmsInputSketchAdd value=hello><button id=cmsButtonSketchAdd>Add</button><br> <input id=cmsInputSketchQuery value=hello><button id=cmsButtonSketchQuery>Search</button><br> Hash: <code id=cmsOutputSketchHash>12, 50, 77, 122, 159, 176, 195, 238</code><br> Counters: <span id=cmsOutputSketchValues>0, 0, 0, 0, 0, 0, 0, 0</span><br> Frequency estimate: <span id=cmsOutputSketchEstimate>0</span><br> <span id=cmsOutputSketchMessage style=display:none></span><p>The count-min sketch is capable of answering more than simple frequency queries. It can also respond to <a href="https://cs.stanford.edu/~rishig/courses/ref/l12b.pdf#page=5" rel="noopener nofollow noreferrer" target=_blank>range and inner-product queries</a>.<h3 id=Space_Efficiency-1>Space Efficiency</h3><p>Similar to bloom filters, the space required by a count-min sketch depends on <a href="http://dimacs.rutgers.edu/~graham/pubs/papers/cmsoft.pdf#page=4" rel="noopener nofollow noreferrer" target=_blank>the tolerance for error and the number of expected elements</a>. The optimal width of the array <code>w</code> is <code>2n/ε</code> and depth <code>d</code> is <code>log(δ)/log(1/2)</code> — where <code>n</code> is the number of total elements, <code>ε</code> defines the bounds for collisions, and <code>δ</code> is the probability the estimates exceeds those bounds.<h2 id=HyperLogLog>HyperLogLog</h2><p>HyperLogLog is another probabilistic data structure, used to approximate the cardinality (or total number of distinct elements) of a multiset. It is different from a bloom filter and a count-min sketch, and relies on the pseudorandomness of hash functions to estimate cardinalities.<h3 id=Probability>Probability</h3><p>Consider this thought experiment: Take a few coins where each coin has an equal probability of landing on heads or tails, and toss them all at once. The probability that the first coin is heads is half, or 1/2. The probability that both the first and second coin are heads is 1/4. The probability that all the first three first coins are heads is 1/8. In general, the probability that the first n coins are heads is one in 2^n.<p><canvas id=hllCanvasCoinProbability></canvas><p>Phrased alternatively, roughly 2^n total tosses are required to observe a maximum of n consecutive leading heads at the beginning of the coin array.<p><canvas id=hllCanvasCoinObservation></canvas> Leading heads: <span id=hllOutputCoinObservationZeros>0</span><br> Max. leading heads: <span id=hllOutputCoinObservationZerosMax>0</span><br> Total tosses: <span id=hllOutputCoinObservationTosses>0</span><br> <button id=hllButtonCoinObservationToss>Toss coins</button><button id=hllButtonCoinObservationReset>Reset count</button><p>Conversely, if shown n consecutive heads at the beginning of the sequence, it can be estimated that the coins were tossed roughly 2^n times.<p><canvas id=hllCanvasCoinEstimation></canvas> Leading heads: <span id=hllOutputCoinEstimationZeros>0</span><br> Max. leading heads: <span id=hllOutputCoinEstimationZerosMax>0</span><br> Estimated tosses: <span id=hllOutputCoinEstimationEstimate>0</span><br> Total tosses: <span id=hllOutputCoinEstimationTosses>0</span><br> <button id=hllButtonCoinEstimationToss>Toss coins</button><button id=hllButtonCoinEstimationReset>Reset count</button><p>The maximum number of consecutive leading heads provides a rough estimate for the number of times the coins were tossed.<p>This is the fundamental principle behind HyperLogLog. Coins are replaced with bits — a hash function is chosen such that output is pseudorandom. Then each bit of the hash acts as an unbiased coin, having an equal probability of being 0 or 1. Analogous to the total number of tosses, the total number of elements can be estimated using the longest run of consecutive leading zeroes of their hashes.<p><canvas id=hllCanvasBits></canvas> Leading zeros: <span id=hllOutputBitsZeros>0</span><br> Max. leading zeros: <span id=hllOutputBitsZerosMax>0</span><br> Estimated cardinality: <span id=hllOutputBitsEstimate>0</span><br> Actual cardinality: <span id=hllOutputBitsCardinality>0</span><br> <input id=hllInputBitsAdd value=hello><button id=hllButtonBitsAdd>Add</button><br> <button id=hllButtonBitsRandom>Add random</button><button id=hllButtonBitsReset>Reset count</button><p>Since hashes are deterministic, duplicate elements will yield the same hashes and would not affect the cardinality calculation. So HyperLogLog estimates the number of <strong>distinct</strong> elements in a multiset.<h3 id=Limitations>Limitations</h3><p>There is a glaring flaw in this approach however. The gaps between the approximations double every time an extra consecutive zero is observed — it can only provide estimates that are powers of two, and nothing in between. Second, a hash output may have a lot of consecutive zeros at the beginning simply owing to chance, skewing the estimate.<p>To mitigate these problems, multiple counters that store the longest run of zeroes for different subsets of the multiset can be used — instead of storing one counter that stores the longest run of zeroes for the entire multiset. The values can then be averaged to find a more precise cardinality estimate.<h3 id=Buckets>Buckets</h3><p>A multiset is segregated into different subsets using ‘<a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Hash_table#/media/File:Hash_table_3_1_1_0_1_0_0_SP.svg target=_blank>buckets</a>’. In HyperLogLog, a bucket is just a counter for storing the length of the longest run of zeroes of hashes for some particular subset of elements. The first <code>b</code> bits of the hash of an element are reserved for selecting the bucket, and the remaining bits are used for finding the leading zeros. The number of leading zeroes are then used to compute the cardinality estimate for that subset. Cardinality for the entire multiset can be calculated by finding the average of the individual estimates using the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Harmonic_mean target=_blank>harmonic mean</a>.<p>Here, the bucket is chosen from the first four bits of the hash.<p><canvas id=hllCanvasBucket></canvas> <canvas id=hllCanvasBucketCounters></canvas> Bucket: <span id=hllOutputBucketNumber>0</span><br> Leading zeros: <span id=hllOutputBucketZeros>0</span><br> Max. leading zeros: <span id=hllOutputBucketZerosMax>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br> Estimated cardinalities: <span id=hllOutputBucketEstimates>1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1</span><br> Average estimate: <span id=hllOutputBucketMean>0</span><br> Actual cardinality: <span id=hllOutputBucketCardinality>0</span><br> <input id=hllInputBucketAdd value=foo><button id=hllButtonBucketAdd>Add</button><br> <button id=hllButtonBucketRandom>Add random</button><button id=hllButtonBucketReset>Reset count</button><details open><summary>Averaging estimates</summary> <p>The addition of new buckets ‘spreads’ the cardinality over all the buckets. However, the bucket quantity information is lost during averaging, and the estimates gets scaled down by the number of buckets. To counteract this, the harmonic mean is scaled by the number of buckets. That is, if there are <code>m</code> buckets, the estimate is <code>m * mean</code>.</p> <p>The harmonic mean is used for averaging because it reduces the influence of large outliers and has shown to be more accurate.</p></details><p>However, even with the corrective measures, there is a <a rel="noopener nofollow noreferrer" href=https://www.moderndescartes.com/essays/hyperloglog/#loglog target=_blank>predictable bias</a> towards larger estimates. Scaling the average by a correction factor counteracts this bias. This brings down the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Standard_error target=_blank>error</a> to 1.04/√m, where m is the number of buckets.<p>Thirty two buckets are used here, and so the standard error is approximately 0.18.<p><canvas id=hllCanvasMain></canvas> <canvas id=hllCanvasMainCounters></canvas> Bucket: <span id=hllOutputMainNumber>0</span><br> Leading zeros: <span id=hllOutputMainZeros>0</span><br> <span id=hllOutputMainZerosMax style=display:none></span> <span id=hllOutputMainEstimates style=display:none></span> Average estimate: <span id=hllOutputMainMean>0</span><br> Scaled estimate: <span id=hllOutputMainScaled>0</span><br> Actual cardinality: <span id=hllOutputMainCardinality>0</span><br> <input id=hllInputMainAdd value=foo><button id=hllButtonMainAdd>Add</button><br> <button id=hllButtonMainRandom>Add random</button><button id=hllButtonMainReset>Reset count</button><br> <button id=hllButtonMainRandomK>Add 500 random elements</button><details open><summary>Correction factor</summary> <p>The correction factor ranges between 0.672 and 0.723, depending on the number of buckets. It is approximately equal to <code>0.723/(1+1.079/m)</code> where <code>m</code> is the number of buckets.</p></details><p>This is HyperLogLog. A very simple and elegant data structure that is also ridiculously efficient. Adding elements involves hashing them and storing their longest run of leading zeroes in buckets. Estimating the cardinality involves finding the harmonic mean of the estimates, scaled by the number of buckets and a correction factor.<h3 id=Space_Efficiency-2>Space Efficiency</h3><p>The only thing needed (to store) for calculating the cardinality are the buckets. So the total amount of space required is the number of buckets times the size of each bucket. The number of buckets depends on the degree of accuracy required — the error rate is inversely proportional to the square root of the number of buckets. More buckets lead to more accurate estimates and vice versa.<p>The size of each bucket depends on the largest number that must be stored in the bucket (before it overflows). A five-bit bucket can store numbers from zero to thirty-one. A hash with thirty-one leading zeroes in a hash suggests roughly two billion unique elements were hashed. So to store cardinalities of up to two billion unique elements, the size of each bucket only needs to be five bits. In general, to store cardinality of <code>n</code> unique elements, the size of each bucket needs to be <code>log(log(n))</code> bits. That is also where its name comes from.<p><canvas id=hllCanvasLogSpace></canvas><p>For example, HyperLogLog is able to estimate cardinalities of more than a billion unique elements with an an error of 2% using 2500 five-bit buckets — only 1.5 kB of memory. Or alternatively, just 0.25 kB for an error of 5% using 400 buckets.<h2 id=Other_Data_Structures>Other Data Structures</h2><p>There are lots of other probabilistic data structures that trade accuracy for efficiency. <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Cuckoo_filter target=_blank>Cuckoo filters</a> and <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Quotient_filter target=_blank>quotient filers</a> are probabilistic data structures used for membership queries, in addition to bloom filters. Estimating distinct elements can be done via <a rel="noopener nofollow noreferrer" href=https://doi.org/10.1145/78922.78925 target=_blank>linear counting</a> — like HyperLogLog — but the underlying principle is similar to bloom filters. Rank can be approximated using <a rel="noopener nofollow noreferrer" href=https://doi.org/10.48550/arXiv.1902.04023 target=_blank>t-digests</a>, or <a rel="noopener nofollow noreferrer" href=https://doi.org/10.48550/arXiv.1603.05346 target=_blank>KLL sketches</a>. Similarities can be estimated using <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Locality-sensitive_hashing target=_blank>LSH</a>, <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/MinHash target=_blank>MinHash</a>, and <a rel="noopener nofollow noreferrer" href=https://doi.org/10.1145/509907.509965 target=_blank>SimHash</a>.<p>There are other probabilistic data structures too, each with their own advantages and disadvantages. But the trade off is similar in all cases — precision for efficiency.<hr><h2 id=References>References</h2><ul><li>Florian Hartmann: <a rel="noopener nofollow noreferrer" href=https://florian.github.io/bloom-filters/ target=_blank>Bloom Filters</a><li>Eric Crahen: <a rel="noopener nofollow noreferrer" href=https://crahen.github.io/algorithm/stream/count-min-sketch-point-query.html target=_blank>Count-Min Sketching, Configuration & Point-Queries</a><li>Engineering at Meta: <a rel="noopener nofollow noreferrer" href=https://engineering.fb.com/2018/12/13/data-infrastructure/hyperloglog/ target=_blank>HyperLogLog in Presto: A significantly faster way to handle cardinality estimation</a></ul><script>// A lot of this code can be refactored to follow the DRY principles
// But this is the first time I am writing JS and learning as I go
// So this code might look very ugly; if you think it is the case
// send PRs, since I am too lazy to return back to refactor it myself

// hash function
const encoder = new TextEncoder();
async function getHash(str) {
    const hashBuffer = await crypto.subtle.digest("SHA-256", encoder.encode(str));
    const hashArray = new Uint8Array(hashBuffer);
    return hashArray;
}

// update hash
const hashBoxButton = document.getElementById("hashBoxButton");
hashBoxButton.onclick = async() => {
    const hashBoxInput = document.getElementById("hashBoxInput").value;
    const hash = await getHash(hashBoxInput);
    document.getElementById("hashBoxOutput").innerHTML = hash[0];
}

// initialize set lists
const setArrayMain = ["world", "firm", "bat", "if", "glance", "analysis", "reasonable", "resident", "verdict", "world", "snub", "greet", "snub", "half", "speed", "exception", "speed", "helmet", "theorist", "please", "operational", "hello", "nursery", "background", "appreciate", "congress", "verdict", "dictionary", "current", "nursery", "snub", "piece", "dilute", "elapse", "congress", "verdict", "confusion", "fan", "breast", "sting", "disagreement", "helmet", "tape"];
const setArrayHashes = [4, 17, 23, 32, 33, 35, 44, 47, 50, 52, 56, 61, 72, 77, 83, 86, 93, 117, 132, 137, 139, 147, 151, 161, 162, 187, 202, 213, 226, 231, 243, 244];
const setArraySorted = setArrayMain.toSorted();
const setArrayUnique = [... new Set(setArraySorted)];

// append lists to page
document.getElementById("setContainerStatic").innerHTML = setArrayMain.join(" ");
document.getElementById("setContainerLinear").innerHTML = setArrayMain.map((word, index) => `<span id="setSpanLinear-${index}">${word}</span>`).join(" ");
document.getElementById("setContainerBinary").innerHTML = setArraySorted.map((word, index) => `<span id="setSpanBinary-${index}">${word}</span>`).join(" ");
document.getElementById("setContainerUnique").innerHTML = setArrayUnique.map((word, index) => `<span id="setSpanUnique-${index}">${word}</span>`).join(" ");
document.getElementById("setContainerHashes").innerHTML = setArrayHashes.map((word, index) => `<span id="setSpanHashes-${index}">${word}</span>`).join(" ");

function setButtonStatus(button, enabled) {
    if (enabled) {
        button.innerHTML = "Searching";
        button.disabled = true;
        button.style.pointerEvents = "none"
    } else {
        button.innerHTML = "Search";
        button.disabled = false;
        button.style.pointerEvents = "auto"
    }
}

// linear search

async function linearSearch(setContainer, target, setArray, setOutput, button) {
    setButtonStatus(button, true);
    var children = document.getElementById(setContainer).children;
    for (let child of children) {child.classList.remove("highlight", "found");};
    for (let i = 0; i < setArray.length; i++) {
        const currentWord = document.getElementById(`setSpanLinear-${i}`);
        currentWord.classList.add("highlight");
        await new Promise(resolve => setTimeout(resolve, 200));
        if (setArray[i] === target) {
            currentWord.classList.remove("highlight");
            currentWord.classList.add("found");
            document.getElementById(setOutput).innerHTML = "<b>Element found.</b>";
            setButtonStatus(button, false);
            return true;
        }
        currentWord.classList.remove("highlight");
    }
    document.getElementById(setOutput).innerHTML = "Element not found.";
    setButtonStatus(button, false);
    return false;
}

// binary search
async function binarySearch(setContainer, target, setArray, setOutput, setFunctionType, button) {
    setButtonStatus(button, true);
    var tmpWords = document.getElementById(setContainer).children;
    for (let child of tmpWords) {child.classList.remove("highlight", "found");};
    let left = 0;
    let right = setArray.length - 1;
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        const currentWord = document.getElementById(`setSpan${setFunctionType}-${mid}`);
        currentWord.classList.add("highlight");
        await new Promise(resolve => setTimeout(resolve, 500));
        if (setArray[mid] === target) {
            currentWord.classList.remove("highlight");
            currentWord.classList.add("found");
            document.getElementById(setOutput).innerHTML = "<b>Element found.</b>";
            setButtonStatus(button, false);
            return true;
        }
        currentWord.classList.remove("highlight");
        if (setArray[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    document.getElementById(setOutput).innerHTML = "Element not found.";
    setButtonStatus(button, false);
    return false;
}

const setButtonLinear = document.getElementById("setButtonLinear");
setButtonLinear.onclick = async() => {
    var target = document.getElementById("setInputLinear").value.trim();
    if (!target) return;
    await linearSearch("setContainerLinear", target, setArrayMain, "setOutputLinear", setButtonLinear);
};

const setButtonBinary = document.getElementById("setButtonBinary");
setButtonBinary.onclick = async() => {
    var target = document.getElementById("setInputBinary").value.trim();
    if (!target) return;
    await binarySearch("setContainerBinary", target, setArraySorted, "setOutputBinary", "Binary", setButtonBinary);
};

const setButtonUnique = document.getElementById("setButtonUnique");
setButtonUnique.onclick = async() => {
    var target = document.getElementById("setInputUnique").value.trim();
    if (!target) return;
    await binarySearch("setContainerUnique", target, setArrayUnique, "setOutputUnique", "Unique", setButtonUnique);
};

const setButtonHashes = document.getElementById("setButtonHashes");
setButtonHashes.onclick = async() => {
    var target = document.getElementById("setInputHashes").value.trim();
    if (!target) return;
    target = await getHash(target);
    document.getElementById("setOutputHashesHash").innerHTML = target[0];
    await binarySearch("setContainerHashes", target[0], setArrayHashes, "setOutputHashes", "Hashes", setButtonHashes);
};

// initialise canvas
function drawCanvas(canvasID, width = 1280, height = 640) {
    var canvasObject = document.getElementById(canvasID).getContext("2d");
        canvasObject.canvas.width = width;
        canvasObject.canvas.height = height;
}

// draw bit array background
const squareSize = 38, gridRows = 8, gridCols = 32, gridXOffset = 5; gridYOffset = 5;
function drawGrid(canvasID, squaresize = squareSize, gridrows = gridRows, gridcols = gridCols, xOffset = gridXOffset, yOffset = gridYOffset, stroke ="#000", fillBlock = false, color = "#fff", strokewidth = 2) {
    var canvasObject = document.getElementById(canvasID).getContext("2d");
    for (let row = 0; row < gridrows; row++) {
        for (let col = 0; col < gridcols; col++) {
            const x = col * squaresize + xOffset;
            const y = row * squaresize + yOffset;
            canvasObject.strokeStyle = stroke;
            canvasObject.lineWidth = strokewidth;
            canvasObject.strokeRect(x, y, squaresize, squaresize);
            if (fillBlock) {
                canvasObject.fillStyle = color;
                canvasObject.fillRect(x + 2, y + 2, squaresize - 4, squaresize - 4);
            }
        }   
    }
}

function drawBlock(canvasID, target, color = "#000", squaresize = squareSize, gridcols = gridCols, xOffset = gridXOffset, yOffset = gridYOffset) {
    var canvasObject = document.getElementById(canvasID).getContext("2d");
    canvasObject.fillStyle = color;
    var y = Math.floor(target / gridcols) * squaresize + yOffset;
    var x = (target % gridcols) * squaresize + xOffset;
    canvasObject.fillRect(x + 2, y + 2, squaresize - 4, squaresize - 4);
}

// draw bit array black blocks
function drawBlocks(canvasID, array, color = "#000", squaresize = squareSize, gridcols = gridCols, xOffset = gridXOffset, yOffset = gridYOffset) {
    for (let i = 0; i < array.length; i++) {
        drawBlock(canvasID, array[i], color, squaresize, gridcols, xOffset, yOffset);
    }
}

function drawBits(canvasID, number, xOffset, yOffset, squarelength = 2, squaresize = 19, colorFG = "#000", colorBG = "#fff") {
    var binaryArraySize = squarelength * squarelength;
    var binaryString = number.toString(2).padStart(binaryArraySize, '0');
    var binaryArray = [...binaryString].map(Number).reverse();
    for (let i = 0; i < binaryArraySize; i++) {
        if (binaryArray[binaryArraySize - i - 1] === 1)
            drawBlock(canvasID, i, colorFG, squaresize, squarelength, xOffset, yOffset);
        else
            drawBlock(canvasID, i, colorBG, squaresize, squarelength, xOffset, yOffset);
    }
}


// add to bit array
async function arrayAdd(bfArray, queryInput, hashOutput, messageOutput, hashDepth, cms = false, cmsWidth = 32) {
    var target = document.getElementById(queryInput).value.trim();
    if (!target) return;
    target = await getHash(target);
    if (cms)
        for (let i = 0; i < hashDepth; i++)
            target[i] = i * cmsWidth + (target[i] % cmsWidth);
    document.getElementById(hashOutput).innerHTML = target.slice(0, hashDepth).join(", ");
    document.getElementById(messageOutput).innerHTML = "Element added.";
    for (i = 0; i < hashDepth; i++)
        bfArray[(target[i])] += 1;
    return target;
}

async function arrayRemove(canvasID, bfArray, queryInput, hashOutput, queryOutput, hashDepth) {
    var target = document.getElementById(queryInput).value.trim();
    if (!target) return;
    target = await getHash(target);
    document.getElementById(hashOutput).innerHTML = target.slice(0, hashDepth).join(", ");
    drawBlocks(canvasID, target.slice(0, hashDepth), "#f45");
    await new Promise(resolve => setTimeout(resolve, 500));
    for (let i = 0; i < hashDepth; i++) {
        drawBlock(canvasID, target[i], "#fff");
        bfArray[target[i]] = 0;
    }
    document.getElementById(queryOutput).innerHTML = "Element removed.";
}

// show and query bitarray position
async function arrayQuery(canvasID, bfArray, queryInput, hashOutput, queryOutput, hashDepth, maxFrequency = 16, xOffset = gridXOffset, yOffset = gridYOffset, squaresize = squareSize, gridcols = gridCols, draw = true, cms = false, cmsWidth = 32) {
    var target = document.getElementById(queryInput).value.trim();
    if (!target) return;
    target = await getHash(target);
    if (cms)
        for (let i = 0; i < hashDepth; i++)
            target[i] = i * cmsWidth + (target[i] % cmsWidth);
    document.getElementById(hashOutput).innerHTML = target.slice(0, hashDepth).join(", ");
    drawBlocks(canvasID, target.slice(0, hashDepth), "#999", squaresize, gridcols, xOffset, yOffset);
    await new Promise(resolve => setTimeout(resolve, 500));
    var bfSimilarity = true;
    var frequency = new Array(hashDepth).fill(0);
    for (let i = 0; i < hashDepth; i++) {
        frequency[i] = bfArray[target[i]] % maxFrequency;
        if (bfArray[target[i]] === 0) {
            if (draw)
                drawBlock(canvasID, target[i], "#fff");
            bfSimilarity = false;
        }
        else
            if (draw)
                drawBlock(canvasID, target[i], "#000");
    }
    if (bfSimilarity)
        document.getElementById(queryOutput).innerHTML = "<b>Element found.</b>";
    else
        document.getElementById(queryOutput).innerHTML = "Element not found.";
    return frequency;
}

function generateRandomString(length) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    var result = '';
    for (let i = 0; i < length; i++) {
        var index = Math.floor(Math.random() * characters.length);
        result += characters[index];
    }
    return result;
}

drawCanvas("bfCanvasAdd", 1280, 320);
drawCanvas("bfCanvasQuery", 1280, 320);
drawCanvas("bfCanvasCollision", 1280, 320);
drawCanvas("bfCanvasMultiple", 1280, 320);
drawCanvas("bfCanvasSaturated", 1280, 320);
drawCanvas("bfCanvasBigger", 1280, 920);
drawCanvas("bfCanvasDeletion", 1280, 320);
drawCanvas("bfCanvasCounting", 1280, 320);
drawGrid("bfCanvasAdd");
drawGrid("bfCanvasQuery");
drawGrid("bfCanvasCollision");
drawGrid("bfCanvasMultiple");
drawGrid("bfCanvasSaturated");
drawGrid("bfCanvasBigger", 38, 24, 32);
drawGrid("bfCanvasDeletion");
drawGrid("bfCanvasCounting");
for (let i = 0; i < 256; i++)
    drawBlock("bfCanvasSaturated", i, "#000");

// initialize bloom filter arrays
var bfArrayAddQuery = new Array(256).fill(0);
var bfArrayCollision = new Array(256).fill(0);
var bfArrayMultiple = new Array(256).fill(0);
var bfArraySaturated = new Array(256).fill(1);
var bfArrayBigger = new Array(256).fill(0);
var bfArrayDeletion = new Array(256).fill(0);
var bfArrayCounting = new Array(256).fill(0);

const bfButtonAdd = document.getElementById("bfButtonAdd");
bfButtonAdd.onclick = async() => {
    var target = await arrayAdd(bfArrayAddQuery, "bfInputAdd", "bfOutputAddHash", "bfOutputAddMessage", 1);
    drawBlock("bfCanvasAdd", target[0]);
    drawBlock("bfCanvasQuery", target[0]);
};
const bfButtonQuery = document.getElementById("bfButtonQuery");
bfButtonQuery.onclick = async() => {
    await arrayQuery("bfCanvasQuery", bfArrayAddQuery, "bfInputQuery", "bfOutputQueryHash", "bfOutputQueryMessage", 1);
}
const bfButtonCollisionAdd = document.getElementById("bfButtonCollisionAdd");
bfButtonCollisionAdd.onclick = async() => {
    var target = await arrayAdd(bfArrayCollision, "bfInputCollisionAdd", "bfOutputCollisionHash", "bfOutputCollisionMessage", 1);
    drawBlock("bfCanvasCollision", target[0]);
};
const bfButtonCollisionQuery = document.getElementById("bfButtonCollisionQuery");
bfButtonCollisionQuery.onclick = async() => {
    await arrayQuery("bfCanvasCollision", bfArrayCollision, "bfInputCollisionQuery", "bfOutputCollisionHash", "bfOutputCollisionMessage", 1);
}

var bfHashDepth = 3;
const bfOutputMultipleHashDepth = document.getElementById("bfOutputMultipleHashDepth");
const bfInputMultipleSlider = document.getElementById("bfInputMultipleSlider");
bfInputMultipleSlider.min = 1;
bfInputMultipleSlider.max = 10;
bfInputMultipleSlider.step = 1;
bfInputMultipleSlider.value = bfHashDepth;
bfInputMultipleSlider.addEventListener("change", function() {
    bfHashDepth = bfInputMultipleSlider.value;
    bfOutputMultipleHashDepth.innerHTML = bfInputMultipleSlider.value
});

const bfButtonMultipleAdd = document.getElementById("bfButtonMultipleAdd");
bfButtonMultipleAdd.onclick = async() => {
    var target = await arrayAdd(bfArrayMultiple, "bfInputMultipleAdd", "bfOutputMultipleHash", "bfOutputMultipleMessage", bfHashDepth);
    drawBlocks("bfCanvasMultiple", target.slice(0, bfHashDepth));
};
const bfButtonMultipleQuery = document.getElementById("bfButtonMutlipleQuery");
bfButtonMultipleQuery.onclick = async() => {
    await arrayQuery("bfCanvasMultiple", bfArrayMultiple, "bfInputMultipleQuery", "bfOutputMultipleHash", "bfOutputMultipleMessage", bfHashDepth);
}
const bfButtonSaturatedQuery = document.getElementById("bfButtonSaturatedQuery");
bfButtonSaturatedQuery.onclick = async() => {
    await arrayQuery("bfCanvasSaturated", bfArraySaturated, "bfInputSaturatedQuery", "bfOutputSaturatedHash", "bfOutputSaturatedMessage", 3);
}
const bfButtonBiggerAdd = document.getElementById("bfButtonBiggerAdd");
bfButtonBiggerAdd.onclick = async() => {
    var target = await arrayAdd(bfArrayBigger, "bfInputBiggerAdd", "bfOutputBiggerHash", "bfOutputBiggerMessage", 3);
    drawBlock("bfCanvasBigger", target[6], "#000", squareSize, gridCols, 5, 5);
    drawBlock("bfCanvasBigger", target[7], "#000", squareSize, gridCols, 5, 309);
    drawBlock("bfCanvasBigger", target[8], "#000", squareSize, gridCols, 5, 613);
    // inaccurate and ugly hack, but using it since used only once
};
const bfButtonBiggerAddRandom = document.getElementById("bfButtonBiggerAddRandom");
bfButtonBiggerAddRandom.onclick = async() => {
    var bfVarBiggerRandom = generateRandomString(8);
    document.getElementById("bfInputBiggerAdd").value = bfVarBiggerRandom;
    var target = await arrayAdd(bfArrayBigger, "bfInputBiggerAdd", "bfOutputBiggerHash", "bfOutputBiggerMessage", 3);
    drawBlock("bfCanvasBigger", target[6], "#000", squareSize, gridCols, 5, 5);
    drawBlock("bfCanvasBigger", target[7], "#000", squareSize, gridCols, 5, 309);
    drawBlock("bfCanvasBigger", target[8], "#000", squareSize, gridCols, 5, 613);
};
const bfButtonDeletionAdd = document.getElementById("bfButtonDeletionAdd");
bfButtonDeletionAdd.onclick = async() => {
    var target = await arrayAdd(bfArrayDeletion, "bfInputDeletionAdd", "bfOutputDeletionHash", "bfOutputDeletionMessage", 3);
    drawBlocks("bfCanvasDeletion", target.slice(0, 3));
};
const bfButtonDeletionQuery = document.getElementById("bfButtonDeletionQuery");
bfButtonDeletionQuery.onclick = async() => {
    await arrayQuery("bfCanvasDeletion", bfArrayDeletion, "bfInputDeletionQuery", "bfOutputDeletionHash", "bfOutputDeletionMessage", 3);
}
const bfButtonDeletionRemove = document.getElementById("bfButtonDeletionRemove");
bfButtonDeletionRemove.onclick = async() => {
    await arrayRemove("bfCanvasDeletion", bfArrayDeletion, "bfInputDeletionRemove", "bfOutputDeletionHash", "bfOutputDeletionMessage", 3); 
}
const bfButtonCountingAdd = document.getElementById("bfButtonCountingAdd");
bfButtonCountingAdd.onclick = async() => {
    var target = await arrayAdd(bfArrayCounting, "bfInputCountingAdd", "bfOutputCountingHash", "bfOutputCountingMessage", 3);
    drawBlocks("bfCanvasCounting", target.slice(0, 3));
};
const bfButtonCountingQuery = document.getElementById("bfButtonCountingQuery");
bfButtonCountingQuery.onclick = async() => {
    await arrayQuery("bfCanvasCounting", bfArrayCounting, "bfInputCountingQuery", "bfOutputCountingHash", "bfOutputCountingMessage", 3);
}

var cmsArrayComparison = new Array(256).fill(0);
drawCanvas("cmsCanvasComparison", 1280, 650);
drawGrid("cmsCanvasComparison", 38, 8, 32);
drawGrid("cmsCanvasComparison", 19, 16, 64, gridXOffset, 341, "#999");
drawGrid("cmsCanvasComparison", 38, 8, 32, gridXOffset, 341, "#000");
const cmsButtonComparisonAdd = document.getElementById("cmsButtonComparisonAdd");
cmsButtonComparisonAdd.onclick = async() => {
    var target = await arrayAdd(cmsArrayComparison, "cmsInputComparisonAdd", "cmsOutputComparisonHash", "cmsOutputComparisonMessage", 3);
    drawBlocks("cmsCanvasComparison", target.slice(0, 3));
    for (let i = 0; i < 3; i++) {
        var xOffset = (target[i] % gridCols) * squareSize + gridXOffset;
        var yOffset = Math.floor(target[i] / gridCols) * squareSize + 341;
        drawBits("cmsCanvasComparison", cmsArrayComparison[target[i]], xOffset, yOffset);
    }
};
const cmsButtonComparisonQuery = document.getElementById("cmsButtonComparisonQuery");
cmsButtonComparisonQuery.onclick = async() => {
    await arrayQuery("cmsCanvasComparison", cmsArrayComparison, "cmsInputComparisonQuery", "cmsOutputComparisonHash", "cmsOutputComparisonMessage", 3);
    var frequency = await arrayQuery("cmsCanvasComparison", cmsArrayComparison, "cmsInputComparisonQuery", "cmsOutputComparisonHash", "cmsOutputComparisonMessage", 3, 16, gridXOffset, 341);
    document.getElementById("cmsOutputComparisonValues").innerHTML = frequency.slice(0, 3).join(", ");
    var target = document.getElementById("cmsInputComparisonQuery").value.trim();
    target = await getHash(target);
    for (let i = 0; i < 3; i++) {
        var xOffset = (target[i] % gridCols) * squareSize + gridXOffset;
        var yOffset = Math.floor(target[i] / gridCols) * squareSize + 341;
        drawGrid("cmsCanvasComparison");
        drawGrid("cmsCanvasComparison", 38, 1, 1, xOffset, yOffset, "#000", true, "#fff");
        drawGrid("cmsCanvasComparison", 19, 2, 2, xOffset, yOffset, "#999", false);
        drawGrid("cmsCanvasComparison", 38, 1, 1, xOffset, yOffset, "#000", false);
        drawBits("cmsCanvasComparison", cmsArrayComparison[target[i]], xOffset, yOffset);
    }
}

var cmsArrayMain = new Array(256).fill(0);
drawCanvas("cmsCanvasMain", 1280, 320);
drawGrid("cmsCanvasMain", 19, 16, 64, gridXOffset, gridYOffset, "#999");
drawGrid("cmsCanvasMain", 38, 8, 32);
const cmsButtonMainAdd = document.getElementById("cmsButtonMainAdd");
cmsButtonMainAdd.onclick = async() => {
    var target = await arrayAdd(cmsArrayMain, "cmsInputMainAdd", "cmsOutputMainHash", "cmsOutputMainMessage", 3);
    for (let i = 0; i < 3; i++) {
        var xOffset = (target[i] % gridCols) * squareSize + gridXOffset;
        var yOffset = Math.floor(target[i] / gridCols) * squareSize + gridYOffset;
        drawBits("cmsCanvasMain", cmsArrayMain[target[i]], xOffset, yOffset);
    }
};
const cmsButtonMainQuery = document.getElementById("cmsButtonMainQuery");
cmsButtonMainQuery.onclick = async() => {
    var frequency = await arrayQuery("cmsCanvasMain", cmsArrayMain, "cmsInputMainQuery", "cmsOutputMainHash", "cmsOutputMainMessage", 3, 16, gridXOffset, gridYOffset, squareSize, gridCols, false);
    document.getElementById("cmsOutputMainValues").innerHTML = frequency.slice(0, 3).join(", ");
    document.getElementById("cmsOutputMainEstimate").innerHTML = Math.min(...frequency.slice(0, 3));
    var target = document.getElementById("cmsInputMainQuery").value.trim();
    target = await getHash(target);
    for (let i = 0; i < 3; i++) {
        var xOffset = (target[i] % gridCols) * squareSize + gridXOffset;
        var yOffset = Math.floor(target[i] / gridCols) * squareSize + gridYOffset;
        drawGrid("cmsCanvasMain", 38, 1, 1, xOffset, yOffset, "#000", true, "#fff");
        drawGrid("cmsCanvasMain", 19, 2, 2, xOffset, yOffset, "#999", false);
        drawGrid("cmsCanvasMain", 38, 1, 1, xOffset, yOffset, "#000", false);
        drawBits("cmsCanvasMain", cmsArrayMain[target[i]], xOffset, yOffset);
    }
}

var cmsArrayComparisonErrors = new Array(256).fill(0);
var cmsVarComparisonErrorsHashDepth = 32;
drawCanvas("cmsCanvasComparisonErrors", 1280, 650);
drawGrid("cmsCanvasComparisonErrors", 38, 8, 32);
drawGrid("cmsCanvasComparisonErrors", 19, 16, 64, gridXOffset, 341, "#999");
drawGrid("cmsCanvasComparisonErrors", 38, 8, 32, gridXOffset, 341, "#000");
cmsInputComparisonErrorsSlider.min = 1;
cmsInputComparisonErrorsSlider.max = 32;
cmsInputComparisonErrorsSlider.step = 1;
cmsInputComparisonErrorsSlider.value = cmsVarComparisonErrorsHashDepth;
cmsInputComparisonErrorsSlider.addEventListener("change", function() {
    cmsVarComparisonErrorsHashDepth = cmsInputComparisonErrorsSlider.value;
    cmsOutputComparisonErrorsHashDepth.innerHTML = cmsInputComparisonErrorsSlider.value;
});
const cmsButtonComparisonErrorsAdd = document.getElementById("cmsButtonComparisonErrorsAdd");
cmsButtonComparisonErrorsAdd.onclick = async() => {
    var target = await arrayAdd(cmsArrayComparisonErrors, "cmsInputComparisonErrorsAdd", "cmsOutputComparisonErrorsHash", "cmsOutputComparisonErrorsMessage", cmsVarComparisonErrorsHashDepth);
    drawBlocks("cmsCanvasComparisonErrors", target.slice(0, cmsVarComparisonErrorsHashDepth));
    for (let i = 0; i < 32; i++) {
        var xOffset = (target[i] % gridCols) * squareSize + gridXOffset;
        var yOffset = Math.floor(target[i] / gridCols) * squareSize + 341;
        drawBits("cmsCanvasComparisonErrors", cmsArrayComparisonErrors[target[i]], xOffset, yOffset);
    }
};

var cmsArraySketch = new Array(256).fill(0);
drawCanvas("cmsCanvasSketch", 1280, 320);
drawGrid("cmsCanvasSketch", 19, 16, 64, gridXOffset, gridYOffset, "#999");
drawGrid("cmsCanvasSketch", 38, 8, 32);
const cmsButtonSketchAdd = document.getElementById("cmsButtonSketchAdd");
cmsButtonSketchAdd.onclick = async() => {
    var target = await arrayAdd(cmsArraySketch, "cmsInputSketchAdd", "cmsOutputSketchHash", "cmsOutputSketchMessage", 8, true, 32);
    for (let i = 0; i < 8; i++) {
        var xOffset = (target[i] % gridCols) * squareSize + gridXOffset;
        var yOffset = Math.floor(target[i] / gridCols) * squareSize + gridYOffset;
        drawBits("cmsCanvasSketch", cmsArraySketch[target[i]], xOffset, yOffset);
    }
}
const cmsButtonSketchQuery = document.getElementById("cmsButtonSketchQuery");
cmsButtonSketchQuery.onclick = async() => {
    var frequency = await arrayQuery("cmsCanvasSketch", cmsArraySketch, "cmsInputSketchQuery", "cmsOutputSketchHash", "cmsOutputSketchMessage", 8, 16, gridXOffset, gridYOffset, squareSize, gridCols, false, true, 32);
    document.getElementById("cmsOutputSketchValues").innerHTML = frequency.slice(0, 8).join(", ");
    document.getElementById("cmsOutputSketchEstimate").innerHTML = Math.min(...frequency.slice(0, 8));
    var target = document.getElementById("cmsInputSketchQuery").value.trim();
    target = await getHash(target);
    for (let i = 0; i < 8; i++)
        target[i] = i * 32 + (target[i] % 32);
    for (let i = 0; i < 8; i++) {
        var xOffset = (target[i] % gridCols) * squareSize + gridXOffset;
        var yOffset = Math.floor(target[i] / gridCols) * squareSize + gridYOffset;
        drawGrid("cmsCanvasSketch", 38, 1, 1, xOffset, yOffset, "#000", true, "#fff");
        drawGrid("cmsCanvasSketch", 19, 2, 2, xOffset, yOffset, "#999", false);
        drawGrid("cmsCanvasSketch", 38, 1, 1, xOffset, yOffset, "#000", false);
        drawBits("cmsCanvasSketch", cmsArraySketch[target[i]], xOffset, yOffset);
    }
}

function drawTrig(canvasID, size = 10, color = "#000", xOffset = 10, yOffset = 10) {
    var canvasObject = document.getElementById(canvasID).getContext("2d");
    canvasObject.beginPath();
    canvasObject.moveTo(xOffset, yOffset);
    canvasObject.lineTo(xOffset - size, yOffset + size);
    canvasObject.lineTo(xOffset + size, yOffset + size);
    canvasObject.closePath(); 
    canvasObject.fillStyle = color;
    canvasObject.fill();
}

function drawCoins(canvasID, number, coins = 8, radius = 70, colorFG = "#000", colorBG = "#fff", stroke = "#000", strokewidth = 2, width = 1280, height = 200) {
    var canvasObject = document.getElementById(canvasID).getContext("2d");
    canvasObject.strokeStyle = stroke;
    canvasObject.lineWidth = strokewidth;
    var y = height / 2;
    for (i = 0; i < coins; i++) {
        var x = (i* width / coins) + (width / (2 * coins));
        canvasObject.beginPath();
        canvasObject.arc(x, y, radius, 0, Math.PI * 2);
        if ((number >> i) & 1 === 1)
            canvasObject.fillStyle = colorFG;
        else
            canvasObject.fillStyle = colorBG;
        canvasObject.fill()
        canvasObject.stroke();
    }
}

function drawBitArray(canvasID, number, length = 32, squaresize = 38, colorFG = "#000", colorBG = "#fff", stroke = "#000", strokewidth = 2, xOffset = 5, yOffset = 5) {
    var canvasObject = document.getElementById(canvasID).getContext("2d");
    var y = yOffset;
    for (let i = 0; i < length; i++) {
    var x = i * squaresize + xOffset;
        if ((number >> i) & 1 === 1)
            canvasObject.fillStyle = colorFG;
        else
            canvasObject.fillStyle = colorBG;
    canvasObject.fillRect(x + 2, y + 2, squaresize - 4, squaresize - 4);
    }
}

function countZeros(number, size, start = 0) {
    for (let i = start; i < size; i++)
        if ((number >> i) & 1 === 1)
            return i - start;
    return size;
}

async function hllAdd(canvasID, squaresize, hllSet, inputQuery, outputZeros, outputZerosMax, outputEstimate, outputCardinality, estimates, maxCounter, outputBucket, bucketsLog = 0, canvasIDBuckets, outputMean, outputScaled) {
    var target = document.getElementById(inputQuery).value.trim();
    if (!target) return;
    hllSet.add(target);
    target = await getHash(target);
    target = ((target[0] << 24) | (target[1] << 16) | (target[2] << 8) | target[3] );
    drawBitArray(canvasID, target);
    var bucket = 0;
    if (outputBucket) {
        var bucketsNum = 1 << bucketsLog;
        var temp = (target & (bucketsNum - 1));
        for (let i = 0; i < bucketsLog; i++) {
            bucket = (bucket << 1) | (temp & 1);
            temp = temp >> 1;
        }
        document.getElementById(outputBucket).innerHTML = bucket;
    }
    var zeros = countZeros(target, 32, bucketsLog);
    if (zeros > maxCounter[bucket])
        maxCounter[bucket] = zeros % 16;
    if (outputBucket) {
        var canvasObject = document.getElementById(canvasIDBuckets).getContext("2d");
        canvasObject.fillStyle = "#fff";
        canvasObject.fillRect(0, squaresize * 2 + 6, 1280, 20);
        drawBits(canvasIDBuckets, maxCounter[bucket], (bucket * squaresize * 2) + gridXOffset, gridYOffset, 2, squaresize, "#999", "#fff");
        drawTrig(canvasIDBuckets, 10, "#999", bucket * squaresize * 2 + squaresize + gridXOffset, squaresize * 2 + gridYOffset + 5);
    }
    estimates[bucket] = 1 << (maxCounter[bucket]);
    document.getElementById(outputZeros).innerHTML = zeros;
    document.getElementById(outputZerosMax).innerHTML = maxCounter.join(", ");
    document.getElementById(outputEstimate).innerHTML = estimates.join(", ");
    document.getElementById(outputCardinality).innerHTML = hllSet.size;
    if (outputBucket) {
        var sum = 0;
        for (let i = 0; i < bucketsNum; i++)
            sum += 1/estimates[i];
        mean = Math.floor(bucketsNum * bucketsNum * 2 / sum);     // additional mult by 2 prob cuz bit shift is off by 1
        document.getElementById(outputMean).innerHTML = mean;     // pls help find it, its buggine me; pun not intended
    }
    if (outputScaled) {
        const alpha = 0.7213 / (1 + 1.079 / bucketsNum);
        document.getElementById(outputScaled).innerHTML = Math.floor(mean * alpha);
    }
}

drawCanvas("hllCanvasCoinProbability", 1280, 400);
drawCoins("hllCanvasCoinProbability", 176);
drawCanvas("hllCanvasCoinObservation", 1280, 200);
drawCoins("hllCanvasCoinObservation", 0);
drawCanvas("hllCanvasCoinEstimation", 1280, 200);
drawCoins("hllCanvasCoinEstimation", 0);

var hllCanvasCoinProbability = document.getElementById("hllCanvasCoinProbability").getContext("2d");
hllCanvasCoinProbability.beginPath();
hllCanvasCoinProbability.strokeStyle = "#000";
hllCanvasCoinProbability.moveTo(11, 231);
hllCanvasCoinProbability.lineTo(11, 241);
hllCanvasCoinProbability.lineTo(311, 241);
hllCanvasCoinProbability.lineTo(311, 231);
hllCanvasCoinProbability.moveTo(11, 281);
hllCanvasCoinProbability.lineTo(11, 291);
hllCanvasCoinProbability.lineTo(471, 291);
hllCanvasCoinProbability.lineTo(471, 281);
hllCanvasCoinProbability.moveTo(11, 331);
hllCanvasCoinProbability.lineTo(11, 341);
hllCanvasCoinProbability.lineTo(631, 341);
hllCanvasCoinProbability.lineTo(631, 331);
hllCanvasCoinProbability.stroke();
hllCanvasCoinProbability.font = "22px JetBrains Mono";
hllCanvasCoinProbability.textAlign = "center";
hllCanvasCoinProbability.textBaseline = "middle";
hllCanvasCoinProbability.fillStyle = "#000";
for (let i = 80; i < 1280; i += 160)
    hllCanvasCoinProbability.fillText("1/2", i, 196);
hllCanvasCoinProbability.font = "22px JetBrains Mono";
hllCanvasCoinProbability.fillStyle = "#000";
for (let i = 0; i < 3; i ++)
    hllCanvasCoinProbability.fillText(`1/${2 << i}`, i * 80 + 161, 260 + i * 50);

var hllVarCoinObservationTosses = 0;
var hllVarCoinObservationZerosMax = 0;
const hllButtonCoinObservationToss = document.getElementById("hllButtonCoinObservationToss");
hllButtonCoinObservationToss.onclick = function() {
    hllVarCoinObservationTosses += 1;
    var hllVarCoinObservationRandom = Math.random() * 256;
    var hllVarCoinObservationZeros = countZeros(hllVarCoinObservationRandom, 8);
    if (hllVarCoinObservationZeros > hllVarCoinObservationZerosMax) {
        hllVarCoinObservationZerosMax = hllVarCoinObservationZeros;
        document.getElementById("hllOutputCoinObservationZerosMax").innerHTML = hllVarCoinObservationZerosMax;
    }
    drawCoins("hllCanvasCoinObservation", hllVarCoinObservationRandom);
    document.getElementById("hllOutputCoinObservationZeros").innerHTML = hllVarCoinObservationZeros;
    document.getElementById("hllOutputCoinObservationTosses").innerHTML = hllVarCoinObservationTosses;
}
const hllButtonCoinObservationReset = document.getElementById("hllButtonCoinObservationReset");
hllButtonCoinObservationReset.onclick = function() {
    hllVarCoinObservationTosses = 0;
    hllVarCoinObservationZerosMax = 0;
    document.getElementById("hllOutputCoinObservationZeros").innerHTML = 0;
    document.getElementById("hllOutputCoinObservationZerosMax").innerHTML = 0;
    document.getElementById("hllOutputCoinObservationTosses").innerHTML = 0;
    drawCoins("hllCanvasCoinObservation", 0);
}

var hllVarCoinEstimationTosses = 0;
var hllVarCoinEstimationZerosMax = 0;
const hllButtonCoinEstimationToss = document.getElementById("hllButtonCoinEstimationToss");
hllButtonCoinEstimationToss.onclick = function() {
    hllVarCoinEstimationTosses += 1;
    var hllVarCoinEstimationRandom = Math.random() * 256;
    var hllVarCoinEstimationZeros = countZeros(hllVarCoinEstimationRandom, 8);
    if (hllVarCoinEstimationZeros > hllVarCoinEstimationZerosMax) {
        hllVarCoinEstimationZerosMax = hllVarCoinEstimationZeros;
        document.getElementById("hllOutputCoinEstimationZerosMax").innerHTML = hllVarCoinEstimationZerosMax;
        document.getElementById("hllOutputCoinEstimationEstimate").innerHTML = 2 << (hllVarCoinEstimationZerosMax - 1);
    }
    drawCoins("hllCanvasCoinEstimation", hllVarCoinEstimationRandom);
    document.getElementById("hllOutputCoinEstimationZeros").innerHTML = hllVarCoinEstimationZeros;
    document.getElementById("hllOutputCoinEstimationTosses").innerHTML = hllVarCoinEstimationTosses;
}
const hllButtonCoinEstimationReset = document.getElementById("hllButtonCoinEstimationReset");
hllButtonCoinEstimationReset.onclick = function() {
    hllVarCoinEstimationTosses = 0;
    hllVarCoinEstimationZerosMax = 0;
    document.getElementById("hllOutputCoinEstimationZeros").innerHTML = 0;
    document.getElementById("hllOutputCoinEstimationZerosMax").innerHTML = 0;
    document.getElementById("hllOutputCoinEstimationEstimate").innerHTML = 0;
    document.getElementById("hllOutputCoinEstimationTosses").innerHTML = 0;
    drawCoins("hllCanvasCoinEstimation", 0);
}

drawCanvas("hllCanvasBits", 1280, 48);
drawGrid("hllCanvasBits", 38, 1, 32, gridXOffset, gridYOffset, "#000");
drawCanvas("hllCanvasBucket", 1280, 65);
drawBitArray("hllCanvasBucket", 0);
drawGrid("hllCanvasBucket", 38, 1, 4, gridXOffset, gridYOffset, "#999");
drawGrid("hllCanvasBucket", 38, 1, 28, 157, gridYOffset, "#000");
drawTrig("hllCanvasBucket", 10, "#999", 24, 50);
drawTrig("hllCanvasBucket", 10, "#999", 62, 50);
drawTrig("hllCanvasBucket", 10, "#999", 100, 50);
drawTrig("hllCanvasBucket", 10, "#999", 138, 50);
drawCanvas("hllCanvasBucketCounters", 1280, 105);
drawGrid("hllCanvasBucketCounters", 38, 2, 32, gridXOffset, gridYOffset, "#999");
drawGrid("hllCanvasBucketCounters", 76, 1, 16, gridXOffset, gridYOffset, "#000");
drawTrig("hllCanvasBucketCounters", 10, "#999", 43, 88);
drawCanvas("hllCanvasMain", 1280, 65);
drawBitArray("hllCanvasMain", 0);
drawGrid("hllCanvasMain", 38, 1, 5, gridXOffset, gridYOffset, "#999");
drawGrid("hllCanvasMain", 38, 1, 27, 195, gridYOffset, "#000");
drawTrig("hllCanvasMain", 10, "#999", 24, 50);
drawTrig("hllCanvasMain", 10, "#999", 62, 50);
drawTrig("hllCanvasMain", 10, "#999", 100, 50);
drawTrig("hllCanvasMain", 10, "#999", 138, 50);
drawTrig("hllCanvasMain", 10, "#999", 176, 50);
drawCanvas("hllCanvasMainCounters", 1280, 65);
drawGrid("hllCanvasMainCounters", 19, 2, 64, gridXOffset, gridYOffset, "#999");
drawGrid("hllCanvasMainCounters", 38, 1, 32, gridXOffset, gridYOffset, "#000");
drawTrig("hllCanvasMainCounters", 10, "#999", 24, 50);

var hllVarBitsZerosMax = [0];
var hllVarBitsEstimates = [0];
const hllSetBitsSet = new Set();
const hllButtonBitsAdd = document.getElementById("hllButtonBitsAdd");
hllButtonBitsAdd.onclick = async() => {
    await hllAdd("hllCanvasBits", 38, hllSetBitsSet, "hllInputBitsAdd", "hllOutputBitsZeros", "hllOutputBitsZerosMax", "hllOutputBitsEstimate", "hllOutputBitsCardinality", hllVarBitsEstimates, hllVarBitsZerosMax);
}
const hllButtonBitsRandom = document.getElementById("hllButtonBitsRandom");
hllButtonBitsRandom.onclick = async() => {
    var target = generateRandomString(10);
    document.getElementById("hllInputBitsAdd").value = target;
    await hllAdd("hllCanvasBits", 38, hllSetBitsSet, "hllInputBitsAdd", "hllOutputBitsZeros", "hllOutputBitsZerosMax", "hllOutputBitsEstimate", "hllOutputBitsCardinality", hllVarBitsEstimates, hllVarBitsZerosMax);
}
const hllButtonBitsReset = document.getElementById("hllButtonBitsReset");
hllButtonBitsReset.onclick = function() {
    hllSetBitsSet.clear();
    hllVarBitsTosses = 0;
    hllVarBitsZerosMax[0] = 0;
    document.getElementById("hllOutputBitsZeros").innerHTML = 0;
    document.getElementById("hllOutputBitsZerosMax").innerHTML = 0;
    document.getElementById("hllOutputBitsEstimate").innerHTML = 0;
    document.getElementById("hllOutputBitsCardinality").innerHTML = 0;
    drawBitArray("hllCanvasBits", 0);
}

var hllVarBucketZerosMax = new Array(16).fill(0);
var hllVarBucketEstimates = new Array(16).fill(1);
const hllSetBucketSet = new Set();
const hllButtonBucketAdd = document.getElementById("hllButtonBucketAdd");
hllButtonBucketAdd.onclick = async() => {
    await hllAdd("hllCanvasBucket", 38, hllSetBucketSet, "hllInputBucketAdd", "hllOutputBucketZeros", "hllOutputBucketZerosMax", "hllOutputBucketEstimates", "hllOutputBucketCardinality", hllVarBucketEstimates, hllVarBucketZerosMax, "hllOutputBucketNumber", 4, "hllCanvasBucketCounters", "hllOutputBucketMean");
}
const hllButtonBucketRandom = document.getElementById("hllButtonBucketRandom");
hllButtonBucketRandom.onclick = async() => {
    var target = generateRandomString(10);
    document.getElementById("hllInputBucketAdd").value = target;
    await hllAdd("hllCanvasBucket", 38, hllSetBucketSet, "hllInputBucketAdd", "hllOutputBucketZeros", "hllOutputBucketZerosMax", "hllOutputBucketEstimates", "hllOutputBucketCardinality", hllVarBucketEstimates, hllVarBucketZerosMax, "hllOutputBucketNumber", 4, "hllCanvasBucketCounters", "hllOutputBucketMean");
}
const hllButtonBucketReset = document.getElementById("hllButtonBucketReset");
hllButtonBucketReset.onclick = function() {
    hllSetBucketSet.clear();
    hllVarBucketZerosMax.fill(0);
    hllVarBucketEstimates.fill(1);
    document.getElementById("hllOutputBucketNumber").innerHTML = 0;
    document.getElementById("hllOutputBucketZeros").innerHTML = 0;
    document.getElementById("hllOutputBucketZerosMax").innerHTML = "0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0";
    document.getElementById("hllOutputBucketEstimates").innerHTML = "1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1";
    document.getElementById("hllOutputBucketMean").innerHTML = 0;
    document.getElementById("hllOutputBucketCardinality").innerHTML = 0;
    drawBitArray("hllCanvasBucket", 0);
    var hllCanvasBucketCounters = document.getElementById("hllCanvasBucketCounters").getContext("2d");
    hllCanvasBucketCounters.clearRect(0, 0, 1280, 120);
    drawGrid("hllCanvasBucketCounters", 38, 2, 32, gridXOffset, gridYOffset, "#999");
    drawGrid("hllCanvasBucketCounters", 76, 1, 16, gridXOffset, gridYOffset, "#000");
    drawTrig("hllCanvasBucketCounters", 10, "#999", 43, 88);
}

var hllVarMainZerosMax = new Array(32).fill(0);
var hllVarMainEstimates = new Array(32).fill(1);
const hllSetMainSet = new Set();
const hllButtonMainAdd = document.getElementById("hllButtonMainAdd");
hllButtonMainAdd.onclick = async() => {
    await hllAdd("hllCanvasMain", 19, hllSetMainSet, "hllInputMainAdd", "hllOutputMainZeros", "hllOutputMainZerosMax", "hllOutputMainEstimates", "hllOutputMainCardinality", hllVarMainEstimates, hllVarMainZerosMax, "hllOutputMainNumber", 5, "hllCanvasMainCounters", "hllOutputMainMean", "hllOutputMainScaled");
}
const hllButtonMainRandom = document.getElementById("hllButtonMainRandom");
hllButtonMainRandom.onclick = async() => {
    var target = generateRandomString(10);
    document.getElementById("hllInputMainAdd").value = target;
    await hllAdd("hllCanvasMain", 19, hllSetMainSet, "hllInputMainAdd", "hllOutputMainZeros", "hllOutputMainZerosMax", "hllOutputMainEstimates", "hllOutputMainCardinality", hllVarMainEstimates, hllVarMainZerosMax, "hllOutputMainNumber", 5, "hllCanvasMainCounters", "hllOutputMainMean", "hllOutputMainScaled");
}
const hllButtonMainRandomK = document.getElementById("hllButtonMainRandomK");
hllButtonMainRandomK.onclick = async() => {
    for (let i = 0; i < 500; i++) {
        var target = generateRandomString(10);
        document.getElementById("hllInputMainAdd").value = target;
        await hllAdd("hllCanvasMain", 19, hllSetMainSet, "hllInputMainAdd", "hllOutputMainZeros", "hllOutputMainZerosMax", "hllOutputMainEstimates", "hllOutputMainCardinality", hllVarMainEstimates, hllVarMainZerosMax, "hllOutputMainNumber", 5, "hllCanvasMainCounters", "hllOutputMainMean", "hllOutputMainScaled");
    }
}
const hllButtonMainReset = document.getElementById("hllButtonMainReset");
hllButtonMainReset.onclick = function() {
    hllSetMainSet.clear();
    hllVarMainZerosMax.fill(0);
    hllVarMainEstimates.fill(1);
    document.getElementById("hllOutputMainNumber").innerHTML = 0;
    document.getElementById("hllOutputMainZeros").innerHTML = 0;
    document.getElementById("hllOutputMainZerosMax").innerHTML = "0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0";
    document.getElementById("hllOutputMainEstimates").innerHTML = "1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1";
    document.getElementById("hllOutputMainMean").innerHTML = 0;
    document.getElementById("hllOutputMainScaled").innerHTML = 0;
    document.getElementById("hllOutputMainCardinality").innerHTML = 0;
    drawBitArray("hllCanvasMain", 0);
    var hllCanvasMainCounters = document.getElementById("hllCanvasMainCounters").getContext("2d");
    hllCanvasMainCounters.clearRect(0, 0, 1280, 120);
    drawGrid("hllCanvasMainCounters", 19, 2, 64, gridXOffset, gridYOffset, "#999");
    drawGrid("hllCanvasMainCounters", 38, 1, 32, gridXOffset, gridYOffset, "#000");
    drawTrig("hllCanvasMainCounters", 10, "#999", 24, 50);
}

drawCanvas("hllCanvasLogSpace", 1280, 300);
var hllCanvasLogSpace = document.getElementById("hllCanvasLogSpace").getContext("2d");
hllCanvasLogSpace.textAlign = "center";
hllCanvasLogSpace.textBaseline = "middle";
hllCanvasLogSpace.font = "24px JetBrains Mono"; 
hllCanvasLogSpace.fillStyle = "#000";
hllCanvasLogSpace.fillText("65000 elements", 160, 251);
hllCanvasLogSpace.fillText("16 zeros", 640, 251);
hllCanvasLogSpace.fillText("4 bits", 1120, 251);
hllCanvasLogSpace.font = "50px JetBrains Mono"; 
hllCanvasLogSpace.fillStyle = "#000";
hllCanvasLogSpace.fillText("0000000", 641, 125);
hllCanvasLogSpace.font = "28px JetBrains Mono"; 
hllCanvasLogSpace.fillText("nKbwCzEjzSq", 160, 85);
hllCanvasLogSpace.fillText("xlMOWJanPAA", 160, 125);
hllCanvasLogSpace.fillText("GuwQVkfmqsl", 160, 162);
drawGrid("hllCanvasLogSpace", 50, 2, 2, 1071, 71, "#999");
drawGrid("hllCanvasLogSpace", 100, 1, 1, 1071, 71);
hllCanvasLogSpace.beginPath();
hllCanvasLogSpace.strokeStyle = "#000";
hllCanvasLogSpace.lineWidth = 2;
hllCanvasLogSpace.moveTo(290, 121);
hllCanvasLogSpace.lineTo(500, 121);
hllCanvasLogSpace.moveTo(780, 121);
hllCanvasLogSpace.lineTo(1000, 121);
hllCanvasLogSpace.stroke();
drawCanvas("cmsCanvasDifferentRange", 1280, 710);
var cmsCanvasDifferentRange = document.getElementById("cmsCanvasDifferentRange").getContext("2d");
drawGrid("cmsCanvasDifferentRange", 19, 16, 32, 613, 5, "#999", false, "#fff", 2);
drawGrid("cmsCanvasDifferentRange", 38, 8, 16, 613, 5, "#000", false, "#fff", 2);
drawGrid("cmsCanvasDifferentRange", 19, 16, 32, 613, 405, "#999", false, "#fff", 2);
drawGrid("cmsCanvasDifferentRange", 38, 8, 16, 613, 405, "#000", false, "#fff", 2);
cmsCanvasDifferentRange.strokeStyle = "#000";
cmsCanvasDifferentRange.lineWidth = 2;
cmsCanvasDifferentRange.beginPath();
cmsCanvasDifferentRange.moveTo(581, 5); cmsCanvasDifferentRange.lineTo(581, 309);
cmsCanvasDifferentRange.moveTo(561, 5); cmsCanvasDifferentRange.lineTo(561, 309);
cmsCanvasDifferentRange.moveTo(541, 5); cmsCanvasDifferentRange.lineTo(541, 309);
cmsCanvasDifferentRange.moveTo(521, 5); cmsCanvasDifferentRange.lineTo(521, 309);
cmsCanvasDifferentRange.moveTo(521, 5); cmsCanvasDifferentRange.lineTo(531, 5);
cmsCanvasDifferentRange.moveTo(541, 5); cmsCanvasDifferentRange.lineTo(551, 5);
cmsCanvasDifferentRange.moveTo(561, 5); cmsCanvasDifferentRange.lineTo(571, 5);
cmsCanvasDifferentRange.moveTo(581, 5); cmsCanvasDifferentRange.lineTo(591, 5);
cmsCanvasDifferentRange.moveTo(521, 309); cmsCanvasDifferentRange.lineTo(531, 309);
cmsCanvasDifferentRange.moveTo(541, 309); cmsCanvasDifferentRange.lineTo(551, 309);
cmsCanvasDifferentRange.moveTo(561, 309); cmsCanvasDifferentRange.lineTo(571, 309);
cmsCanvasDifferentRange.moveTo(581, 309); cmsCanvasDifferentRange.lineTo(591, 309);
cmsCanvasDifferentRange.moveTo(150, 23); cmsCanvasDifferentRange.lineTo(521, 23);
cmsCanvasDifferentRange.moveTo(150, 63); cmsCanvasDifferentRange.lineTo(541, 63);
cmsCanvasDifferentRange.moveTo(150, 103); cmsCanvasDifferentRange.lineTo(561, 103);
cmsCanvasDifferentRange.moveTo(150, 143); cmsCanvasDifferentRange.lineTo(581, 143);
cmsCanvasDifferentRange.moveTo(150, 423); cmsCanvasDifferentRange.lineTo(591, 423);
cmsCanvasDifferentRange.moveTo(150, 463); cmsCanvasDifferentRange.lineTo(591, 463);
cmsCanvasDifferentRange.moveTo(150, 503); cmsCanvasDifferentRange.lineTo(591, 503);
cmsCanvasDifferentRange.moveTo(150, 543); cmsCanvasDifferentRange.lineTo(591, 543);
cmsCanvasDifferentRange.stroke();
cmsCanvasDifferentRange.textAlign = "center";
cmsCanvasDifferentRange.textBaseline = "middle";
cmsCanvasDifferentRange.font = "28px JetBrains Mono"; 
cmsCanvasDifferentRange.fillStyle = "#000";
cmsCanvasDifferentRange.fillText("hash1(x)", 70, 25);
cmsCanvasDifferentRange.fillText("hash2(x)", 70, 65);
cmsCanvasDifferentRange.fillText("hash3(x)", 70, 105);
cmsCanvasDifferentRange.fillText("hash4(x)", 70, 145);
cmsCanvasDifferentRange.fillText("...", 70, 185);
cmsCanvasDifferentRange.fillText("hash1(x)", 70, 425);
cmsCanvasDifferentRange.fillText("hash2(x)", 70, 465);
cmsCanvasDifferentRange.fillText("hash3(x)", 70, 505);
cmsCanvasDifferentRange.fillText("hash4(x)", 70, 545);
cmsCanvasDifferentRange.fillText("...", 70, 585);
cmsCanvasDifferentRange.textAlign = "left";
cmsCanvasDifferentRange.font = "24px JetBrains Mono"; 
cmsCanvasDifferentRange.fillText("Same hash range", 5, 295);
cmsCanvasDifferentRange.fillText("Separate hash ranges", 5, 695);

drawCanvas("cmsCanvasComparisonStatic", 1280, 320);
var cmsCanvasComparisonStatic = document.getElementById("cmsCanvasComparisonStatic").getContext("2d");
drawGrid("cmsCanvasComparisonStatic", 40, 1, 1, 25, 5);
drawGrid("cmsCanvasComparisonStatic", 40, 1, 1, 201, 5);
drawGrid("cmsCanvasComparisonStatic", 40, 1, 1, 261, 5, "#000", true, "#000");
drawGrid("cmsCanvasComparisonStatic", 40, 2, 2, 5, 201, "#999");
drawGrid("cmsCanvasComparisonStatic", 80, 1, 1, 5, 201);

for (let i = 0; i < 8; i++) {
    drawGrid("cmsCanvasComparisonStatic", 40, 2, 2, 201 + i * 100, 201, "#999", false, "#fff", 2);
    drawGrid("cmsCanvasComparisonStatic", 80, 1, 1, 201 + i * 100, 201, "#000", false, "#fff", 2);
    drawBits("cmsCanvasComparisonStatic", i, 201 + i * 100, 201, 2, 40, "#000", "#fff");
}
cmsCanvasComparisonStatic.textAlign = "center";
cmsCanvasComparisonStatic.textBaseline = "middle";
cmsCanvasComparisonStatic.font = "28px JetBrains Mono";
cmsCanvasComparisonStatic.fillStyle = "#000";
for (let i = 0; i < 8; i++)
    cmsCanvasComparisonStatic.fillText(i, i * 100 + 240, 310); 
cmsCanvasComparisonStatic.fillText("...", 1040, 240); 
cmsCanvasComparisonStatic.fillText("15", 1140, 310); 
cmsCanvasComparisonStatic.fillText("0", 220, 75); 
cmsCanvasComparisonStatic.fillText("1", 280, 75); 
drawGrid("cmsCanvasComparisonStatic", 40, 2, 2, 1101, 201, "#999", false, "#fff", 2);
drawGrid("cmsCanvasComparisonStatic", 80, 1, 1, 1101, 201, "#000", false, "#fff", 2);
drawBits("cmsCanvasComparisonStatic", 15, 1101, 201, 2, 40, "#000", "#fff");
cmsCanvasComparisonStatic.strokeStyle = "#000";
cmsCanvasComparisonStatic.lineWidth = 2;
cmsCanvasComparisonStatic.beginPath();
cmsCanvasComparisonStatic.moveTo(45, 74);
cmsCanvasComparisonStatic.lineTo(45, 156);
cmsCanvasComparisonStatic.moveTo(45, 166);
cmsCanvasComparisonStatic.lineTo(35, 156);
cmsCanvasComparisonStatic.lineTo(55, 156);
cmsCanvasComparisonStatic.closePath();
cmsCanvasComparisonStatic.stroke();

var bfCanvasCompare = document.getElementById("bfCanvasCompare").getContext("2d");
drawCanvas("bfCanvasCompare", 1280, 460);
drawGrid("bfCanvasCompare", 38, 1, 32, 5, 145);
drawGrid("bfCanvasCompare", 38, 1, 32, 5, 235);
drawGrid("bfCanvasCompare", 38, 1, 32, 5, 385);
drawGrid("bfCanvasCompare", 38, 1, 8, 5, 5);
drawGrid("bfCanvasCompare", 38, 1, 8, 499, 5);
drawGrid("bfCanvasCompare", 38, 1, 8, 841, 5);
bfCanvasCompare.textAlign = "center";
bfCanvasCompare.textBaseline = "middle";
bfCanvasCompare.fillStyle = "#000";
bfCanvasCompare.font = "24px JetBrains Mono";
bfCanvasCompare.fillText("4", 330, 25);
bfCanvasCompare.fillText("17", 474, 25);
bfCanvasCompare.fillText("23", 1170, 25);
bfCanvasCompare.font = "20px JetBrains Mono";
for (let i = 0; i < 32; i++)
    bfCanvasCompare.fillText(i, i * 38 + 24, 200);
for (let i = 0; i < 32; i++)
    bfCanvasCompare.fillText(i + 32, i * 38 + 24, 290);
bfCanvasCompare.font = "16px JetBrains Mono";
for (let i = 0; i < 32; i++)
    bfCanvasCompare.fillText(i + 224, i * 38 + 24, 440);
bfCanvasCompare.font = "28px JetBrains Mono";
bfCanvasCompare.fillText("...", 630, 334);
var bfArrayCompare1 = [4, 17, 23];
drawBlocks("bfCanvasCompare", bfArrayCompare1, "#000", 38, 32, gridXOffset, 145);
var bfArrayCompare2 = [0, 1, 3, 12, 15, 18, 20, 24, 29];
drawBlocks("bfCanvasCompare", bfArrayCompare2, "#000", 38, 32, gridXOffset, 235);
var bfArrayCompare3 = [2, 7, 19, 20];
drawBlocks("bfCanvasCompare", bfArrayCompare3, "#000", 38, 32, gridXOffset, 385);
var bfArrayCompareN1 = [5];
var bfArrayCompareN2 = [3, 7];
var bfArrayCompareN3 = [3, 5, 6, 7];
drawBlocks("bfCanvasCompare", bfArrayCompareN1, "#000", 38, 32, 5, 5);
drawBlocks("bfCanvasCompare", bfArrayCompareN2, "#000", 38, 32, 499, 5);
drawBlocks("bfCanvasCompare", bfArrayCompareN3, "#000", 38, 32, 841, 5);
bfCanvasCompare.strokeStyle = "#000";
bfCanvasCompare.lineWidth = 2;
bfCanvasCompare.beginPath();
bfCanvasCompare.moveTo(5, 55);
bfCanvasCompare.lineTo(309, 55);
bfCanvasCompare.moveTo(175, 55);
bfCanvasCompare.lineTo(175, 115);
bfCanvasCompare.moveTo(175, 125);
bfCanvasCompare.lineTo(165, 115);
bfCanvasCompare.lineTo(185, 115);
bfCanvasCompare.closePath();
bfCanvasCompare.moveTo(499, 55);
bfCanvasCompare.lineTo(803, 55);
bfCanvasCompare.moveTo(671, 55);
bfCanvasCompare.lineTo(671, 115);
bfCanvasCompare.moveTo(671, 125);
bfCanvasCompare.lineTo(661, 115);
bfCanvasCompare.lineTo(681, 115);
bfCanvasCompare.closePath();
bfCanvasCompare.moveTo(841, 55);
bfCanvasCompare.lineTo(1145, 55);
bfCanvasCompare.moveTo(899, 55);
bfCanvasCompare.lineTo(899, 115);
bfCanvasCompare.moveTo(899, 125);
bfCanvasCompare.lineTo(889, 115);
bfCanvasCompare.lineTo(909, 115);
bfCanvasCompare.closePath();
bfCanvasCompare.stroke();</script><style>.setContainer{font:normal .875rem var(--monospace);border:.0625rem solid var(--fg);margin:1rem 0;padding:1rem;line-height:1.25rem;overflow:auto}.highlight{font-weight:800}.found{background-color:var(--green);font-weight:800}</style></article></main><footer><a href=https://ekunazanu.foo/more#Terms_of_Use>© 2025</a> <a href=https://ekunazanu.foo/about>ekunazanu</a> · <a rel="noopener nofollow noreferrer" href=https://creativecommons.org/licenses/by/4.0/ target=_blank>CC BY 4.0</a> · <a rel="noopener nofollow noreferrer" href=https://github.com/ekunazanu/ekunazanu.foo target=_blank>Source</a></footer>